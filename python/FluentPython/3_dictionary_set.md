## 3. dictionary and set

### 일반적인 매핑형
- 파이썬의 고성능 딕셔너리 뒤에는 해시 테이블을 이용해서 구현한다.
- 집합도 해시 테이블을 이용해서 구현한다.
- 표준 라이브러리에서 제공하는 매핑형은 모두 dict를 이용해서 구현하므로, 키가 해시 가능해야 한다는 제한을 갖고 있다.

#### 해시가 가능하다?
- 수명 주기 동안 결코 변하지 않는 해시값을 갖고 있고(`__hash__` 메서드가 필요) 다른 객체와 비교할 수 있으면(`__eq__` 메서드가 필요) 객체를 해시 가능하다고 한다. 동일하고 판단되는 객체는 반드시 해시값이 동일해야 한다.
- 원자적 불변형(str, byte, 수치형)은 모두 해시 가능하다. frozenset은 언제나 해시 가능하다. 이것은 모든 요소가 해시 가능하도록 정의되어 있기 떄문이다.
- 튜플은 들어 있는 항목들이 모두 해시 가능해야 해시 가능하다.

```python
tt = (1, 2, (30, 40)) # hashable
tl = (1, 2, [30, 40]) # not hashable
```

- 사용자 정의 자료형은 기본적으로 해시 가능하다. 기본적으로 객체의 해시값은 id()를 이용해서 구하므로 모든 객체가 서로 다르기 때문이다.

### 지능형 딕셔너리
```python
# example
DIAL = [(22, 'c'), (333, 'b')]
country_code = {country: code for code, country in DiAL}
```

- 모든 반복형 객체에서 키-값 쌍을 생성함을써 딕셔너리 객체를 만들 수 있다.

### 공통적인 매핑 메서드
- `dict.update(m, [**kargs])`에서 m을 다루는 방식은 덕 타이핑의 대표적인 예이다. m이 keys() 메서드를 갖고 있는지 확인한 후, 만약 메서드를 갖고 있으면 매핑이라고 간주한다. keys() 메서드가 없으면, update 메서드는 m의 항목들이 (키, 값)으로 되어 있다고 간주하고 m을 반복한다. 대부분의 파이썬 매핑은 update와 같은 논리를 내부적으로 구현한다.

#### setdefault()
```python
# example
index.setdefault(word, []).append(location) # 단어가 없을 떄는 []을 가져온다.
```

- 이 메서드는 똑같은 키를 여러 번 조회하지 않게 해줌으로써 속도를 향상시켜준다.

### 융통성 있게 키를 조회하는 매핑
- 검색할 떄 키가 존재하지 않으면 특별한 값을 반환하는 매핑 방법

#### defaultdict
```python
index = colletions.defaultdict(list) # list 생성자를 가지고 있는 defaultdict을 생성
index[word].append(location) # word가 없을 경우 빈 리스트를 생성
```

- defaultdict 객체를 생성할 때 존재하지 않는 키 인수로 `__getitem__` 메서드를 호출할 떄마다 기본값을 생성하기 위해 사용되는 callable을 제공한다.
- defaultdict의 default_factiory는 `__getitem__` 호출에 대한 기본값을 제공하기 위해 호출되며, 다른 메서드를 통해서는 호출되지 않는다.

#### `__missing__()` 메서드
- 기본 dict에는 정의되어 있지 않지만, dict는 이 메서드를 알고 있다.
- dict 클래스를 상속하고 `__missing__()` 메서드를 정의하면, `dict.__getitem__()` 표준 메서드가 키를 발견할 수 없을 때 KeyError를 발생시키지 않고 `__missing__()`를 호출한다.
- `__getitem__`을 호출할 때만 `__missing__()`가 호출되며, get() 이나 `__contain__()` 등 키를 검색하는 다른 메서드에는 호출되지 않는다.
- 사용자 정의 매핑형을 만들 때는 dict보다 collections.UserDict 클래스를 상속하는 것이 더 낫다.
- `__missing__()` 메서드는 str(k) 키가 존재할 떄는 k가 문자열이든 비문자열이든 문제없이 작동한다. 그러나 str(k)가 존재하지 않는다면, 이 메서드는 무한히 재귀적으로 호출된다.
- 파이썬3에서는 아주 큰 매핑의 경우에도 `k in dict.keys()` 형태의 검색이 효율적이다. 이 메서드는 집합과 비슷한 뷰를 반환하는데, 집합에 포함되었는지 여부를 검사하는 것은 딕셔너리만큼 빠르기 때문이다.

### 그 외 매핑형
- `collections.OrderedDict`는 키를 삽입한 순서대로 유지함으로써 항목을 반복하는 순서를 예측할 수 있다.
- `collections.ChainMap`은 매핑들의 목록을 담고 있으며 한꺼번에 모두 검색할 수 있다. 각 매핑을 차례대로 검색하고, 그중 하나에서라도 키가 검색되면 성공한다.
- `collections.Counter`은 모든 키에 정수형 카운터를 갖고 있는 매핑, 이 카운터는 해시 가능한 객체(키)나 한 항목이 여러 번 들어갈 수 있는 다중 집합에서 객체의 수를 세기 위해 사용할 수 있다.

### UserDict 상속
- UserDict는 dict를 상속하지 않고 내부에 실제 항목을 담고 있는 data라고 하는 dict 객체를 갖고 있다. 이렇게 구현함으로써, `__setitem__` 등의 특수 메서드를 구현할 때 발생하는 원치 않는 재귀적 호출을 피할 수 있으며, `__contains__` 메서드를 간단히 구현할 수 있다.

### 불변 매핑
```python
from types import MappingProxyType

d = {1: 'a'}
d_proxy = MappingProxyType(d)
d_proxy[2] = 'x' # error occured
```

- 표준 라이브러리에서 제공하는 매핑형은 모두 가변형이지만, 사용자가 실수로 매핑을 변경하지 못하도록 보장하고 싶은 경우 사용한다.
- types 모듈은 MappingProxyType이라는 래퍼 클래스를 제공해서, 원래 매핑의 동적인 뷰를 제공하지만 읽기 전용의 mappingproxy 객체를 반환한다. 따라서 원래 매핑을 변경하면 mappingproxy에 반영되지만, mappingproxy를 직접 변경할 수는 없다.

### 집합 이론
```python
# examples
found = len(needles & haystack) # haystack 안에 needles 항목 수 구함

frozenset({0, 1, 2, 3, 5})
```

- 집합 요소는 반드시 해시할 수 있어야 한다. set은 해시 가능하지 않지만 frozenset은 해시 가능하므로, frozenset이 set에 들어갈 수 있다.
- 집합형은 중위 연산자를 이용해서 기본적인 집합 연산을 구현한다. 'ㅣ'은 합집합, '&'은 교집합, '-'은 차집합을 계산한다.

#### 집합 리터럴
- 공집합은 리터럴로 표기할 수 없으므로, 반드시 set()으로 표기해야 한다. {} 구문을 사용하면 빈 딕셔너리가 생성된다.
- `{1, 2, 3}`과 같은 리터럴 집합 구문은 `set({1, 2, 3})`처럼 생성자를 호출하는 것보다 더 빠르고 가독성이 좋다.
- frozenset은 언제나 생성자를 호출해서 생성해야 한다.

#### 지능형 집합
```python

{chr(i) for i in range(32, 256) if 'SIGN' name(chr(i), '')}
```

### dict과 set의 내부구조

#### 딕셔너리 안의 해시 테이블
- 해시 테이블은 희소 배열이다. 버킷에는 키에 대한 참조와 항목의 값에 대한 참조가 들어간다. 모든 버킷의 크기가 동일하므로 오프셋을 계산해서 각 버킷에 바로 접근할 수 있다.
- 파이썬은 버킷의 1/3 이상을 비워두려고 한다. 해시 테이블 항목이 많아지면 더 넓은 공간에 복사해서 버킷 공간을 확보한다.
- hash() 내장 함수는 내장 자료형은 직접 처리하고 사용자 정의 자료형의 경우 `__hash__`메서드를 호출한다. 두 객체가 동일하면 이 값들의 해시값도 동일해야 한다. 그렇지 않으면 해시 테이블 알고리즘이 제대로 작동하지 않는다.
- str, bytes, datetime 객체의 해시에는 무작위 솔트 값이 적용된다. 솔트 값은 파이썬 프로세스가 실행되는 동안에는 동일하게 유지되지만, 파이썬 프로세스를 새로 실행하면 달라진다.
- dict에서 값을 가져오기 위해 `__hash__`를 호출해서 해시 값을 가져오고, 해시값의 최하위 비트를 해시 테이블 안의 버킷에 대한 오프셋으로 사용한다.
- 해시 충돌은 해시 함수가 임의의 객체를 적은 수의 비트로 매핑하기 떄문에 발생한다. 이를 해결하기 위해 해시의 다른 비트들을 가져와서 특정 방식으로 조작한 후 그 결과를 이용해서 다른 버킷을 조회한다.
- 클래스에서 사용자 정의 `__ep__` 메서드를 구현할 떄는 `__hash__` 메서드도 적절히 구현해야 한다. hash(a) == hash(b)도 언제나 참이 되어야 하기 때문이다.
- 많은 양의 레코드를 처리하는 경우에는, 튜플이나 명명된 튜플의 리스트에 저장하는 것이 좋다. dict 튜플로 교체하면, 레코드마다 하나의 해시 테이블을 가져야 하는 부담과 레코드마다 필드명을 다시 저장해야 하는 부담을 제거하여 메모리 사용량을 줄일 수 있다.
- dict에 항목을 추가할 떄마다 파이썬은 그 딕셔너리의 해시 테이블 크기를 늘릴지 판단한다. 그러므로 기존 키의 순서가 변경될 수 있다. 따라서 딕셔너리를 반복하는 동안 딕셔너리의 내용을 변경하는 것은 좋지 않다.

#### set의 작동 방식
- set도 해시 테이블을 이용해서 구현하지만, 각 버킷이 항목에 대한 참조만을 담고 있다는 점이 다르다.
- set 요소는 모두 해시 가능한 객체여야 한다.
- set의 메모리 오버헤드가 크다.
- 요소의 순서는 요소를 추가한 순서에 따라 달라진다.
- 요소를 집합에 추가하면 다른 요소의 순서가 바뀔 수 있다.