## 2. Sequence

### 내장 시퀸스
- 컨테이너 시퀸스 : 객체에 대한 참조를 담고 있다. (서로 다른 자료형의 항목들을 담을 수 있는 list, tuple, collections.deque 형)
- 균일 시퀸스 : 객체에 대한 참조 대신 자신의 메모리 공간에 각 항목의 값을 직접 담는다. (단 하나의 자료형만 담을 수 있는 str.bytes, bytearray, memoryview, array.array 형)
- 가변 시퀸스 : list, bytearray, array.array, colletions.deque, memoryview 형
- 불변 시퀸스 : tuple, str, bytes 형

### 지능형 리스트(listcomp), 제너레이터(genexp)
- 시퀸스를 간단히 생성할 수 있는 구문들이다.

#### 지능형 리스트
```python
# example
codes = [ord(symbol) for symbol in symbols]
```

- 지능형 리스트로 생성된 리스트를 사용하지 않는다면, 지능형 리스트를 사용하지 말아야 한다.
- 코드를 짧게 만들어야 한다. 지능형 리스트 구문이 두 줄이상 넘어가는 경우에는 코드를 분할하거나 for문을 이용해서 작성하는 것이 더 낫다.
- 지능형 리스트는 오로지 리스트를 만들 뿐이다. 다른 종류의 시퀸스를 채우려면 제너레이터를 사용해야 한다.

```python
# 데카르트 곱 example
tshirts = [(color, size) for color in colors for size in sizes]
```

#### 제너레이터
- 시퀸스형을 초기화하려면 지능형 리스트를 만들지 않고, 반복자 프로토콜을 이용해서 항목을 하나씩 생성하는 제너레이터가 메모리를 더 적게 사용한다.
- 제너레이터는 대괄호 대신 괄호를 사용한다.

```python
# example
tuple(ord(symbol) for symbol in symbols)

for tshirt in ('%s %s' % (c, s) for c in colors for s in sizes):
    print(tshirt)
```

- 제너레이터는 한 번에 하나의 항목을 생성한다. 그렇기 때문에, 단지 for 루프에 전달하기 위해 항목이 들어 있는 리스트를 생성하는 일을 피할 수 있다.
- 메모리에 유지할 필요가 없는 데이터를 생성하기 위해서는 제너레이터를 사용하는 것이 좋다.

### 튜플
- 튜플의 각 항목은 레코드의 필드 하나를 의미하며 항목의 위치가 의미를 결정한다.
- 튜플을 필드의 집합으로 사용하는 경우에는 항목 수가 고정되어 있고 항목의 순서가 중요하다.

#### 더미 변수, 튜플 언패킹
```python
# examples
# _ 는 더미변수를 표현한다.
for contry, _ in ids:
    print(country)

lax = (a, b)
la, lon = lax # 튜플 언패킹

b, a = a, b

t = (1, 2)
div(*t)

a, b, *rest = range(5)
```

- 튜플 언패킹은 반복 가능한 객체라면 어느 객체든 적용할 수 있다.
- 튜플 언패킹을 사용하면 임시 변수를 사용하지 않고도 두 변수의 갑을 서로 교환할 수 있다.
- 함수를 호출할 때 매개변수 앞에 *를 붙여 튜플을 언패킹할 수 있다.
- 함수 매개변수에 *를 연결해서 초과된 인수를 가져오는 방법이 있는데, 병렬 할당의 경우 *는 단 하나의 변수에만 적용할 수 있다.

#### 명명된 튜플
```python
# example
City = namedtuple('City', 'name country')
tokyo = City('Tokyo', 'JP')
```

- colletions.namedtuple()는 필드명과 클래스명을 추가한 튜플의 서브클래스를 생성하는 팩토리 함수로서, 디버깅에 유용하다.
- 필드명이 클래스에 저장되므로 nametuple()로 생성한 객체는 튜플과 동일한 크기의 메모리만 사용한다.
- _fileds는 클래스의 필드명을 담고 있는 튜플이다.
- _make는 반복형 객체로부터 명명된 튜플을 만든다.
- _asdict는 명명된 튜플 객체에서 만들어진 collections.OrderedDict 객체를 반환한다.

#### 튜플 메서드들
- 튜플은 항목을 추가하거나 삭제하는 기능 및 `__reversed__()` 메서드를 제외하고 리스트가 제공하는 메서드를 모두 지원한다. 이 함수는 최적화 때문에 생략되었다.
- reversed() 메서드는 `__reversed()__`를 이용하지 않는다.

### 슬라이싱
```python
# examples
l = [10, 20, 30, 40]
l[:2]

l[2:3]

l[:3:1]

l = list(range(10))
l[2:5] = [20, 30] # [0, 1, 20 ,30, 5, 6, 7, 8, 9]
```

- 파이썬의 모든 시퀸스형은 슬라이싱을 지원한다.
- 슬라이스와 범위 지정시에 마지막 항목을 포함하지 않는 것은 중단점만 이용해서 슬라이스나 범위를 지정할 때 길이를 계산하기 쉽다. 또한, 시작점과 중단점을 모두 지정할 떄도 길이를 계산하기 쉽다. 단지 중단점에서 시작점을 빼면 된다.
- 슬라이스 마지막 항목은 보폭만큼씩 항목을 건너뛰게 만든다. 보폭이 음수인 경우에는 거꾸로 진행된다.
- `a:b:c` 표기법은 인덱스 연산을 수행하는 [] 안에서만 사용할 수 있으며, slice(a, b, c) 객체를 생성한다.
- 세 개의 마침표(...)로 표현된 생략 기호는 파이썬 파서에 의해 하나의 토큰으로 인식된다. 이 기호는 Ellipsis 객체의 별명으로서 하나의 ellipsis 클래스의 객체이다. 생략 기호 객체는 함수의 인수나, 슬라이스의 한 부분으로 전달할 수 있다.
- 슬라이싱 할당의 경우, 항목 하나만 할당하는 경우에도 할당문 오른쪽에는 반복 가능한 객체가 와야 한다.

### 덧셈과 곱셈 연산자, 복합 할당
```python
l = [1, 2, 3]
l * 2 # [1, 2, 3, 1, 2, 3]
l *= 2 # [1, 2, 3, 1, 2, 3]

board = [['_'] * 3 for i in range(2)] # [['_', '_', '_'], ['_', '_', '_']]

weird = [['_'] * 2] * 2
weird[1][1] = '0' # [['_', '0'], ['_', '0']]

```

- 시퀸스는 덧셈과 곱셈을 지원한다.
- 덧셈의 경우 두 피연산자 두 개가 같은 자료형이어야 하며, 둘 다 변경되지 않지만 동일한 자료형의 시퀸스가 새로 만들어진다.
- 하나의 시퀸스를 여러 번 연결하려면 정수를 곱해서 표현한다.
- a * 3과 같은 표현식을 사용할 떄, 주의해야 한다. 리스트의 리스트를 초기화할 떄, 동일한 내부 리스트에 대한 참조를 가진 리스트가 만들어지므로 원치 않는 결과가 나올 수 있다.
- += 연산자가 작동하도록 만드는 메서드는 `__iadd__`이다. 그러나 이 메서드가 구현되어 있지 않다면, `__add__`를 호출한다. 가변 시퀸스에 대해서는 `__iadd__`를 구현해서 += 연산자가 기존 객체의 내용을 변경하게 만드는 것이 좋다. 불변 시퀸스의 경우에는 이 연산을 수행할 수 없다.
- 가변 시퀸스의 복합 할당의 경우 기존 객체에 새로운 항목을 추가하지만, 불변 시퀸스의 복합 할당의 경우 시퀸스 전체를 새로 만들어 타깃 변수에 저장한다. 그러므로 불변 시퀸스에 반복적으로 연결 연산을 하는 것은 비효율적이다.
- 가변 항목을 튜플에 넣는 것은 기괴한 작동을 보이므로 좋은 방법이 아니다. 또한, 복합 할당은 원자적인 연산이 아니다. 그리고 파이썬 바이트 코드를 보는 것은 어렵지 않으며(`import dis, dis.dis('a+=b')`) 내부 작동을 파악하는데 도움이 된다.

### list.sort()과 sorted()
- list.sort() 메서드는 사본을 만들지 않고 리스트 내부를 변경해서 정렬한다. sort() 메서드는 타킷 객체를 변경하고 새로운 리스트를 생성하지 않았음을 알려주기 위해 None을 반환한다.
- 객체를 직접 변경하는 함수나 메서드는 객체가 변경되었고 새로운 객체가 생성되지 않았음을 호출자에 알려주기 위해 None을 반환해야 한다. 그러나 None을 반환하는 메서드는 연결해서 호출할 수 없다.
- sorted() 함수는 새로운 리스트를 생성해서 반환한다. 이 함수는 불변 시퀸스 및 제너레이터를 포함해서 반복 가능한 모든 객체를 인수로 받을 수 있다.

### bisect 모듈
```python
haystack = [1, 2, 4, 10]
needle = [2, 5, 11]

bisect(haystack, needle) # 1, 2, 4, 5, 10 ,11

def grade(score, breakedpoints=[60, 70, 80, 90], grades='FDCBA')
    i = bisect.bisect(breakpoints, score)
    return grades[i]

[grade(score) for score in [33, 99, 77, 70, 89, 90, 100]] # ['F', 'A', 'C', 'C', 'B', 'A', 'A']
```

- bisect 모듈은 bisect()와 insort() 함수를 제공한다.
- bisect(haystack, needle)은 정렬된 시퀸스인 haystack 안에서 오름차순 정렬 상태를 유지한 채로 needle을 추가할 수 있는 위치를 찾아낸다.
- bisect_right(), bisect_left()는 haystack 기준으로 오른쪽에 넣을지 왼쪽에 넣을지를 결정한다.
- 정렬은 값비싼 연산이다 그러므로 일단 시퀸스를 일단 정렬한 후에는 정렬 상태를 유지하는 것이 좋다. 그렇기에 bisect.insort(seq, item) 함수를 사용한다. 이 함수는 seq를 오름차순으로 유지한 채로 item을 seq에 삽입한다.

### 리스트의 대안
- 숫자들로 구성된 리스트를 다루고 있다면 배열을 사용하는 것이 좋다.
- 리스트의 양쪽 끝에 항목을 계속 추가하거나 삭제하면서 FIFO, LIFO 데이터 구조를 구현할 때는 덱(deque)가 더 빠르다.

#### 배열(array.array)
```python
floats = array('d', (random() for i in range(10**7)))
```

- 파이썬의 배열은 C 배열만큼 가볍다. 또한, 배영형에 맞지 않는 숫자를 저장할 수 없게 한다.
- 빠르게 파일에 저장하고 읽어올 수 있는 frombytes()와 tofile()를 제공한다. tofile()의 경우 그냥 실수 한 행을 파일에 저장하는 것보다 7배 빠른 성능을 보인다.
- 배열을 정렬하려면 sorted()를 사용하여야 한다.
- 객체를 직렬화하는 pickle 모듈도 숫자 데이터를 빠르고 융통성 있게 저장할 수 있다.

#### 메모리 뷰
- 메모리 뷰는 공유 메모리 시퀸스형으로서 bytes를 복사하지 않고 배열의 슬라이스를 다룰 수 있게 해준다.
- 메모리 뷰는 데이터 구조체를 복사하지 않고 메모리를 공유할 수 있게 해준다. 데이터셋이 커지는 경우 이것은 아주 중요한 기법이다.

#### 덱 및 기타 큐
- 덱은 큐의 양쪽 어디에서든 빠르게 삽입 및 삭제할 수 있도록 설계된 스레드 안전한 양방향 큐이다. 덱은 최대 길이를 설정해서 제한된 항목만 유지할 수도 있으므로 덱이 꽉 찬 후에는 추가하는 방향의 반대쪽 항목을 버린다.
- 덱의 append, popleft 메서드는 원자성을 가지고 있으므로 멀티스레드 앱에서 락을 사용하지 않고도 덱을 이용해서 FIFO 큐를 구현할 수 있다.
- 단점으로는 덱의 중간 항목을 삭제하는 연산은 그다지 빠르지 않다.
- 큐 모듈에서는 스레드 안전한 Queue, LifoQueue, PriorityQueue 클래스를 제공한다. 이 클래스들은 스레드 간에 안전하게 통신하기 위해 사용된다. 덱과 달리 항목이 꽉차있을 때는 추가를 블로킹하고 다른 스레드에서 큐 안의 항목을 제거해서 공간을 확보해줄 때까지 기다린다. 따라서 활성화된 스레드 수를 조절하기 좋다.
- mulitprocessing 모듈은 큐모듈의 Queue와 비슷하지만 프로세스 간 통신을 지원하게 위해 설계된 Queue를 지원한다.
- asyncio는 비동기 환경에서 작업하기 위한 Queue, LifoQueue, PriorityQueue, JoinableQueue를 제공한다.
- headq는 queue 클래스를 구현하지 않지만, 가변 시퀸스를 힙 큐나 우선순위 큐로 사용할 수 있게 해준다.

### 기타
- 리스트에 항목을 넣는 이유는 나중에 항목을 처리하기 위한 것이므로, 모든 항목이 어떤 연산을 공통적으로 지원해야 한다. 그러므로 리스트에 여러 자료형을 넣는 것은 그리 쓸모 있지 않다.
- 튜플은 각 항목이 실제로는 하나의 필드이고, 각 필드의 형은 서로 독립적이다.
- list.sort(), sorted()등의 key는 효율적이다. 또한, 이를 사용하면 숫자와 숫자 형태의 문자열로 구성된 리스트도 정렬할 수 있다.
- sorted()와 list.sort()에 사용된 정렬은 팀 정렬이다. 팀 정렬은 데이터의 정렬된 정도에 따라 삽입 정렬과 병합 정렬 사이를 전환하는 적응형 알고리즘이다.