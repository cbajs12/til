### Basic

#### 변수
- 변수명은 문자, 숫자 , 밑줄(_) 포함 가능
- 대소문자를 구별한다.
- 다중치환 지원 `a = b = c = 1`

#### 자료형
- 정수앞에 `0o`붙이면 8진수, `0b`붙이면 2진수, `0x` 붙이면 16진수로 인식한다.
- 진수변환 함수, oct, hex, bin이 존재하며, 결과값은 String이다.
- float은 실수를 표현하고, 지수형으로도 표현 가능
- complex는 복소수를 표현, real은 실수부, imag는 허수부를 나타낸다. conjugate()는 켤레복소수를 반환한다.
- 연산자
> - `+`. `-`, `*`, `/` , `%`, `**` (거듭제곱),` //`(정수나누기-나누기 후 정수부분만 반환)

### 문자
- '', "" 모두 사용가능, 대량의 문자열은 """ """, ''' '''를 사용
- 이스케이프 문자들 : `\n`, `\t`(탭), `\r`, `\0`(널), `\\`( \ ), `\'`, `\"` 
- 문자열 앞에 r을 붙여 이스케이프 문자를 적용시키지 않을수 있다. `print(r"hey\n") # hey\n`
- `+` : 문자열 병합, `*` : 문자열 반복
- 문자열은 자동으로 인덱싱이 된다. (인덱싱을 통한 수정은 불가)
- 슬라이싱 : `[시작:끝]`
- 문자열과 수치간 변환 : str(), int(), float() ...
- `chr()`: 문자의 유니코드값을 반환
- `ord()`: 유니코드값을 문자로 변환

####  List
-  순서가 존재하며, 여러 종유의 값을 담을수있다. 
-  extend()는 튜플이나 리스트등의 여러값을 한번에 넣을수 있다. 
-  index()는 값의 인덱스를 보여주는데 중복값 존재시 첫번째 위치만을 보여준다.
-  더하기 연산자로 추가 가능한데, 리스트나 튜플 사용없이 문자열을 넣으면 각 문자가 쪼개서 들어가진다.
` c += red : c[r, e, d]`
- 생성자  `list()`
- `in` 연산자로 내부에 값이 존재하는지 확인가능 `2 in b : true`

#### Set
- 값이 순서가 없고, 중복이 없는 집합
- `-`: 차집합, `|`: 합집합, `&`: 교집합 연산자 존재
- 생성자 `set()`
- `in` 연산자로 내부에 값이 존재하는지 확인가능 `2 in b : true`

#### tuple
- 리스트와 비슷하지만 `()`를 사용하고 수정을 제외한 모든 기능이 존재한다.
- 속도는 리스트비해  빠르다.
- 생성자 `tuple()`
- `in` 연산자로 내부에 값이 존재하는지 확인가능 `2 in b : true`
- 함수에서 여러 값 반환시에 편리

#### dictionary
- 키와 값으로 구성되어 있는 자료구조
- 생성자 `dict()`
- 2.x에서는 `items()`, `keys()`, `values`의 반환값은 리스트였지만, 3.x에서는 딕셔너리로 변경. 예전처럼 리스트로 받으려면 추가 작업해야함 `list(c.keys)`
- `defaultdict('자료형')` : 존재하지 않는 key가 주어진다면, 이 key와 인자에서 주어진 값으로 dict에 새로운 항목을 추가해 준다.

#### bool
- `or`사용시 첫번째 값이 참이면, 두번쨰 값은 보지 않는다.
- 0, '', None는 false로 간주한다.

#### 얕은 복사, 깊은 복사
- 모든 변수는 해당 객체의 주소를 가지고 있다.
- `id()`는 객체의 고유한 값을 반환
- `copy()`는 얕은복사, `deepcopy`는 깊은복사를 한다. (`import copy` 필요)

#### Counter
- key와 value의 빈도를 연결 시켜준다. `c = Counter([0,1,2,0]) # c = {0:2, 1:1,2:1}`
- 단어의 개수를 셀때에도 유용(`most_common()`)

#### List Comprehension
- 기존 리스트에서 특정항목 선택 혹은 변환시킨 결과를 새로운 리스트에 저장하는 경우 처리하는 방법
> nums = [x for x in range(5) if x % 2 == 0]  # [0, 2, 4] 
> pairs = [(x, y) for x in range(10) for y in range(22)]

#### Generator
- Generator는 반복할수 있으며, 내부의 각 항목은 필요한 순간에 그때그때 생성한다.
- 메모리의 제약을 받지 않을수 있다.
- 생성방법중 하나는 함수와 yield를 사용하는것
- Generator는 단 한번만 반복할수 있다. 여러번 반복하려면, 매번 생성하거나 list를 사용해야한다. 
```python
def lazy_range(n):
   i = 0
   while i < n:
      yield i
      i += 1
```

#### random
- 난수 생성시 사용
- 동일한 고정된 난수를 사용하고 싶으면 `seed()`
- 구간안에서 난수 생성 `randrange()`
- list의 항목의 임의순서로 재정렬 `shuffle`
- list의 임의 항목을 선택 `choice`
- list에서 중복이 허용되지 않는 임의의 표본 list `sample`

#### enumerate
- 인덱스 또는 항목 형태의 tuple을 생성
```python
for i, document in enumerate(documents):
   do_something(i, document)

for i, _ in enumerate(document): do_something(i)
```

#### args, kwargs
- `*`는 argument unpacking(인자 해체)를 할때 사용하는데, 뒤에 오는 자료구조의 항목들을 개별적인 인자로 전달한다.
- `*args`는 이름이 없는 인자로 구성된 튜플 또는 리스트
- `**kwargs`는 이름이 주어진 인자로 구성된 dict
