## Control
### 조건
- 조건식에서 `0`, `0.0`, `()`, `{}`, `[]`, `(")`, None은 항상 거짓으로 판단
- 논리 연산자 `&`와 `|`는 단축평가를 하지 않지만, `and`와 `or`는 단축평가를 실시한다. (단축평가는 조건식 전체를 판단하지 않고 순차적으로 진행하다가 수식의 평가가 자명한 경우 뒤의 수식을 평가하지 않는것을 의미)

### for문
- for문은 시퀸스 객체의 아이템을 순차적으로 가져와 블록 구문을 실행한다. 그렇기 때문에 문자열, 리스트, 이터레이터, 연산자 재정의한 `__iter__` 또는 `__next__`등이 사용 가능하다.
```python
for i in L:
	if i%2 == 0:
    	continue
else:
	print("Exit without break") #break로 루프가 종료되지 않은 경우 출력
```

### 제어관련 함수
- range() : 수열을 만들어 내는 함수이다, `range('시작값', '종료값, '증가값')`, 종료값은 필수 항목이다, 이터레이션이 가능한 객체가 반환된다.
- enumerate() : 항목값과 인덱스 값을 동시에 만들어 낸다, `enumerate('시퀸스 타입 객체', '시작값')`, 시작값은 인덱스 순번의 시작값으로 생략 가능, 튜플 형태로 반환
- List Comprehensions : 기존의 리스트 객체를 이용해 조합, 필터링등의 추가적 연산을 통해 새로운 리스트 객체를 생성할때 효율적

> `<표현식>` for `<아이템>` in `<시퀸스 타입 객체>` (if `<조건식>`)
```python
l = [1,2,3,4,5]
[i for i in l if i > 3] # [4, 5]
lt = [9,10,11]
[x * y for x in l for y in lt]
```

- filter() : 이터레이션 가능한 객체를 순회하며, 함수의 결과가 true인 경우만 묶어 해당 이터레이터 객체를 반환, `filter('함수' | None, '필터링할 대상(이터레이션 가능해야)')`, None은 필터링 수행하지 않고 모든 아이템 반환, 새로운 이터레이터 객체를 반환하므로 기존 객체에 변경은 없다, 결과값을 객체에 저장하려면 내장함수 list(), tuple(), dict()등을 이용해야 한다.
```python
def GetBigger(i):
	return i > 20
l = [10, 20, 40]
Iter = fileter(GerBigger, l)
```

- zip() : 2개 이상의 시퀸스형이나 이터레이터형 객체를 튜플 형태로 서로 쌍을 묶을수 있다, 결과값을 객체에 저장하려면 내장함수 list(), tuple(), dict()등을 이용해야 한다. zip()함수로 결과를 분리하기 위해 결합된 객체에 `*`붙여 분리할수 있다, 인자의 개수가 동일하지 않는경우 가장 짧은 쪽을 기준으로 결합하고 나머지는 포함하지 않는다.
```python
x = [10,20,30]
y = ['a','b','c']
res = list(zip(x,y))
x2, y2 = zip(*res)
```

- map() : 객체를 순회하며 각 아이템을 첫 인자인 함수에 전달하고 결과를 이터레이터 객체로 생성해 반환한다, `map('함수', '이터레이션 가능객체')`
```python
def pow(x,y):
	return x**y
x = [1,2,3]
y = [2,3,4]
res = list(pow, x, y) # [1, 8, 81]
```

### 효율적인 순회 방법
- for, join, List Comprehensions을 이용할수 있다.
- for는 아이템 수만큼 print호출, join과 list comprehensions은 한번만 호출
```python
l = ['a','b','c']
for i in l:
	print(i)
print("\n".join(l))
print("\n".join(i for i in l))
```
