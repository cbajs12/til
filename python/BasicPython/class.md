## Class
- 클래스에 이름공간에 속한 멤버함수를 `메서드`라 한다.
- 각 클래스에서 공통된 부분을 추출해 기본 클래스로 작성하는 작업을 `추상화`라 한다.
- 추상화 결과로 작성된 클래스를 `부모 클래스`, 이를 받아서 각 특성을 추가한 클래스를 `자식 클래스`라고 한다. 이 관계를 상속관계라 한다.
- 클래스는 일종의 도장 역할이고, 실체가 필요할때 도장 찍듯이 `인스턴스`객체를 생성한다.
- 동일한 인터페이스에 대해 구체적인 인스턴스마다 다른 동작을 수행하는 특징을 `다형성`이라 한다.

### 선언
```python
class MyClass:
   def print(self):
      return "hi"
c = MyClass()
```
- 선언 동시에 클래스 객체가 생성된다.
- 정의한 클래스를 사용하려면 인스턴스 객체를 만들어야 한다.
- 인스턴스 객체가 변경되기 전까지는 클래스 객체와 동일한 데이터와 메서드를 가리킨다.
- 인스턴스의 데이터가 변경되면 클래스 객체의 데이터와 구분하기 위해 인스턴스 객체 이름공간에 변경된 데이터를 저장한다. `c.name = 'park'`
- 기본적으로 클래스, 인스턴스의 모든 멤버 변수와 메서드의 접근은 `public`이다.
- 메서드의 첫인자가 `self`인데, 이것은 현재 인스턴스 객체를 가르키는것이다. 이를 통해 인스턴스 객체의 이름공간에 접근하기 때문에 `클래스 공간의 static 메서드`나 `클래스 메서드를 제외`하고 명시적으로 메서드의 첫인자는 `self`를 사용한다.

#### 바운드 메서드, 언바운드 메서드
- 클래스의 메서드는 클래스 객체의 이름공간에 선언된다. 
- 인스턴스 객체가 클래스의 메서드를 호출하면 자기 이름공간에 대한 정보를 호출하는 메서드에게 전달해야한다.
- 메서드를 호출할때 암묵적으로 첫인자로 인스턴스 객체를 넘기는 호출 방식을 `바운드 메서드`라 한다. 
- 메서드를 정의할 때 첫인자가 인스턴스 객체임을 선언하나, 호출할 때는 자동으로 반영 되어 명시적으로 입력하지 않는다. `c.print()`
- 메서드 호출시 명시적으로 첫인자로 인스턴스 객체를 전달하는 호출 방식을 언바운드 메서드 호출이라 한다.
- 클래스 객체를 통해 메서드를 호출하며, 첫인자로 인스턴스 객체를 입력해야 한다. `MytClass.print(c)`

### 객체와 이름공간
- 인스턴스 객체를 통해 변수나 함수 찾는경우 인스턴트 -> 클래스 -> 전역 영역 순으로 찾는다.
- 그렇게 해도 찾기 못하는 경우 `AttributeError`예외 발생한다.
- 파이썬에서는 런타임에 각 클래스와 인스턴스 이름공간에 멤버변수를 추가 또는 삭제가 가능하다, 그 이유는 클래스와 인스턴스 이름공간이 분리되었기 때문이다.
- 클래스 객체와 인스턴스 객체에 동적으로 멤버변수를 추가 또는 삭제할수있다.
- 인스턴스 객체에 동적으로 멤버 변수를 추가하는 경우, 추가한 인스턴스 객체를 통해서만 접근할수 있다. `c.age=20`
- 멤버 메서드에서 `self`가 누락되는경우, 즉 self를 이용해 클래스 멤버에 접근하지 않는 경우 이름이 동일한 전역 변수에 접근해서 출력한다.
- 인스턴스 객체가 자신을 생성한 클래스 객체를 참조하기 위해 인스턴스 객체의 내장 속성 `__class__`가 있다.
- 인스턴스 객체가 어떤 클래스로부터 생성됐는지 확인하는 내장 함수 `isinstance('인스턴스 객체','클래스 객체')`

### 생성자, 소멸자
- 생성자는 인스턴스 객체가 생성될때 자동으로 호출 `__init__()`
- 소멸자는 인스턴스 객체의 레퍼런스 카운터가 `0`이 될때 호출`__del__()`
- 인스턴스 객체를 생성한 후 레퍼런스 카운터가 1개 이상 존재한다면 del구문을 사용해도 소멸자는 호출되지 않는다.

### static, class 메서드
- static메서드는 인스턴스 객체를 통하지 않고 클래스를 통해 직접 호출할수 있는 메서드
- 메서드 정의할때 `self`인자를 선언하지 않는다.
- 클래스 메서드의 경우 암묵적으로 첫인자로 클래스 객체가 전달된다.
- `<메서드 이름> = staticmethod('클래스내에 정의한 메서드 이름')`
- `<메서드 이름> = classmethod('클래스내에 정의한 메서드 이름')`
```python
class MyClass:
   def print():
      return "park"
   def classPrint(cls):  # 암묵적으로 첫인자는 클래스를 받음
      return "print"
   Print = staticmethod(print)
   Cprint = classmethod(classPrint)
```
- 정의된 정적 메서드와 클래스 메서드는 클래스뿐 아니라 인스턴스 객체를 통해서도 호출가능

#### Naming Mangling
- 파이썬에서 기본 속성이 `public`이라서 외부에서 접근하거나 변경할수있다. 그것을 `Naming Mangling`으로 해결했다. 
- 클래스 내의 멤버 변수나 함수를 정의할때 이름이 `__`로 시작하는 경우 클래스 외부에서 참조할때 자동적으로 `_[클래스이름]__[멤버이름]`으로 변경된다. 
- 클래스 내에서는 정의한 `__[멤버이름]`만 사용가능하다.
- 이런 변수는 외부에서 접근할시에 클래스 내에 동일한 이름이 없다는 `NameError`가 발생

### 연산자 중복 정의
- 두개의 밑줄 문자(`__`)가 앞뒤로 있는 메서드는 연산자 중복을 위해 미리 정의된 특별한 메서드이다.
- 기본적으로 제공되는 연산자 중복 정의가 없으므로 개발자가 명시적으로 중복하지 않은 연산자를 사용하는 경우 `TypeError`발생

### 상속
- 자식 클래스 선언부의 헤더에 상속받을 부모 클래스 리스트를 괄호 사이에 기입한다. `class Student(Person)`
- 두 클래스 간의 관계를 확인하기 위해 `issubclass('자식클래스', '부모클래스')`를 사용한다.
- 어떤 클래스의 부모 클래스를 알기 위해서는 `__bases__`속성을 사용해 알아내실수 있다.
- 명시적으로 부모 클래스의 생성자를 호출해야한다. 이때 인스턴스 객체를 나타내는 인자 `self`를 함께 전달해야 한다. `Person.__init__(self, name)`
- 메서드를 재정의 하려면 부모 클래스에 정의된 메서드와 이름만 같으면 된다. 그 이유는 이름공간의 속성 정보가 내부적으로 사전 형식으로 관리되기 때문
- 메서드를 확장할때, 자식 클래스 메서드에 부모 클래스를 명시적으로 호출하면 기능을 최소한의 작업으로 확장할수 있다.
```python
def PrintInfo(self):
   Person.PrintPerson(self)
   print("hello")
```
- 자식 클래스가 상속받은 멤버 메서드에 대해 재정의하지 않거나 멤버 데이터에 새로운 값을 할당하지 않은 경우, 자식 클래스 내부의 이름공간에 해당 데이터와 메서드를 위한 저장 공간을 생성하는 대신 부모 클래스의 이름공간에 존재하는 데이터와 메서드를 참조한다.
- 클래스 객체와 인스턴스 객체의 이름 정보는 내부 변수 `__dict__`에 사전 형식으로 관리 된다.

#### 다중상속
- 자식 클래스 선언부의 헤더에 상속받을 클래스를 괄호 사이에 `,`을 구분자로 해서 작성한다. `class Liger(Tiger, Lion)`
- 다중 상속된 클래스의 나열 순서가 검색 결과에 영향을 준다. 두 부모클래스가 같은 메서드를 가질경우, 첫번째 클래스에서 먼저 메서드를 찾아 호출한다.
- 다양한 상속 구조에서 메서드의 이름을 찾는 순서는 `__ㅡmro__`에 튜플로 정의되어 있다.
- `super()`는 부모 클래스의 객체를 반환한다.
- `super().메서드이름(매개변수)`형태로 부모 클래스의 메서드를 호출한다.
- 클래스 간에 상호 동작으로 다중 상속의 문제를 파악해서 호출한다.
- 명시적으로 클래스의 이름과 인스턴스 객체를 인자로 전달해서 호출할수 있다. `super(Liger, self).__init__()`
