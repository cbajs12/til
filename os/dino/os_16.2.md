# 분산 OS

## 통신구조

### 지명과 이름 변환
- 네트워크 통신에 있어서 고려되어야 할 첫 번째 요소는 네트워크 있는 시스템들에게 이름을 부여하는 방법이다. 이를 지명이라고 한다.
- 원격 시스템 상에 존재하는 프로세스는 일반적으로 호스트 이름과 식별자에 의해 식별된다. 호스트 이름은 네트워크 내에서 유일하고, 식별자는 해당 호스트 내의 프로세스 ID나 혹은 고유한 번호이다.
- 네트워크는 바인딩 기법을 사용하여 호스트 이름을 IP 주소로 변경하는 방법을 사용한다. 네트워크는 DNS를 통하여 이름-주소 변환뿐 아니라 호스트 이름의 구조도 정의한다. 이름 구조의 각 구성요소들은 "."으로 나누어져 있으며, 각 네임 서버를 가진다. 이 네임 서버는 시스템 내의 보통 프로세스이다. 이 네임 서버는 요청된 이름을 받아서 그 이름을 담당하는 네임 서버의 주소를 반환한다. 그러고 나서, 그 네임 서버로 접속되고 그것은 요청된 이름의 주소를 반환한다.
- 각 네임 서버는 보통 지역 캐시를 가지고 있어 성능을 향상시킨다. 캐시가 가진 내용이 변경되었다면 이것을 갱신해야 한다. 네임 서비스는 중요한 것이기 때문에 프로토콜 내에 많은 최적화와 안전장치들이 있다. 중요한 네임서버의 내용을 가지고 있는 백업 네임 서버를 둘 수 있다.
- 도메인 네임 서버에서는 각 네임 서버 사이트가 자기 도메인의 호스트 정보만 갱신하면 된다. 도메인 내의 이름-주소 변환에 대한 처리를 분산시키기 위해 여러 개의 서브 도메임을 둘 수도 있다.
- Java는 IP 이름을 IP 주소로 변환하는 프로그램을 설계하는 데 필요한 API를 제공한다.
- 일반적으로 OS는 여러 프로세스들로부터 `<호스트 이름, 식별자>`의 형태로 목적지가 지정된 메시지를 받아들이고 그 메시지를 적당한 호스트로 전송하는 작업을 담당한다. 목적지 호스트의 커널은 식별자가 지정하는 프로세스로 메시지를 전달하는 역할을 한다.

### 라우팅 전략
- 각 호스트들은 각자의 라우팅 테이블을 가지고 있고, 이 테이블은 다른 사이트들에게 메시지를 보내기 위해 사용될 수 있는 경로들을 가진다. 이 테이블에는 여러 통신 경로에 대한 속도 및 비용 등에 대한 정보들이 포함될 수 있고, 이런 정보들은 필요할 때 수작업 또는 라우팅 정보를 교환하는 프로그램에 의해 갱신될 수 있다.
- 고정 라우팅: A에서 B로의 경로가 미리 정해져 있으며, 하드웨어 고장이 발생하여 그 경로를 사용하지 못하게 되지 않는 한 경로를 바꾸지 않는다. 보통은 최단 거리 경로가 지정된다.
- 가상 라우팅: A에서 B의 경로가 한 세션동안만 고정된다. 다른 세션에서는 A에서 B의 경로가 달라질 수 있다. 세션은 파일 전송처럼 짧을 수도 있고 원격 로그인처럼 길수도 있다.
- 동적 라우팅: A에서 B로의 경로는 메시지가 보내질 때 결정된다. 경로 선택이 동적으로 결정되기 때문에, 메시지들은 서로 다른 경로들을 배정받을 수 있다. 일반적으로 메시지를 사용률이 가장 낮은 링크를 통해서 보낸다.
- 고정 라우팅은 링크 고장이나 부하의 변화에 적응할 수 없다. 이 문제는 가상 라우팅으로 부분적으로, 동적 라우팅으로 완전히 해결 가능하다. 고정 라우팅과 가상 라우팅에서는 메시지가 순차적으로 전달되는 반면, 동적 라우팅에서는 메시지가 순차적으로 전달되지 않는다. 이 문제는 메시지에 일련번호를 붙임으로써 해결될 수 있다.
- 고정 라우팅과 동적 라우팅을 혼용해서 사용할 수 있는데, 호스트들은 지역 네트워크를 다른 네트워크에 연결하는 시스템(게이트웨이)에 접근 방법만 알고 있으면 된다. 지역 네트워크의 각 호스트들은 게이트웨이로 정적 라우팅을 하고, 반면에 게이트웨이 자신은 동적 라우팅을 사용해서 다른 네트워크 호스트에 접근한다.
- 라우터는 컴퓨터 네트워크의 한 구성요소로서, 메시지의 라우팅을 담당한다. 라우터는 적어도 두 개의 네트워크에 연결되어 있어야 한다. 라우터는 메시지의 목적지 주소에 의해 다음 전달할 곳을 선택한다. 정적 라우팅인 경우 테이블은 새로운 파일을 라우터에 로드하는 방법으로 수동적으로만 갱신된다. 반면 동적 라우팅인 경우 라우터 간에 라우팅 프로토콜이 사용되는데, 이 프로토콜을 이용해 서로 네트워크 변화를 알려주고 자동적으로 자신들의 라우팅 테이블을 갱신한다.

### 패킷 전략
- 메시지의 길이는 가변적이다. 시스템의 설계를 간단하게 하기 위하여 패킷, 프레임 또는 데이터그램이라 불리는 고정된 크기의 메시지가 사용된다. 패킷 형태로 구현된 통신은 무연결 메시지 형태로 데이터를 전송한다. 무연결 메시지는 신뢰성이 없다고 할 수 있다. 대안으로, 목적지로부터 패킷 수신을 알리는 패킷이 돌아오는 경우에는 신뢰성이 있다고 할 수 있다. 두 통신자 사이에 양방향으로 패킷이 전달될 필요가 있으면 신뢰성을 높이기 위하여 연결이 구축되어야 한다.

### 연결 전략
- 메시지들이 상대에게 도달하면, 프로세스들은 통신 세션을 만들어 정보를 교환한다. 일반적인 방법은 회선 교환, 메시지 교환, 패킷 교환 방식이 있다
- 회선 교환: 두 프로세스가 통신할 때 고정된 물리 링크가 설정되고, 그 링크는 세션 동안 할당도니다. 이 두 프로세스가 실제로 통신을 실행하지 않는다 해도 한 번 설정된 세션 동안은 다른 프로세스들은 이 링크를 사용할 수 없다.
- 메시지 교환: 두 프로세스가 통신할 때, 임시 링크가 하나의 메시지 전송 기간 동안 설정된다. 물리적인 링크들은 필요할 때마다 동적으로 할당되고, 아주 짧은 시간 동안만 할당된다. 각 메시지는 시스템 정보들을 가진 데이터 블록이다. 시스템 정보들은 통신 네트워크가 그 메시지를 목적지에 정확히 전달하는 데 필요한 정보들이다.
- 패킷 교환: 하나의 논리 메시지는 여러 개의 패킷으로 나뉘어진다. 각 패킷들은 독립적으로 해당 목적지로 전송되며, 따라서 각 패킷은 출발지와 목적지 주소를 가지고 있다. 각 패킷은 서로 다른 경로로 전달될 수 있다. 패킷들은 목적지에 도착하면 원래의 메시지로 재결합되어야 한다. 데이터는 패킷 단위로 독립적으로 라우팅되고 재결합하는데 문제 없지만, 음성 신호를 패킷 분리하고 재결합하는 것은 조심하여야 한다.
- 회선 교환은 초기 설정 시간이 필요하고 대역폭도 낭비되지만, 단일 메시지 전송 당 오버헤드는 적다. 반면에, 메시지 교환과 패킷 교환은 초기 설정 시간은 작지만, 단일 메시지 전송 당 오버헤드는 커진다. 패킷 교환에서는 각 메시지들은 패킷으로 분리되어야 하고, 재결합되어야 한다. 패킷 교환은 네트워크 대역폭을 가장 효율적으로 사용하기 때문에 데이터 네트워크에 적합하다.

### 경쟁
- 하나의 링크를 공유하는 사이트들은 동시에 그 링크를 통해 정보를 전송하려고 하는 경우가 발생할 수 있다. 이렇게 전송되는 정보는 충돌에 의해 손상되기 때문에 그 정보들은 반드시 폐기되어야 한다. 반복적인 충돌을 회피하기 위해 충돌 탐지(CD)와 토큰 패싱이 있다.
- CSMA/CD: 메시지를 링크로 전송하기 전에 사이트는 현재 다른 메시지가 그 링크를 사용하고 있는가를 확인해야 한다. 이 기법을 CSMA라 한다. 링크를 아무도 사용하고 있지 않으면 그 사이트는 전송을 시작할 수 있다. 다른 사이트에서 사용중이면 링크가 사용중일 때까지 기다려야 한다. 둘 이상의 사이트가 동시에 전송을 시작하면 충돌 탐지 상황으로 인지하고 전송을 멈춘다. 이후 각 사이트들은 임의의 시간이 흐른 후 메시지 재전송을 시도한다. 이 기법의 문제점은 통신 부하가 많을 때는 충돌이 빈번하게 발생하기 때문에 성능에 문제가 된다. 그러나 이 기법은 이더넷 시스템에서 성공적으로 사용되고 있다. 충돌의 횟수를 제한하는 한 방법은 이더넷 네트워크 당 호스트의 수를 제한하는 것이다. 네트워크 성능을 적당하게 유지하기 위해서는 이더넷 네트워크 당 시스템의 수를 감소시켜야 한다.
- 토큰 패싱: 토큰이라는 특수한 메시지가 시스템을 계속해서 순환한다. 정보를 전송하고자 하는 사이트는 토큰이 도착할 때까지 기다려야 하며, 토큰이 도착하면 토큰을 없애고 전송을 시작한다. 그리고 메시지 전송이 끝나면 이전 토큰을 다시 순환시킨다. 토큰 패싱 네트워크의 장점은 성능을 일정하게 유지할 수 있다는 것이다. 그러나 부하가 적은 네트워크의 경우, 이더넷의 시스템들은 임의의 순간에 메시지를 전송할 수 있기 때문에 토큰 패싱보다 효율적이다.

## 통신 프로토콜
- 통신 네트워크의 설계 및 구현상의 문제들은 여러 층으로 문제를 분할함으로써 단순화할 수 있다. 한 시스템의 각 층은 다른 시스템에 존재하는 동등한 층과 통신한다. 통상 각층은 자신의 고유한 프로토콜을 가질 수 있고 특정 프로토콜을 사용하여 피어 간에 통신이 일어난다. 이러한 프로토콜들은 하드웨어 또는 소프트웨어로 구현된다.

### ISO 계층
- 물리 층: 비트 스트림을 물리적으로 전송하기 위한 기계적, 전기적 사항들을 담당한다. 물리 층에서 통신 시스템들의 이진수 0과 1의 전기적 표현이 일치해야만 한다. 왜냐하면, 수신측이 전기 신호의 스트림을 올바른 이진 데이터로 해석이 가능해야 하기 때문이다. 이 층은 하드웨어로 구현된다.
- 데이터 링크 층: 데이터 링크 층은 물리 층에서 발생되는 오류에 대한 감지와 복구 등 프레임 관련 작업을 담당한다.
- 네트워크 층: 네트워크 층은 통신 네트워크 내의 연결 및 패킷 라우팅을 담당한다. 즉, 나가는 패킷의 주소를 조정하고 들어오는 패킷의 주소를 해독하며, 부하의 변화에 대응하기 위한 라우팅 정보를 유지한다. 라우터가 이 층에서 동작한다.
- 트랜스포트 층: 네트워크로의 하위 수준 접근 및 클라이언트 간 메시지 전달을 담당한다. 즉, 메시지를 패킷으로 분할하고, 패킷의 순서를 유지하며, 또한 흐름 제어와 물리 주소를 생성한다.
- 세션 층: 세션을 구현하고 프로세스 간 통신 프로토콜을 담당한다. 원격 로그인, 파일 전송 등을 위한 실제적인 통신을 다룬다.
- 프로젠테이션 층: 문자 변환이나 반이중-전이중 모드 등을 포함해 사이트들 간 포맷의 차이의 해결을 담당한다.
- 응용 층: 사용자들이 직접 교신하는 것을 담당한다.
- OSI 프로토콜 스택의 각 논리적 층은 대응하는 시스템의 동등한 층과 통신을 한다. 그러나 실제로 하나의 메시지는 상위 층에서 시작하고, 하위 층들을 차례로 통과한다. 각 층들은 메시지를 변경하기도 하고 수신 측의 동등한 층에 맞는 메시지-헤더 자료를 포함시키기도 한다. 마지막으로, 메시지는 데이터-네트워크 층으로 내려가서 하나 이상의 패킷 단위로 전송된다. 이들 데이터는 상대 시스템의 데이터 링크 층에서 수신되고 메시지는 프로토콜 스택의 상위 층들을 통과하면서 분석되고 수정되고 헤더가 제거된다.
- TCP/IP 프로토콜 스택은 각 층이 여러 기능을 실행하기 때문에 층 당 한 개의 기능을 실행하는 ISO 네트워킹보다 구현이 어렵지만 성능 면에서는 더 효율적이다. 이 프로토콜에는 HTTP, FTP, DNS 등이 있다. 트랜스포트층은 무연결 UDP와 연결지향 TCP/IP을 구분한다. IP 프로토콜은 IP 데이터그램을 TCP/IP 인터넷을 통해서 전송하는 일을 담당한다. TCP/IP는 공식적으로 링크와 물리 층을 구분하지 않는다. 따라서 TCP/IP 트래픽은 어느 물리 네트워크에서도 전달될 수 있다.
- 강한 인증은 다단계 핸드셰이킹 또는 인증장치를 필요로 하며 프로토콜을 더 복잡하게 만든다. 

## 견고성

### 고장 탐지
- 공유 메모리가 없는 환경에서 고장을 구별하는 것은 일반적으로 거의 불가능하다. 대개 이들 고장 중 하나가 발생했다는 것만 탐지할 수 있다. 고장이 탐지되면 애플리케이션의 종류에 따라 적절한 조치를 해야 한다.
- 핸드셰이킹 프로시저를 사용해 링크와 사이트의 결함을 탐지한다. 사이트 사이간에 직접 연결된 링크를 가지고 있다면, 일정한 간격으로 서로에게 상태 확인 메시지를 보낸다. 한 사이트가 이러한 메시지를 일정 시간 내에 받지 못할 경우 상대편 사이트가 고장, 링크 고장, 또는 메시지 분실로 가정한다. 이때 이 사이트는 상대편 사이트에게 메시지 올 때까지 기다리거나 상태 여부를 묻는 메시지를 보낸다.
- `타임아웃 기법`을 사용하여 메시지에 대한 시간을 정할 수 있다. 보낸 메시지가 주어진 시간안에 응답 받지 못한다면 상대편이 문제가 발생했다는 것을 알 수 있다.

### 재구성
- 고장을 탐지하게 되면, 시스템을 재구성하고 현재까지의 정상적인 작동을 계속할 수 있도록 해야 한다.
- 링크가 고장이라면 시스템 내의 모든 호스트에 알려서 라우팅 테이블들이 갱신될 수 있도록 해야 한다.
- 호스트의 결함이라면 시스템 내의 다른 모든 호스트에게 이 사실을 알려서 이 호스트를 사용하지 않도록 해야한다.

### 고장 복구
- 링크가 결함이라고 할때, 이것이 회복되면 핸드셰이킹 프로시저를 반복하여 호스트들에게 알려야 한다.
- 상대 호스트가 결함이 회복되었을 때, 다시 정상 가동된다는 사실을 모든 호스트에게 알려야한다. 그 후에 다른 호스트로부터 정보를 받아서 자신의 테이블을 갱신해야 한다.

### 결함 허용
- 분산 시스템은 일정 수준의 결함을 허용하고 다양한 유형의 결함이 발생할 때 정상적으로 계속 동작해야 한다. 설비 결함 허용하게 만드는 작업 프로토콜 단계에서 시작되지만 위에서 언급한 것처럼 시스템의 전 측면에서 고려되어야 한다. 통신 고장, 기계 고장 등은 일정한 범위 내에서 허용되어야 한다. 결함 허용 시스템은 이러한 고장이 발생하더라도 저하된 형태를 유지하면서 계속 동작해야 한다.
- 결함 허용은 구현이 어렵고 비용이 많이든다. 네트워크 층에서는 통신 장애를 예방하기 위하여 다수의 중복된 통신 경로와 스위치와 라우터 같은 네트워크 장치가 필요한다. 저장장치는 고장이 발생한 경우 상대방의 역할을 떠맡기 위한 중복된 하드웨어 구성요소를 포함할 수 있다. 게다라 RAID는 하나 이상의 디스크가 고장 날 경우 게속해서 데이터에 접근하는 것을 보장할 수 있다.
- 중복이 없는 시스템의 고장은 애플리케이션 또는 전체 시스템을 중단시킬 수 있다. 가장 단순한 시스템 고장은 오로지 상태를 가지지 않는 애플리케이션만을 실행하는 시스템에서 발생한다. 이러한 애플리케이션은 시스템의 동작을 저하시키지 않고 재시작될 수 있다. 따라서 애플리케이션이 하나 이상의 노드에서 실행될 수만 있다면 동작은 중단 없이 계속될 수 있다. 이러한 기능은 계산 클러스터라고 알려져 있다.
- 데이터 중심 시스템은 공유 데이터에 접근하고 수정하는 애플리케이션을 포함한다. 데이터 중심 시스템은 결함 허용이 되도록 구현하기가 더욱 어렵다. 예를 들어, 고가용 클러스터는 둘 이상의 컴퓨터와 공유 디스크 집합을 포함한다.
- 특정 애플리케이션은 클러스터링과 함께 락 관리를 구현함으로써 성능을 향상시키기도 한다. 락 관리를 통하여 애플리케이션은 복수의 노드에서 실행될 수 있으며 공유 디스크의 동일한 데이터를 사용할 수 있다.

### 네트워킹의 예
- TCP/IP 네트워크에서 모든 호스트는 호스트 이름과 IP 주소를 가진다. host-id는 네트워크 번호와 호스트 번호로 구분된다. 나뉘는 부분은 네트워크의 크기에 따라 다르다.
- 전송 시스템은 패킷을 전송하기 위해 라우터가 가지고 있는 라우팅 테이블을 조사한다. 라우터들은 출발지 네트워크에서 목적지 네트워크로 패킷을 전송하기 위해 host-id의 네트워크 부분을 사용한다. 그런 다음 목적지 시스템은 패킷을 수신한다. 이 패킷은 완전할 수도 아니면 메시지로 결합해야할 수도 있다.
- 모든 이더넷 장치는 주소를 지정하기 위해 할당된 유일한 MAC 주소를 가지고 있다. LAN의 두 장치는 MAC으로 상호 통신한다. 한 시스템이 다른 시스템에 데이터를 보내려면, 네트워킹 소프트웨어는 목표 시스템의 IP 주소를 포함하는 `ARP` 패킷을 생성한다. 이들 패킷은 이더넷 네트워크에 있는 다른 모든 시스템에 방송된다.
- 방송 시에는 모든 호스트들이 패킷을 받아 처리하도록 신호를 보내는데, 이를 위해 특별한 네트워크 주소를 사용한다. 방송은 게이트웨이에 의해 재전송되지 않으므로 지역 네트워크에 있는 시스템만이 이들을 수신하게 된다. ARP 요청의 IP 주소와 같은 IP 주소를 갖는 시스템만이 이들을 수신하게 된다. ARP 요청의 IP 주소와 같은 IP 주소를 갖는 시스템만이 응답하고 자신의 MAC 주소를 질의한 시스템에게 보낸다. 효율을 높이기 위해 호스트는 IP-MAC 주소 쌍을 내부 테이블에 캐시한다. 캐시 항목들은 노화하는데, 이는 그 시스템에 대한 접근이 주어진 시간 내에 일어나지 않을 때 저장된 항목을 제거하기 위해 필요하다. 추가적인 성능 향상을 위해 자주 사용되는 호스트들은 위한 ARP 항목들은 ARP 캐시에 고정되게 만들 수 있다.
- 이더넷 장치가 host-id와 이더넷 주소를 공표하면 통신을 시작될 수 있고, 프로세스는 통신하고자 하는 호스트의 이름을 명시할 수 있다. 네트워킹 소프트웨어는 그 이름을 가지고 와서 DNS 찾기를 통해 목적지의 인터넷 번호를 결정한다. 메시지는 소프트웨어 층을 경유해서 애플리케이션 층에서부터 하드웨어 층으로 전송된다. 하드웨어 층에서 패킷은 헤더에 이더넷 주소를 가지며, 테일에 패킷 손상 검출하는 체크섬과 꼬리표를 가진다. 패킷은 이더넷 장치에 의해 인터넷 상에 놓여진다. 패킷의 데이터 부분은 원래 메시지의 데이터 일부 혹은 전부를 포함할 수 있지만 메시지를 구성하는 상위 레벨 헤더의 일부도 포함할 수 있다. 데이터링크 층 위의 모든 헤더는 이더넷 내에 데이터로서 포함된다.
- 만약 목적지가 출발지와 동일한 지역 네트워크에 있다면, 시스템은 ARP 캐시를 조사할 수 있고, 호스트의 이더넷 주소를 찾을 수 있고 회선 상에 패킷을 놓을 수 있다. 그런다음 목적지 이더넷 장치는 패킷 내의 주소를 확인하여 패킷을 읽고, 프로토콜 스택으로 전송한다.
- 만약 목적지 시스템이 출발지와 다른 네트워크상에 존재한다면, 출불지 시스템은 네트워크 상의 적당한 라우터를 찾아서 그곳으로 패킷을 보낸다. 그런 다음 라우터들은 패킷이 목적지 네트워크에 도착할 때까지 WAN을 통해서 패킷을 보낸다. 목적지 네트워크에 접속된 라우터는 ARP 캐시를 조사해서 목적지 이더넷 번호를 찾고, 패킷을 해당 호스트로 보낸다. 이러한 모든 전송 과정을 통해서 다음 라우터의 이더넷 주소가 사용됨에 따라 데이터링크 층 헤더가 변경될 수 있지만, 패킷의 다른 헤더부분은 패킷이 수신될 때까지 그래도 유지되고, 마지막으로 이들은 커널에 의해서 수신 프로세스로 전달된다.
