# 보호
- 보호는 컴퓨터 시스템에 정의된 자원에 대하여 프로그램, 프로세스 또는 사용자의 접근을 제어하는 기법이다. 이 기법은 부과될 제어를 명세하기 위한 방법과 이를 시행할 수단을 제공해야 한다.
- 보안이란 시스템과 그 시스템 자료의 무결성이 유지될 확신의 척도를 말한다.

## 보호의 목표
- 보호는 원래 다중 프로그래밍 OS에 대한 부가물로 인식되었으며, 따라서 신뢰성이 없는 사용자도 파일의 디렉터리와 같은 공동의 논리적 이름 공간이나 메모리와 같은 공동의 물리적 이름 공간을 안전하게 공유할 수 있도록 고안되었다. 현대의 보호 개념은 자원을 공유하는 복잡한 시스템의 신뢰성을 증가시키기 위해 발전되어 왔다.
- 보호를 제공하는 분명한 이유는 사용자가 접근 제한을 악의적, 의도적으로 위반하는 것을 방지할 필요성이다. 그러나 일반적으로 보다 중요한 것은 시스템 내에서 활성 상태인 각 프로그램 요소가 시스템 자원들을 정해진 사용 정책대로 사용하도록 보장할 필요성이다. 이것은 신뢰성 있는 시스템의 절대적인 요구사항이다.
- 또한, 보호는 구성요소 서브시스템 사이의 인터페이스에 숨어 있는 오류를 검출함으로써 시스템의 신뢰성을 향상시킬 수 있다. 보호되지 않은 자원은 인가되지 않거나 무자격 사용자에 의해 사용되는 것에 대해 방어할 수 없다. 보호 지향 시스템은 인가된 사용자와 그렇지 않은 사용자를 구별할 수 있는 수단을 제공한다.
- 컴퓨터 시스템에서 보호의 역할은 자원 사용을 지배하는 정책을 시행하기 위한 기법을 제공하는 것이다. 이러한 정책들은 일부는 시스템 설계 시에 고정되며, 반면 일부는 시스템 관리에 의하여 구축된다. 또 다른 일부는 자신의 파일이나 프로그램을 보호하기 위하여 개개의 사용자들에 의해 정의되기도 한다. 보호 시스템은 선언 가능한 다양한 정책을 시행하기 위하여 반드시 융통성을 가져야 한다.
- 자원의 이용 정책은 애플리케이션이나 시간의 흐름에 따라 변경될 수 있다. 보호는 응용 서브시스템이 만들거나 제공하는 자원들의 오용을 방지할 수 있도록 응용 프로그래머를 위한 도구로서도 활용 가능해야 한다.
- 하나의 중요한 원칙은 기법과 정책을 분리하는 것이다. 기법은 어떤 일을 어떻게 실행해야 할지를 결정한다. 반면, 정책은 무엇이 실행되어야 할지를 결정한다. 정책과 기법의 분리는 융통성을 위하여 매우 중요하다. 정책은 장소와 시간에 따라 변할 가능성이 있다. 최악의 경우에 정책의 변경 하나 하나가 아래에 깔려 있는 기법의 변경을 필요로 할 수 있다.

## 보호의 원칙
- 보호의 원칙은 종종 OS를 설계하는 프로젝트를 통해서 소개된다. 원칙을 따름으로서 설계상의 결정을 간소화하고, 시스템의 일관성을 유지하며 이해하기도 쉽다. 핵심적인, 경험에 의한 보호의 원칙에는 최소 권한의 원칙이 있다. 최소 권한의 원칙은 프로그램, 사용자, 심지어 시스템이 태스크를 실행하는데 필요한 만큼의 권한만 부여하는 법칙이다.
- 최소 권한의 원칙을 따르는 OS는 실패나 손상된 구성요소가 최소한의 피해만을 입히거나 허락하도록 OS의 구조, 프로그램, 시스템 호출 및 자료구조를 구현해야 한다. 예를 들어, 시스템 데몬의 버퍼 오버플러우는 데몬의 실패를 야기할 수는 있지만 원격 사용자가 최대한의 권한을 갖고 전체 시스템에 접근할 수 있게 하는 프로세스 스택에서의 코드 실행을 허용해서는 안된다.
- 또한, 이러한 OS는 세밀한 접근 제어를 하는 애플리케이션을 작성 가능하게 하는 시스템 호출과 서비스를 제공해야 한다. OS는 애플리케이션이 필요로 할 때 권한을 주고 필요로 하지 않을 때는 권한을 박탈하는 기법을 제공해야 한다. 또한 모든 특권적인 함수 접근에 대해 감사 기록을 생성한다. 감사 기록을 이용하여 시스템의 모든 보호와 보안 활동을 추적할 수 있다.
- 최소 권한의 원칙으로 사용자를 관리하는 것은 사용자가 필요로 하는 최소한의 권한만이 부여된 사용자마다 별도의 계정 생성을 포함한다. 이러한 기능을 제공하기 위해 어떤 시스템은 역할 기반 접근 제어(RBAC)를 구현하였다.
- 최소 권한의 원칙을 따르는 컴퓨팅 기관에서 제작된 컴퓨터들은 특정 서비스의 실행, 특정 서비스를 통한 특정 원격 호스트에의 접근, 그리고 특정 시간 내에서 실행되는 이러한 동작들을 제한할 수 있다. 일반적으로 이러한 제한은 각 서비스의 허용과 거브 그리고 접근 제어 리스트를 통해 구현된다.

## 보호의 영역
- 컴퓨터 시스템은 프로세스들과 객체들의 집합이다. 여기서 객체는 하드웨어 객체(CPU, 메모리등)와 소프트웨어 객체(파일, 프로그램등) 둘 모두를 의미한다. 각 객체는 시스템의 다른 모든 객체들과 구분할 수 있는 유일한 이름을 가지며, 각각은 잘 정의되고 의미 있는 연산을 통해서만 접근될 수 있다. 객체는 본질적으로 추상 데이터 타입이다.
- 프로세스는 자기가 접근을 인가 받은 자원들만을 접근할 수 있어야 한다. 또한, 어느 때든 프로세스는 자신의 일을 완료하기 위하여 현재 필요로 하는 자원들만을 접근할 수 있어야 한다. 이러한 요구는 통상 need-to-know 원칙이라 불리며, 이는 시스템에서 잘못된 프로세스가 유발할 수 있는 피해의 양을 제한하는데 유용하다.

### 영역 구조
- need-to-know 기법을 순조롭게 하기 위하여 프로세스는 하나의 보호 영역 내에서 동작한다. 이 영역은 프로세스가 접근할 수 있는 자원을 지정한다. 각 영역은 객체의 집합과 각 객체에 대해 호출될 수 있는 연산의 타입을 정의한다. 객체에 대해 연산을 실행할 수 있는 권한을 접근 권한이라 한다. 하나의 영역은 접근 권한의 집합이고, 각 권한은 `<객체 이름, 권한 집합>`의 순서쌍으로 되어 있다.
- 영역은 서소 원소를 공유할 수 있으며, 따라서 접근 권한을 공유할 수 있다. 예를 들어 접근 권한 `<o4, {인쇄}>`을 가진 영역 D의 프로세스들은 o4에 대해 인쇄 작업만 가능하다.
- 프로세스와 영역간의 연관을 정적(한 프로세스가 이용 가능한 자원들의 집합이 영역의 일생동안 고정된 경우)이거나 동적이다. 
- 만일 프로세스와 영역 간의 연관이 고정되어 있고, need-to-know 원칙을 고수하고 싶다면, 영역의 내용을 변경할 수 있는 기법이 있어야 한다. 프로세스는 서로 다른 접근을 필요로 할 수 있다. 만일 한 영역이 정적이라면, 그 영역이 서로 다른 접근을 포함하도록 정의해야 한다. 그러나 이럴 경우 어떠한 접근을 위해서 다른 접근도 허용이 되기 때문에 need-to-know 원칙을 위배하게 된다. 반드시 영역의 내용이 변경 가능하도록 해서 영역이 항상 필요한 최소의 접근 권한을 반영하도록 해야 한다.
- 프로세스와 영역간의 동적이라면, 프로세스로 하여금 한 영역에서 다른 영역으로 전환하게 하는 기법이 존재한다. 또한 한 영역의 내용이 변경 가능하기를 원할 수 있다. 만일 한 영역의 내용을 변경할 수 없다면, 변경된 내용을 갖는 새로운 영역을 만든 다음 영역의 내용을 변경하기 원할 때 새로운 영역으로 전환함으로써 같은 효과를 낼 수 있다.
- 각 사용자가 하나의 영역이 될 수 있다. 이 경우 접근할 수 있는 객체의 집합은 사용자의 신원에 의존한다. 영역 전환은 사용자가 변경될 때 일반적으로 한 사용자가 로그아웃하고 다른 사용자가 로그인할 때 발생한다.
- 각 프로세스가 하나의 영역이 될 수 있다. 이 경우 접근할 수 있는 객체의 집합은 프로세스의 신원에 의존한다. 영역 전환은 한 프로세스가 다른 프로세스에 메시지를 보내고, 그리고 응답을 기다리는 것에 해당한다.
- 각 프로시저가 하나의 영역이 될 수 있다. 이 경우 접근될 수 있는 객체의 집합은 프로시저 내에 정의된 로컬 변수에 해당한다. 영역 전환은 프로시저가 호출될 때 발생한다.
- OS 실행의 표준 이중 모드(모니터-사용자 모드) 모델을 보자. 한 프로세스가 모니터 모드에서 실행할 때 그 프로세스는 특권 명령어를 실행할 수 있어서 컴퓨터 시스템에 대한 완전한 제어를 얻는다. 반면에, 프로세스가 사용자 모드에서 실행된다면 그 프로세스는 비특권 명령어만을 실행할 수 있다. 결과적으로 사용자 모드에서 실행되는 프로세스는 미리 정의된 메모리 영역에서만 실행될 수 있다. 이러한 두 가지 모드는 사용자의 영역에서 실행되는 사용자 프로세스들로부터 모니터 영역에서 실행되는 OS를 보호한다.

### UNIX의 예
- UNIX에서 한 영역은 사용자와 연관되어 있다. 영역을 전환하는 것은 사용자의 신원을 일시적으로 변경하는 것과 같다. 이 변경은 파일 시스템을 통하여 소유자 신원(setuid 비트)과 영역 비트가 각 파일에 연관 되어 있다. 영역비트가 on이고 사용자가 해당 파일을 실행할 때 사용자의 ID는 파일 소유자의 ID로 설정된다. 반면 영역비트가 off이면 사용자 ID는 변경되지 않는다. 그리고 파일에 대한 작업이 끝나면 일시적인 사용자 ID의 변경이 끝난다.
- 영역을 정의하기 위하여 사용자 ID를 사용하는 OS에서 영역을 변경하는 데 사용되는 다른 일반적인 방법들이 있으며, 이는 거의 모든 시스템들이 그러한 기법을 제공할 필요가 있기 때문이다. 이 기법은 특권을 가진 설비를 일반 사용자가 사용할 수 있게 할 필요가 있을 때 사용된다. 이 방법의 한 가지 문제는 사용자가 root이고, 영역 비트가 on인 파일을 생성할 수 있다면 그 사용자는 root가 될 수 있고 시스템에 대해 무슨 일이든지 할 수 있다.
- 다른 여러 OS에서 사용되고 있는 한 대안은 특별한 디렉터리에 특권 프로그램들을 두는 것이다. OS는 이 디렉터리로부터 실행되는 모든 프로그램의 사용자 ID를 root와 동등한 사용자 또는 그 디렉터리의 소유자의 사용자 ID로 변경하도록 설계되었다. 이 방식은 크래커가 다음에 사용할 목적으로 생성한 그와 같은 파일을 숨길 수 있는 문제를 해결하였다. 그러나 UNIX의 방법보다 유연성이 떨어진다.
- 보다 방어적인 방법은 단순히 사용자 ID의 변경을 허용하지 않는 것이다. 이들 예에서는 특권 설비에 대한 사용자 접근을 허용하기 위하여 특별한 기법이 사용되어야 한다. 예로, 데몬 프로세스가 부트시에 시작될 수 있고 특별한 사용자 ID로 실행된다. 사용자는 그 설비를 사용할 필요가 있을 때마다 이 프로세스에게 요청을 보내는 별도의 프로그램을 실행한다.

### MULTICS의 예
- 이 시스템에서 보호 영역은 링 구조로 계층적으로 조직되어 있다. 각 링은 하나의 영역을 나타낸다. 링에는 0~7까지 있다. 영역의 번호가 낮을 수록 더 큰 특권을 가진다.
- MULTICS는 세그먼트로 나누어진 주소 공간을 가지고 있다. 각 세그먼트는 하나의 파일이다. 각 세그먼트는 이들 링 중 하나와 연관되어 있다. 세그먼트 서술은 링 번호를 나타내는 항을 가진다. 추가로 세그먼트 서술은 읽기, 쓰기, 실행 제어를 하기 위한 세 개의 접근 비트를 포함한다. 세그먼트와 링의 연관은 정책 결정이다. 각 프로세스에는 그 프로세스가 현재 실행중인 링을 나타내는 현재 링 번호 카운터가 연관되어 있다. 한 프로세스가 특정 링에 연관되어 있을때 그보다 낮은 링 영역과 연관된 세그먼트에 접근할 수 없다.
- MULTICS에서의 영역 전환은 프로세스가 다른 링의 프로시저를 호출함으로써 하나의 링으로부터 다른 링으로 넘어갈 때 발생한다. 이 전환은 통제된 방법으로 행해져야 한다. 그러지 않으면, 한 프로세스가 링 0에서 실행할 수 있기 때문이다. 통제된 영역을 전환을 허용하기 위하여 세그먼트 서술자의 링 플드가 접근 괄호, 한계, 출입구 리스트를 포함하도록 변경한다.
- 링 구조의 주요 단점은 need-to-know 원칙을 시행하는 것을 허용하지 않는다는 점이다.
