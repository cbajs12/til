# 파일 시스템
- 파일 시스템은 관련된 자료를 저장하는 파일들의 모음과 시스템 내의 모든 파일을 정리하고 그에 관한 정보를 제공하는 디렉터리 구조로 구성된다.

## 파일 개념
- OS는 컴퓨터 시스템을 편리하게 사용하기 위해 정보에 대한 일관적인 논리적 관점을 제공하고, 저장장치의 물리적 특성을 추상화하여 파일을 정의한다.
- 파일은 OS에 의해서 물리 장치들로 맵핑되며, 이들 저장장치들은 일반적으로 비휘발적 성질을 가진다.
- 파일은 보조 저장장치에 기록된 관련 정보의 명명된 집합으로 정의할 수 있다.  사용자 관점에서 볼 때 파일은 논리적 보조 저장장치의 가장 작은 할당 단위이다.

### 파일 속성
- 사용자의 편의를 위해 파일에 이름을 부여하고 그 이름으로 파일을 참조한다. 일부 시스템들은 대문자와 소문자를 서로 다른 문자로 구별하여 파일의 이름을 만들며, 다른 시스템은 이들을 동일 문자 취급한다.
- 파일이 만들어지면 그 파일을 생성한 프로세스, 사용자, 시스템으로부터도 독립하게 된다.
- 파일은 OS마다 다른 속성을 갖지만 전형적으로, 이름, 식별자(통상 하나의 숫자로 파일 시스템 내에서 파일을 식별한다. 사람이 읽을 수 없는 형태의 파일 이름이다.), 타입, 위치, 크기, 보호(접근 제어 정보), 시간, 날짜, 사용자 식별등의 속성을 가진다.
- 모든 파일에 대한 정보는 보조 저장장치에 상주하는 디렉터리 구조 내에 유지된다. 전형적으로, 디렉터리 항목은 파일의 이름과 고유의 식별자로 구성된다. 식별자는 다시 다른 파일 속성을 찾는 데 사용된다.
- 파일처럼 디렉터리들도 비휘발 성질을 가지고 저장장치에 저장되고, 필요할 때마다 조금씩 메모리로 가져온다.

### 파일 연산
- 파일이란 추상적인 데이터 타입이다. OS는 파일 생성, 쓰기, 읽기, 위치 재설정, 삭제 및 절단 등을 하기 위한 시스템 호출들을 제공한다.
- 파일 생성: 파일을 생성하기 위해서는 파일을 저장할 수 있는 파일 시스템 내 공간을 찾아야 한다. 또한, 새로 생성된 파일에 대한 항목이 디렉터리에 만들어져야 한다.
- 파일 쓰기: 파일을 쓰기 위해서는 파일 이름과 파일에 기록될 정보를 명시하는 시스템 호출을 실행한다. 파일 이름이 주어지면 시스템은 파일의 위치를 찾기 위해서 디렉터리를 탐색한다. 시스템은 파일 내의 다음 쓰기가 일어날 위치를 가리키는 쓰기 포인터를 유지하고 있어야 한다. 쓰기 포인터는 쓰기가 일어날때마다 갱신되어야 한다.
- 파일 읽기: 파일을 읽기 위해서 파일의 이름과 파일이 읽혀 들어갈 블록의 위치를 명시하는 시스템 호출을 사용한다. 관련된 항목을 찾기 위해서 디렉터리를 탐색하고, 시스템은 다음 읽기가 일어날 파일 안의 위치를 가리키는 읽기 포인터를 유지할 필요가 있다. 일단 읽기가 발생하면, 읽기 포인터는 갱신된다. 프로세스는 일반적으로 파일 읽기나 파일 쓰기 중 하나를 하고 있기 때문에 대부분의 시스템은 하나의 현재 파일 위치 포인터를 가진다. 읽기와 쓰기 연산 모두 이 포인터를 사용함으로써 공간을 절약하고 시스템의 복잡성을 감소시킨다.
- 파일 안에서의 위치 재설정: 디렉터리에서 적합한 항목을 탐색하고 현재 파일 위치를 주어진 값으로 설정한다. 파일 내에서 위치의 재설정을 위해 실제로 입출력할 필요는 없으며, 이 파일 연산은 파일 탐색으로도 알려져 있다.
- 파일 삭제: 파일을 삭제하기 위해서는 지명된 파일을 디렉터리에서 찾는다. 해당 디렉터리 항목을 발견하면, 해당 파일이 차지하고 있는 모든 공간을 방출하고 디렉터리 항목을 삭제한다.
- 파일 절단: 사용자가 파일의 내용은 지우고, 다만 그 파일의 속성은 그대로 남기기를 원할 때 사용한다. 사용자가 파일을 삭제하고 파일을 재생성하도록 강제하는 것이 아니라, 이 기능은 파일의 길이를 제외한 모든 속성을 그대로 유지시킨다. 파일의 길이가 0으로 재설정되며, 파일이 가지고 있던 공간은 해제된다.
- 6개의 기본 연산들은 파일 조작에 필요한 최소 연산들이며, 다른 일반적인 연산으로 새로운 정보를 기존 파일 끝에 첨가하거나 재명명하는 연산들이 있다. 이들 기본적인 조작 연산들은 다른 파일 조작 연산들을 실행하기 위해 결합될 수도 있다. 또한 사용자가 파일의 다양한 속성을 획득하고 설정할 수 있는 연산을 가진다.
- 대부분의 파일 연산들은 지명된 파일과 관련된 디렉터리를 찾는 작업을 한다. 이러한 반복적인 탐색을 피하기 위해서 많은 시스템들은 파일이 맨 처음 사용되기 전에 open() 시스템 호출을 호출할 것을 요구한다. OS는 모든 열린 파일에 대한 정보를 갖는 `열린 파일 테이블`을 유지한다. 임의의 파일 연산이 요구되면, 이 테이블에 대한 인덱스로 그 파일을 지정하므로 어떠한 탐색도 필요하지 않다. 파일이 더 이상 실제로 사용되지 않으면 프로세스에 의해 닫히고 OS는 오픈 파일 테이블에 있는 항목을 제거한다.
- 일부 시스템은 파일에 대한 첫 번째 참조가 이루어질 때 파일을 암묵적으로 연다. 이 파일은 자신을 연 작업이나 프로그램이 종료되면 자동적으로 닫힌다. 그러나 대부분의 시스템은 파일이 사용되기 전에 먼저 프로그래머가 시스템 호출로 명시적으로 열기를 요구한다. open() 연산은 파일 이름을 취하여 그 파일 이름으로 디렉터리를 찾고 디렉터리 항목을 열린 파일의 테이블로 복사한다. open() 시스템 호출은 또한 접근 모두 정보-생성, 읽기-쓰기, 덕붙이기-전용 등의 접근 모드 정보를 받을 수 있다. 이 모드를 파일의 허가와 대조한다. 만일 요구된 모드가 허용되면 그 프로세스를 위해 파일을 연다. open() 시스템 호출은 전형적으로 열린 파일 테이블의 항목에 대한 포인터를 되돌려 준다. 실제 파일 이름이 아닌 포인터를 입출력 연산에 사용함으로써 더 이상의 탐색 과정을 피하고 시스템 호출 인터페이스를 단순화한다.
- 보통 OS는 두 단계 내부 테이블(프로세스별 테이블, 범 시스템 테이블)을 사용한다. 
- 프로세스별 테이블은 각 프로세스가 연 모든 파일들을 기록한다. 이 테이블에 저장된 내용은 그 프로세스가 사용하는 파일들에 관한 정보이다.
- 프로세스별 테이블의 각 항목은 다시 범 시스템 열린 파일 테이블들을 가리킨다. 이 범 시스템 테이블은 프로세스에 독립적인 정보, 즉 디스크 상의 파일 위치, 접근 날짜 그리고 파일 크기와 같은 정보들을 갖고 있다.
- 일단 파일이 하나의 프로세스에 의해 열린다면, open() 호출을 실행하는 다른 프로세스는 단순히 범 시스템 테이블들 내에 있는 적절한 항목을 가리키는 새로운 항목이 프로세스의 열린 파일 테이블에 더해진다. 일반적으로, 열린 파일 테이블은 연 프로세스 수를 가리키는 `오픈 계수`를 각 파일에 연관해 두고 있다. 파일 close()는 이 계수를 감소시키고, 계수가 0이 되었을때 파일은 더 이상 사용되지 않음을 나타내고 열린 파일 테이블로부터 제거 된다.
- 파일 포인터: read()와 write() 시스템 호출의 일부분으로 파일 오프셋을 포함하지 않는 시스템은 현재 파일 위치 포인터로서 가장 최근의 읽기/쓰기 위치를 추적해야 한다. 이 포인터는 파일 연산을 실행하는 각 프로세스에 대해 유일하게 하나씩 만들어지므로 디스크 상의 파일 속성들과는 분리되어 유지되어야 한다.
- 파일 오픈 계수: 파일이 닫히면, OS는 열린 파일 테이블 항목들을 재사용해야 한다. 아니면 테이블의 공간이 모자라게 될 것이다. 여러 프로세스가 파일을 열 수 있기 때문에 시스템은 열린 파일 테이블 항목을 제거하기 전에 마지막 파일이 닫힐 때까지 기다려야 한다. 이 계수는 파일의 총 열린 횟수와 닫힌 횟수를 추적하며, 이 계수 값이 0에 도달하면, 그때 시스템은 항목을 제거할 수 있다.
- 파일의 디스크 위치: 대부분의 파일 연산자들은 시스템에게 파일 내의 데이터를 변경하도록 요구한다. 디스크 상의 파일의 위치를 찾기 위한 정보는 매 연산마다 디스크에서 읽는 것을 피하기 위해 메모리에 저장된다.
- 접근 권한: 각 프로세스는 한 파일을 하나의 접근 모드로 연다. 이 정보는 프로세스별 테이블에 저장되며, OS는 이 정보를 후속 요구를 허용하거나 불허하는 데 사용할 수 있다.
- 몇몇 OS는 열려진 파일을 잠금할 수 있는 기능을 제공한다. 파일 잠금은 하나의 프로세스가 파일을 잠그고 다른 프로세스들이 그것에 대해 접근하는 것을 막는데 사용될 수 있다. 파일 잠금은 많은 프로세스들에 의해 사용되고 수정되는 시스템 로그파일과 같이 공유되는 파일들에 유용하다.
- `공유 잠금`은 여러 프로세스가 동시에 잠금을 획득할 수 있다는 점에서 reader 잠금과 비슷하다. `배타적인 잠금`은 한 번에 한 프로세스만 잠금을 획득할 수 있다는 점에서 writer 잠금과 비슷하게 행동한다. 모든 OS가 두 종류의 잠금을 모두 지원하지 않는다.
- OS는 `강제적` 또는 `권고적` 파일 잠금 방법을 제공할 수 있다. 강제적 잠금은 어떠한 프로세스가 배타적 잠금을 획득하면 OS는 다른 프로세스가 잠겨진 파일에 접근하는 것을 막는 것이다. 권고적 잠금은 OS 잠긴 파일에 대한 접근을 막지는 않지만, 대신 파일에 접근하기 전에 스스로 잠금을 획득하도록 프로그래밍 되어야 한다. 
- 만약 파일 잠금 체계가 강제적이라면, OS는 잠금 무결성을 안전하게 보장해준다. 권고적 잠금일 경우는 잠금이 적절히 획득되고 해제되는 것에 대한 보장은 개발자의 몫이다. Windows는 강제적 잠금을 Unix는 권고적 잠금을 채택하고 있다.
- 파일의 잠금 사용은 프로세스 동기화처럼 특별한 주의가 필요하다.

### 파일 타입
- 파일 시스템은 물론 전체 OS 설계시 중요한 사항 중 하나는 OS가 파일 타입들을 인식하고 지원할 것인지를 결정하는 것이다.
- 잘 알려진 방법은 파일 이름의 한 부분으로 하여금 파일 타입을 나타내도록 하는 것이다. 파일 이름이 마침표로 구분되는 이름과 확장자 두 부분으로 나뉘게 된다.
- 시스템은 확장자를 사용하여 파일의 유형과 그 파일에 할 수 있는 연산의 유형을 표시한다.
- 확장자는 OS가 지원하는 것은 아니기 때문에, 애플리케이션이 조작하는 파일들에 대한 힌트로 생각될 수 있다.

### 파일 구조
- 파일의 타입을 사용하여 파일의 내부 구조 형태를 짐작할 수 있다. 소스와 목적 파일들은 그 파일을 다루는 프로그램이 기대하는 구조를 가진다. 어떤 파일들의 경우에는 OS가 인식할 수 있는 구조를 따라야만 한다. 예를 들어, OS는 실행 파일이 메모리상의 어느 위치에 적재되며 처음으로 실행할 명령어의 위치를 파악할 수 있도록 특별한 구조를 요구한다. 이러한 생각을 좀 더 확장하여 어떤 OS에서는 그 시스템이 지원 가능한 파일 구조의 집합을 정의하고, 그러한 구조를 갖는 파일을 다를 수 있는 특별한 연산 기능을 제공한다.
- OS가 여러 파일 구조를 지원하는 경우에 발생 가능한 단점 중 하나는 OS의 크기가 증가한다는 점이다. 
- 어떤 OS들은 파일 형태, 구조에 대하여 최소한의 파일 구조를 두거나 지원한다. UNIX는 파일을 단순히 8비트 바이트들의 단순한 집합으로 보기 때문에 이 바이트들의 의미를 OS가 해석하지 않는다. 이러한 구조는 파일 사용의 융통성을 극대화되는 대신 시스템 차원의 지원은 거의 없다. 이에 따라 각 애플리케이션들은 각자의 프로그램에서 사용되는 파일들에 대한 적절한 해석과 운용을 책임져야 한다. 그렇다 하더라도 모든 OS는 반드시 한 가지 파일 구조는 지원해야 한다. 바로 프로그램을 로딩하고 수행할 수 있는 실행 파일의 구조이다.
- 매킨토시 OS의 경우 파일을 두 부분으로 나누는데, 리소스 포크와 데이터 포크이다. 리소스 포크는 사용자에게 흥미 있는 부분을 포함한다. 예를 들어 리소스 포크는 프로그램에 의해 표시되는 단추의 레이블을 갖고 있다. 사용자는 자신의 언어에 맞게 단추의 레이블을 고칠수 있다. 데이터 포크는 전통적인 파일의 내용인 프로그램의 데이터와 코드를 포함하고 있다.
- 동일한 작업을 UNIX에서 하려면 프로그래머가 자신이 변경할 수 있는 독자적인 데이터 파일을 생성하지 않았다면, 원시 코드를 변경하고 다시 컴파일해야 할 것이다.

### 파일의 내부 구조
- 내부적으로 한 파일 내의 특정 오프셋을 찾는 것은 복잡할 수 있다. 디스크 시스템은 보통 섹터의 크기에 의해 결정되는 블록 크기를 가진다. 모든 디스크 I/O는 한 블록 단위로 실행되며 모든 디스크 블록들은 동일한 크기를 가진다. 이 물리 레코드의 길이는 원하는 논리 레코드의 크기와 일치하지 않는 것이 일반적이다. 논리 레코드의 길이는 매우 다양하며 여러 논리 레코드를 하나의 물리 레코드에 `팩킹`하는 것이 이 차이를 해결하는 일반적인 해결책이다.
- UNIX는 모든 파일을 바이트의 연속된 열이라고 정의한다. UNIX 파일 내의 각 바이트는 시작부터 또는 끝에서부터 몇 번째 파이트 위치라고 부르는 오프셋에 의해 위치 지정이 가능하다. UNIX의 경우 논리 레코드는 1바이트가 된다. 파일 시스템은 자동으로 바이트들을 하나의 물리 블록으로 필요에 따라 팩하고나 언팩한다.
- 논리 레코드의 크기, 물리 블록 크기, 그리고 팩킹 기술은 각 물리 블록내에 몇개의 논리 블록이 들어갈지를 결정한다. 팩킹은 사용자의 애플리케이션이나 OS에 의해 실행될 수 있다. 어느 경우든 파일은 일련의 블록으로 간주된다. 모든 기본 I/O 기능은 블록 단위로 실행된다. 논리 레코드로부터 물리 블록으로의 변환은 단순한 소프트웨어 문제이다.
- 디스크의 공간이 항상 블록 단위로 할당되기 때문에 각 파일의 마지막 블록의 일부는 낭비된다. 이렇게 바이트 단위가 아니라 블록 단위 단위로 처리하기 위해서 발생한 쓸모없는 부분을 `내부 단편`이라고 한다. 모든 파일 시스템은 내부 단편화 문제를 갖고 있다. 블록 크기가 클수록 내부 단편화가 커진다.

## 접근 방법

### 순차 접근
- 파일의 정보가 레코드 순서대로 차례차례 처리된다. 이 접근 모드는 가장 일반적이며 편집기나 컴파일러는 보통 이러한 형식으로 접근한다.
- 파일에 대한 대부분의 연산은 읽기와 쓰기이다. 읽기는 파일의 다음 부분을 차레로 읽어 나간다. 읽은 후에는 현재 위치를 추적하는 파일 포인터가 자동으로 증가된다. 마찬가지로 쓰기 작업은 파일의 끝에 추가하며 새로운 파일의 끝으로 파일 포인터가 이동한다. 

### 직접 접근
- 직접 접근을 위해서 파일은 고정 길이의 논리 레코드들로 구성되고 특별한 순서 없이 빠르게 레코드를 읽고 쓸 수 있다. 직접 접근 방법은 파일의 디스크 모델에 기반을 두며 이는 디스크가 무작위 파일 블록에 임의적 접근을 허용하기 때문이다. 직접 접근을 위해 파일은 번호를 갖는 일련의 블록 또는 레코드로 간주된다. 직접 접근 파일에는 읽기나 쓰기의 순서에 제약을 가하지 않는다.
- 직접 접근 파일은 대규모의 정보를 즉각적으로 접근하는 데 아주 유용하며, 대규모 DB가 이러한 유형이다. 특정 주제에 관한 질이가 들어오면 그 답을 수록하고 있는 블록을 계산해 낸 후 직접 그 정보를 읽어 제공한다.
- 직접 접근 방법을 위해서는 파일 연산이 블록 번호 파라미터를 포함할 수 있도록 수정되어야 한다. 따라서 n이 블록 번호일때, read n 또는 write n을 제공한다. 다른 대안으로 순차 접근을 위해 read/write next와 position file to n 연산을 추가하는 형식이 있다.
- 사용자가 OS에게 제공하는 블록 번호는 통상 파일의 시작을 0으로 보고 계산한 레코드의 위치로써 상대적 블록 번호이다. 따라서 디스크 주소가 첫 번째 블록인 경우 1400이고 두번째 블록기 3이라도 파일의 첫 번째 상대적 블록은 0이고 두번째는 1이다. 상대적 블록 번호를 사용하기 위해서는 OS가 파일이 어디에 저장되어야 하는 지를 결정해야만 하고, 사용자가 자신의 파일이 아닌 부분에 접근하는 것을 막는데 도움이 된다.
- 시스템은 파일의 N번째 레코드에 대한 요청을 처리하기 위하여 파일의 논리적 레코드의 길이(L) * N의 위치로부터 L 바이트에 대한 요청이 된다. 논리적 레크드는 고정된 길이이므로, 레코드를 읽고, 쓰고, 지우는 것은 간단하다.
- 모든 OS가 직접 접근 파일과 순차 접근 파일 모두를 제공하지는 않는다. 어떤 시스템은 파일이 생성될 때 순차 또는 직접 접근 파일인지를 지정해야 한다. 이런 경우 파일은 지정된 방식으로만 접근될 수 있다. 직접 접근 파일을 가지고 순차 파일 기능을 쉽게 제공해 줄 수 있다. 그러나 순차 접근 파일에서 직접 접근을 흉내내는 것은 대단히 비효율적이다.

### 기타 접근 방법
- 직접 접근 파일에 기반을 두고 여러 가지 다른 파일 접근 방법을 제공할 수 있다. 이런 방법들은 일반적으로 파일에 대한 인덱스를 구축해야 한다. 인덱스란 다양한 블록에 포인터를 포함하는 것이다. 파일에서 레코드를 찾기 위해서 먼저 이 인덱스를 찾아 그에 대응하는 포인터를 얻는다. 그런 다음 그 포인터를 사용하여 파일에 직접 접근하여 원하는 레코드를 찾는다.
- 파일이 아주 크면 인덱스 자체도 매우 커 메모리에 유지할 수 없게 된다. 이럴 경우 인덱스 파일에 대해서도 인덱스를 만드는 것이 있다. 일차 인덱스 파일은 2차 인덱스 파일의 포인터를 가지고, 이는 다시 실제 자료를 가리킨다.

## 디렉터리와 디스크 구조
- 저장장치는 전체를 하나의 파일 시스템으로 사용할 수 있다. 또한 더 정교한 제어를 위하여 세분될 수도 있다. 예를 들어, 디스크는 쿼터 단위로 분할되고 각 쿼터가 하나의 파일 시스템을 포함할 수 있다. 저장장치는 또한 여러 개를 모아 한 디스크의 고장을 방지하는 RAID로 사용될 수 있다. 때로는 디스크를 분할한 후 모아서 RAID로 사용할 수 있다.
- 파티션은 개별 파일 시스템의 크기를 제한하거나, 하나의 디스크에 여러 개의 파일 시스템을 사용하거나, 파일 시스템으로 일부분을 사용하고 나머지 부분은 스왑 공간이나 포맷되지 않은 디스크 공간 같은 것들로 사용할 때 유용하다.
- 파일 시스템은 디스크의 파티션에 각각 생성될 수 있다. 파일 시스템을 포함하고 있는 임의의 개체를 볼륨이라고 부른다. 볼륨은 장치의 부분 집합, 전체 장치, 또는 RAID 집합으로 연결된 다수의 장치일 수 있다. 각 볼륨은 논리적인 가상 디스크로 취급될 수 있다. 볼륨은 하나 이상의 OS를 부팅하고 실행할 수 있도록 여러 개의 OS를 저장할 수 있다.
- 파일 시스템을 포함하고 있는 각 볼륨은 시스템에 존재하는 파일에 대한 정보 역시 가지고 있어야 한다. 이 정보를 `디바이스 디렉터리` 또는 `컨텐츠 볼륨 테이블`의 항목들에 저장된다. 디렉터리는 그 볼륨에 있는 모든 파일에 대한 이름, 위치, 크기, 타입과 같은 정보를 기록한다.

### 저장장치의 구조
- 컴퓨터 시스템은 파일 시스템이 없을 수도 있으며, 다양한 종류의 파일 시스템을 가질 수도 있다.
- 컴퓨터의 파일 시스템은 확장이 가능하다. 하나의 파일 시스템 안에서도 파일을 그룹으로 분리하여 관리하고 그룹에 대한 조치를 취하는 것은 유용하다. 이 구성은 디렉터리의 사용을 내포한다.

### 디렉터리 개관
- 디렉터리는 파일 이름을 해당 디렉터리 항목으로 변환해주는 심벌 테이블로 볼 수 있다. 이러한 관점하에서 디렉터리는 다양한 방법으로 구성될 수 있다.
- 특정한 디렉터리 구조를 고려할 때 각 디렉터리에 실행될 수 있는 연산들을 중심으로 생각해야 한다.
- 파일 찾기: 사용자는 특정 파일에 해당하는 항목을 찾기 위하여 디렉터리 구조를 탐색할 수 있어야 한다. 파일 이름들은 심벌릭한 형태를 가지며 비슷한 이름은 파일간의 관계를 암시할 수 있으므로, 특정 패턴과 일치하는 이름을 갖는 모든 파일을 찾을 수 있어야 한다.
- 파일 생성: 새로운 파일들을 생성하여 디렉터리에 추가한다.
- 파일 삭제: 더 이상 팔요하지 않은 파일들을 디렉터리에서 삭제한다.
- 디렉터리 나열: 디렉터리에 존재하는 파일들을 나열하고, 나열된 각 파일에 대한 디렉터리 항목의 내용을 보여준다.
- 파일의 재명명: 파일의 이름은 사용자에게 그 내용이 무엇인지를 알려주기 때문에 파일의 내용 또는 용도가 변경되었을 때 이름이 변경된 경우 디렉터리 구조 내에서 항목의 위치가 변경되어야 하는 경우도 있다.
- 파일 시스템의 순회: 파일 시스템의 모든 디렉터리를 순회하면서 그 안의 모든 파일들을 엑세스할 필요가 있다. 신뢰성 측면을 고려하면 전체 파일 시스템 구조와 내요을 주기적으로 저장해 두는 것이 좋다. 

### 1단계 디렉터리
- 모든 파일이 디렉터리 밑에 존재하는 방식이다. 이해하고 관리하기 쉬우나 파일이 많아지거나 다수의 사용자가 사용하는 시스템에서는 심각한 제약을 가지고 있다.
- 같은 디렉터리에 모든 파일이 존재하므로 각 파일들은 유일한 이름을 가져야 한다. 파일 이름은 UNIX는 255자로 제한된다.

### 2단계 디렉터리
- 각 사용자는 자신만의 사용자 파일 디렉터리(UFD)를 가진다. UFD는 비슷한 구조를 가지고 있지만 각 디렉터리에는 오직 한 사용자의 파일만을 저장한다. 
- 사용자 작업이 시작되거나 시스템에 사용자가 로그인하면 시스템의 마스터 파일 디렉터리(MFD)가 먼저 탐색된다. MFD는 사용자 이름이나 계정 번호로 색인되어 있고, 각 엔트리는 해당 사용자의 UFD를 가리키고 있다.
- 사용자가 특정한 파일을 찾고하면 사용자의 UFD에서만 탐색한다. 그러므로 UFD 내에서 파일 이름이 유일하다면, 다른 사용자들이 동일한 이름의 파일을 가질 수 있다. 파일 생성시 OS는 그 이름을 가진 파일이 이미 존재하는 지를 확인하기 위해서 그 사용자의 UFD만을 검색한다. 파일 삭제 시 OS는 검색이 지역적인 UFD 내에서만 일어나도록 제한되기 때문에 동일한 이름을 가진 다른 사용자의 파일을 삭제할 수 없다.
- 필요에 따라 사용자 디렉터리 자체를 만들고 없앨 수 있어야 한다. 적절한 사용자 이름과 계정 정보를 이용하여 특수 시스템 프로그램을 실행한다. 이 프로그램은 새로운 UFD를 생성하고 이를 가리키는 새로운 항목을 MFD에 추가한다. 이 프로그램의 실행은 시스템 관리자만 할수 있어야 한다. 
- 2단계 디렉터리 구조는 파일 이름이 충돌하는 문제는 해결하였으나 여전히 단점이 있다. 이 구조는 한 사용자를 다른 사용자로부터 격리시키지만 협력적 작업을 위한 다른 사용자의 파일 접근을 불허한다.
- 접근이 허용된다면, 한 사용자가 다른 사용자의 디렉터리에 잇는 파일을 지칭할 수 있어야 한다. 2단계 디렉터리에서 특정 파일을 유일하게 지칭하기 위해서는 반드시 사용자의 이름과 파일 이름 모두 알려줘야 한다. 2단계 디렉터리는 높이가 2인 트리 또는 역 트리로 생각할 수 있다. 트리의 루트는 MFD이고 UFD를 자식으로 가진다. UFD의 자손들은 파일이며 단말 노드가 된다. 사용자 이름과 파일 이름을 명시하는 것은 루트로부터 단말까지의 경로를 정의한다. 따라서 사용자 이름과 파일 이름은 경로 이름이 되고, 시스템의 모든 파일은 경로 이름을 가진다. 특정 파일을 유일하게 지칭하기 위해서 사용자는 원하는 파일의 경로 이름을 알아야 한다.
- 시스템마다 볼륨을 지칭하기 위한 추가 구문이 필요하다. 또한, 어떤 시스템들은 볼륨, 디렉터리 이름, 파일 이름들을 분리하여 포시한다.
- 이 상황의 특별한 경우는 시스템 파일의 경우에 발생한다. OS의 일부분으로 제공되는 로더, 어셈블러, 컴파일러, 유틸리티, 루틴, 라이브러리 등은 파일 형식을 취한다. 적합한 명령이 OS에게 전달되면 이 파일들은 로더에 의해 읽혀져서 실행된다. 많은 명령어 해석기들은 단순히 이러한 명렁어들을 적재하여 실행할 파일의 이름으로 취급한다. 디렉터리를 현재 형태로 정의한다면 파일 이름은 현재의 UFD에서 탐색된다. 한 가지 해결책은 시스템 파일을 각 UFD로 복사하는 것이다. 하지만 모든 시스템 파일을 복사하는 것은 엄청난 공간 낭비를 가져온다.
- 일반적인 해결책은 검색 절차를 약간 복잡하게 하는 것이다. 시스템 파일을 포함하고 있는 특수 사용자 디렉터리를 정의한다. 적재될 파일 이름이 주어질 때마다 OS는 우선적으로 현재 UFD를 검색한다. 못찾게 되면 시스템은 자동적으로 이러한 시스템 명령 파일들만 별도로 모아놓은 특수 사용자 디렉터리를 탐색한다. 파일 이름이 지칭될 때 마다 디렉터리를 탐색하는 순서를 탐색 경로라고 한다.

### 트리 구조 디렉터리
- 이 구조는 사용자들이 자신의 서브디렉터리를 만들어서 파일을 구성할 수 있게 한다. 트리는 가장 일반적으로 사용되는 디렉터리 구조이다. 트리 구조는 하나의 루트 디렉터리를 가지며, 시스템의 모든 파일은 고유한 경로 이름을 가진다.
- 디렉터리는 파일과 서브 디렉터리의 집합을 포함한다. 디렉터리는 단순히 또 다른 파일이지만 특별하게 취급된다. 모든 디렉터리들은 내부적으로 똑같은 형식을 가진다. 디렉터리의 각 항목은 한 비트를 사용하여 그 항목이 나타내는 파일이 일반 파일(0)인지 디렉터리 파일(1)인지를 구분한다. 디렉터리를 생성하거나 삭제하기 위해서는 특수한 시스템 호출이 사용된다.
- 통상적으로 각 프로세스는 `현재 디렉터리`를 가지고 있다. 현재 디렉터리 안에는 프로세스가 현재 관심을 가지고 있는 대부분의 파일이 들어 있다. 파일을 참조하면 현재 디렉터리가 먼저 검색한다. 만일 현재 디렉터리에 없는 파일을 참조하려면 경로 이름을 지정하거나 파일을 담고 있는 디렉터리를 현재 디렉터리가 되도록 변경해야 한다.
- 현재 디렉터리를 다른 디렉터리로 바꾸기 위해서는 시스템 호출이 제공되는데, 이 호출은 디렉터리의 이름을 인자로 받아서 새로운 현재 디렉터리를 정의한다. 따라서 사용자는 원하면 언제든지 현재 디렉터리를 바꿀 수 있다. change directory가 호출된 후 다음 호출까지 open() 시스템 호출은 지정된 파일을 현재 디렉터리에서 찾는다.
- 사용자 로그인 셸의 현재 디렉터리는 사용자 작업을 시작하거나 사용자가 로그인했을 경우 지정된다. OS는 사용자에 해당하는 항목을 찾기 위해서 계정 파일을 검색한다. 계정 파일은 사용자의 시작 디렉터리를 가리키는 포인터 또는 이름을 포함하고 있다. 이 포인터가 사용자의 최초 현재 디렉터리를 나타내는 사용자의 지역 변수에 복사된다. 이 셸로부터 다른 프로세스들이 생성되고, 보통 생성된 서브프로세스의 현재 디렉터리는 생성 당시의 부모 프로세스의 현재 디렉터리가 지정된다.
- 경로명에는 절대 경로명과 상대 경로명이 있다. 절대 경로명은 루트에서부터 지정된 파일까지의 경로가 명시된 것을 말하고, 상대 경로면이란 현재 디렉터리를 기준으로 목적하는 파일까지의 경로를 지정하는 것이다.
- 사용자가 자신의 하위디렉터리를 만들 수 있게 허용하면 사용자는 임의의 방식으로 파일을 구성할 수 있다.
- 트리 구조에서 정해야 하는 정책은 디렉터리의 삭제이다. 만약 디렉터리가 비어 있다면 삭제될 디렉터리를 포함하고 디렉터리의 해당 항목을 지우면 되지만, 제거 대상 디렉터리가 비어 있지 않은 경우를 고려해야 한다.
- MS-DOS의 경우 디렉터리에 있는 모든 파일을 삭제해야만 디렉터리를 삭제할 수 있다. UNIX는 rm 명령어와 같이 선택권을 준다.
- 트리 구조 시스템에서 사용자는 자신의 파일뿐만 아니라 다른 사용자의 파일에도 접근할 수 있다.
- 트리 구조에서 파일의 경로는 2단계 디렉터리보다 길어진다. 사용자가 이러한 긴 파일 경로를 기억하지 않고도 프로그램을 실행시킬 수 있도록 Macintosh OS는 실행 프로그램 검색을 자동화시켰다. 한 방법은 메타데이터 코드와 OS가 발견한 모든 실행 가능 프로그램의 이름과 위치를 포함하고 잇는 Desktop file이라는 파일을 사용하여 관리하는 것이다. 새로운 HDD가 시스템에 추가되거나 네트워크가 연결될때, OS는 디바이스에 있는 실행 파일을 찾기 위해 디렉터리 구조를 순회하고 관련 정보를 기록한다. 이 기법은 앞에서 기술한 더블 클릭 실행 기능을 지원한다. 파일을 더블 클릭하면, 파일의 생성자 속성을 읽어서 대응되는 정보를 찾기 위해서 Desktop file을 검색한다. 해당 항목이 검색되면, 그에 맞는 실행 파일이 더블 클릭된 파일을 입력으로 하여 실행된다.

### 비순환 그래프 디렉터리
- 트리 구조는 파일 또는 디렉터리의 공유를 허용하지 않는다. 비순환 그래프는 디렉터리들이 서브디렉터리들과 파일들을 공유할 수 있도록 허용한다. 동일한 파일이나 서브 디렉터리가 서로 다른 디렉터리에 있을 수 있다. 비순환 그래프는 트리 구조 디렉터리 방식을 일반화한 것이다.
- 공유 파일은 복사본과는 다르다. 공유 파일의 경우, 오직 하나의 파일만 존재하고 한 사람이 수정한 내용을 다른 사람도 즉시 보게 된다. 이러한 공유는 서브디렉터리의 경우 특히 중요한데, 한 사용자가 공유 디렉터리에 파일을 만들면 그 디렉터리를 공유하고 있는 모든 서브디렉터리에 자동적으로 반영된다.
- 공유하기를 원하는 모든 파일을 하나의 디렉터리에 놓을 수 있다. 각 구성원의 UFD에는 공유파일 디렉터리가 하위 디렉터리로 존재하게 된다. 단일 사용자 시스템의 경우에도 사용자의 파일 구성에 따라 몇몇 파일은 여러 디렉터리에 존재해야만 한다.
- 공유 파일은 여러 가지 방법으로 구현 가능하다. UNIX의 경우는 링크라 불리는 새로운 디렉터리 항목을 만드는 것이다. 링크는 실제로 다른 파일이나 서브디렉터리를 가리키는 포인터이다. 이러한 링크는 절대 혹은, 상대 경로명으로 구현될 수 있다. 파일에 대한 참조가 일어날 때 디렉터리를 검색한다. 만약 디렉터리 항목이 링크로 표시되어 잇다면, 실제 파일 이름은 링크 정보에 포함되어 있다. 그 경로 이름을 사용하여 링크를 해석하여 실제 파일의 위치를 찾는다. 링크는 디렉터리 항목의 형식을 통해서 수비게 구분될 수 있거나 파일 유형을 지원하는 시스템에서는 특수 유형의 파일로서 구분 가능하고 결과적으로 간접 포인터이다. OS가 디렉터리 트리를 순회할 때는 시스템의 비순환 구조를 유지하기 위해 이들 링크를 무시한다.
- 공유 파일을 구현하는 다른 방법은 공유하는 디렉터리들이 공유 파일에 대한 모든 정보를 복사해서 가지고 있는 방법이다.
- 비순한 그래프 디렉터리 구조는 단순 트리 구조보다 융통성이 있는 대신 더 복잡하다. 이 구조에서 파일은 여러 개의 절대 경로명을 가질 수 있다. 결과적으로 파일 이름이 다르더라도 동일한 파일을 가리킬수 있다. 이러한 경우 심각한 문제를 야기할 수 있다.
- 심벌릭 링크로 공유를 구현하는 시스템에서는 이러한 상황을 쉽게 해결할 수 있다. 심벌릭 링크를 지울 경우 원본 파일에는 아무 영향이 없고, 단지 링크만 제거되는 것이다. 파일 항목 자체가 지워지고 파일의 공간이 반납되면, 이 링크는 대상없는 포인터가 된다. 이러한 링크를 탐색하여 삭제할 수 있지만, 각 파일별로 자신을 가리키고 있는 링크의 목록을 유지하지 않는 한 검색에 소모되는 비용이 커지게 된다. 대안으로 그 링크를 사용하려는 시도가 있을 때까지는 링크를 그대로 둘 수 있다. 파일이 존재하지 않는 것을 알게 되고, 링크 이름을 해석하는 것은 실패하게 된다. UNIX의 경우 파일이 삭제될 때 심벌릭 링크는 그대로 둔다. 따라서 사용자에 달려있다. windows도 똑같은 방법을 사용한다.
- 삭제하는 또 다른 방법은 모든 참조가 지워질 때까지 원본 파일을 보존하는 것이다. 이 방법을 구현하기 위해서 파일에 대한 모든 참조의 리스트를 유지할 수 있다. 디렉터리 항목의 링크나 복사가 생성되면, 새로운 항목이 파일 참조 리스트에 추가된다. 링크 또는 디렉터리 항목이 지워지면 목록에서 해당 항목을 제거한다. 파일 참조 목록이 비게 되면, 원본 파일은 삭제된다.
- 이 방식의 문제점은 파일 참조 리스트의 크기가 가변적이고 매우 커질 수 있다는 것이다. 그러나 전체 목록을 유지할 필요는 없고 단지 파일을 가리키고 있는 개수만 유지하면 된다. 새로운 링크나 디렉터리 항목이 추가되면 참조 계수를 증가시키고, 링크나 디렉터리 항목이 삭제되면 계수를 감소시킨다. 계수가 0이 되면 파일은 삭제될 수 있다. UNIX는 하드링크에 대해서 파일 정보 블록(inode)에 참조 계수를 유지하여 이러한 방식을 사용한다. 디렉터리에 대한 다중 참조가 금지되어 있기 때문에 비순회 그래프 구조를 유지한다.

### 일반 그래프 디렉터리
- 2단계 디렉터리 구조에서 사용자가 하위 디렉터리를 생성할 수 있게 되면 트리 구조가 된다. 단순히 새로운 파일이나 디렉터리를 기존의 트리 구조 디렉터리에 추가하는 것은 트리 구조의 특성을 보존한다. 그러나 기존 트리 구조 디렉터리에 새로운 링크를 추가하면 트리 구조는 붕괴되고 일반적인 그래프 구조가 된다.
- 비순환 그래프의 장점은 그래프를 순회하고 파일에 대한 참조의 존재 여부를 결정하는 알고리즘이 간단하는 것이다. 성능상의 이유로 비순환 그래프의 공유 부분을 두 번 순회하는 것을 원하지 않는다. 주요 공유 서브디렉터리를 다시 탐색하는 것은 피하고 싶어 한다. 두 번째 탐색은 시간 낭비이기 때문이다.
- 디렉터리에서 순환이 허용될 경우에, 성능상 이유와 정확성의 이유 때문에 한 디렉터리를 두 번 탐색하려 하지 않을 것이다. 한 가지 해결책은 검색하는 동안 엑세스할 수 있는 디렉터리의 개수를 임의로 제한하는 것이다. 
- 순환이 존재하면 디렉터리나 파일은 더이상 가리키지 않더라도 참조 계수가 0이 아닐 수도 있다. 이 비정상적인 결과는 디렉터리 구조 안에 자기 참조가 생길 수 있다는 사실에 기인한다. 이 경우, 마지막 참조가 제거되고 디스크 공간이 재 할당될 수 있을 때를 결정하기 위해서 가비지 컬렉션 기법을 사용해야 한다. 가비지 컬렉션은 전체 파일 시스템을 순회하고, 접근 가능한 모든 것을 표시한다. 그 후 두 번째 탐색에서 표시되지 않은 것들을 수집하여 사용가능한 공간 리스트에 추가한다. 그러나 디스크 기반의 파일 시스템에서 가비지 컬렉션을 실행하면 시간을 엄청나게 소모하므로 좀 처럼 사용되지 않는다.
- 가비지 컬렉션은 오로지 그래프에 순환이 생길 가능성 때문에 필요하다. 따라서 비순환 그래프를 다루기가 훨 씬 쉽다. 새로운 링크가 디렉터리 구조에 추가될 때 순환이 생기지 않도록 하는 것이 어려운 문제이다.
- 그래프에 순환이 존재하는 지 검사하는 알고리즘중 간단한 것은 디렉터리와 링크의 경우에만 쓸수 있는데, 디렉터리를 순환할 때 링크는 우회하는 것이다. 순환을 피할 수 있고 추가적인 오버헤드도 발생하지 않는다.
