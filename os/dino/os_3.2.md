# 프로세스

## 프로세스 통신
- IPC(프로세스간 통신): 공유메모리와 메시지 전달의 두가지 모델이 있다.
- OS에서는 두 모델을 모두 구현하고 있다.
- 메시지 전달 모델은 공유 메모리 모델 보다 구현하기 쉽고, 공유 메모리 모델은 최대 속도와 편이를 제공한다.

### 공유 메모리 시스템
- 공유 메모리 영역은 공유 메모리 세그먼트를 생성하는 프로세스의 주소 공간에 위치한다. 이 세그먼트를 이용하여 통신하고자 하는 다른 프로세스들은 이 세그먼트를 자신의 주소 공간에 추가해야 한다.
- 생산자와 소비자 프로세스들이 병행으로 실행되도록 하려면, 생산자가 정보를 채워 넣고 소비자가 소모할 수 있는 항들의 버퍼가 반드시 사용 가능해야 한다. 이 버퍼는 공유하는 메모리 영역에 존재하게 된다. 생산자와 소비자가 동기화되는것은 중요하다.
- 두가지 유형의 버퍼가 사용된다. 무한버퍼는 버퍼의 크기에 한계가 없는 것으로 소비자는 새로운 항목을 기다려야만 할수도 있지만 생산자는 항상 새로운 항목을 생산할수 있다. 또 한가지는 유한 버퍼이다. 버퍼의 크기가 고정되어 있는 것으로 버퍼가 비어있으면 소비자는 대기하고 모든 버퍼가 채워져 있으면 생산자가 대기해야 한다.

### 메시지 전달 시스템
- 동일한 주소 공간을 공유하지 않고도 프로세스들이 통신을 하고, 그들의 동작을 동기화할 수 있도록 허용하는 기법을 제공한다.
- 메시지 전달 시스템은 최소 두가지 연산(send, receive)을 제공한다. 프로세스가 보낸 메시지는 가변 혹은 고정길이일 수도 있다.
- 하나의 링크와 send/receive 연산을 논리적으로 구현하는 방법들은 직간접적 통신(Naming), 동기/비동기식 통신, 자동/명시적 버퍼링등이 있다.

#### Naming
- 직접 통신 하에서, 통신을 원하는 각 프로세스는 통신의 수신자 또는 송신자의 이름을 명시해야 한다. 통신을 원하는 모든 프로세스의 쌍 사이에 연결이 자동적으로 구축된다. 프로세스들은 상대방의 신원만 알면 되며, 두 프로세스간만 연결이 된다. 프로세스간에는 하나의 연결만이 존재해야 한다. 
- 이 기법의 주소 방식에서는 대칭성을 보인다. 비대칭적 기법에서는 주소 지정시에 송신자만 수신자의 이름을 지명한다.
- 단점은 프로세스를 정확히 지정함으로써 모듈화를 제한한다는 것이다. 프로세스의 이름을 바꾸면 모든 다른 프로세스 지정부분에 대한 검사가 필요하다.
- 간접 통신에서 메시지들은 메일박스 혹은 포트로 송수신이 된다.
- 메일박스는 추상적으로 프로세스들에 의해 메시지들이 넣어지고 제거 될수 있는 객체라고 볼수 있다. 각 메일 박스는 고유의 식별자를 가진다. 그럼으로써 프로세스는 여러개의 다른 메일박스를 통하여 다른 프로세스들과 통신할 수 있다.
- 연결은 두개 이상의 프로세스들과 연관될 수 있다. 한 쌍의 프로세스 사이의 연결은 공유 메일 박스를 가질때만 구축된다. 
- 한 순간 최대 하나의 프로세스가 receive 연산을 실행하도록 허용한다.
- 메일박스는 한 프로세스 또는 OS에 의해 소유될 수 있다.

#### 동기화
- 동기식, 비동기식으로 구분된다.
- 동기식: 송신 프로세스의 메시지가 수신 프로세스 또는 메일박스에 의해 수신될때까지 대기한다, 수신 프로세스는 메시지가 이용 가능할 때까지 대기한다.
- 비동기식: 송신 프로세스가 메시지를 보내고 작업을 재시작한다. 수신 프로세스가 유효한 메시지 또는 null을 받는다.

#### 버퍼링
- 통신하는 프로세스들에 의해 교환되는 메시지는 임시 큐에 들어 있다.
- 무용량 큐: 큐의 길이가 0이다. 링크는 자체 안에 대기하는 메시지들을 가질 수 없다. 송신자는 수신자가 메시지를 수신할 때까지 기다려야 한다.
- 유한 용량: 큐의 길이가 유한하다. 용량만큼의 메시지가 들어갈수 있다. 큐가 다 찼다면, 송신자는 큐에 공간이 있을때까지 대기한다.
- 무한 용량: 큐는 무한의 길이를 가진다. 대부분의 메시지들이 큐안에서 대기할 수 있다.

## IPC 시스템의 예들

### Mach
- Mach에선 대부분의 시스템 호출과 모든 태스크간의 정보를 포함하여 메시지에 의해 실행된다.
- 메시지들은 메일박스로 송수신되고, 이것을 포트라 부른다.
- 각 태스크가 생성될때 커널 메일박스와 통지 메일박스가 생성된다. 커널 메일박스는 태스크가 커널과의 대화시에 사용되고, 커널은 통지 포트에 사건이 발생될 경우 통지를 보낸다.
- 메일박스는 메시지 큐를 가진다. 메시지 들은 고정 길이의 헤더와 가변 길이의 자료 부분으로 구성된다. 
- 헤더는 메시지의 길이와 두 개의 메일박스 이름을 가진다.
- 메시지의 가변부분은 타입을 가진 자료 항목의 리스트이다.
- 메일박스가 풀이면, 대기하거나, 무한 대기하거나, 기다리지 않거나, 메시지를 OS에게 보관하도록 캐시할수 있다.

### windows XP
- LPC에 의하여 메시지가 전달된다.
- 클라이언트가 서브시스템의 연결 포트 객체를 위한 핸들을 오픈한다. 클라이언트가 요청을 보내고 서버가 두 개의 통신 포트를 생성하고, 그중 하나를 클라이언트에 핸들을 반환한다. 클라이언트와 서버는 해당 포트 핸들을 사용하여 메시지나 콜백을 보내고 응답을 듣는다.
- 작은 메시지는 메시지 큐를 중간 저장장소로 활용하고, 한 프로세스에서 다른 프로세스로 복사하는 것이다.
- 큰 메시지의 경우, 색션 객체를 통해 메시지를 전달하는데 이 객체는 공유 메모리 영역을 구축한다.
- 색션 객체를 사용하려면 섹션 객체에 대한 포인터와 크기 정보를 수록한 작은 메시지를 보낸다. 데이터의 복사를 피하고 통신을 할수 있다.

## 클라이언트-서버 환경에서 통신

### 소켓
- 통신의 극점을 뜻한다. 양 프로세스마다 하나씩 필요하다. 각 소켓은 IP주소와 포트 번호를 통하여 구별한다.
- 일반적으로 서버-클라이언트 구조를 사용한다.
- 모든 연결은 유일해야 한다.
- 소켓은 스레드들 간에 구조화 되지 않은 바이트 스트림만을 통신하도록 한다.

### 원격 프로시저 호출(RPC)
- 네트워크에 연결되어 있는 두 시스템 사이의 통신에 사용하기 위하여 프로시저 호출을 추상화하기 위한 방편으로 설계되었다.
- IPC 기반위에 만들어져 있다.
- 전달되는 메시지는 구조화 되어 있고 따라서 데이터의 패킷 수준을 넘어서게 된다.
- 포트는 단순히 메시지 패킷의 시작부분에 포함되는 정수이다. 원격 프로세스가 서비스를 받고자 하면 그 서비스에 대응되는 적절한 포트주소로 메시지를 보내야한다.
- RPC는 클라이언트가 자기의 프로시저를 호출하는 것처럼 원격 호스트의 프로시저를 호출할 수 잇게 해준다. 이 시스템은 클라이언트 쪽에 스텁을 제공하여 통신을 하는데 필요한 자세한 사항들을 숨겨준다.
- 클라이언트가 원격 프로시저를 호출하면 RPC는 그에 대응하는 스텁을 호출하고 원격 프로시저가 필요로 하는 매개변수를 건네준다. 스텁이 원격 서버의 포트를 찾고 매개변수를 네트워크로 전송하기 위해 적절한 형태로 재구성한다. 그후 스텁은 메시지 전달 기법을 사용하여 서버에게 메시지를 전송한다. 서버의 스텁은 메시지를 수신후, 그에 맞는 서버의 프로시저를 호출한다.
- 데이터 표현 방식(MSB 혹은 LSB)의 차이를 해결하기 위하여 기종 중립적인 데이터 표현 방식을 정의한다(XDR). 클라이언트가 메시지를 보내기전에 XDR 형태로 변환하고 보내며, 서버도 이 데이터를 받아 자신의 형태로 변환한다.
- 중복된 메시지를 검사하기 위하여 타임스탬프를 사용한다. 각 메시지에 이것을 매기고, 서버는 중복된 타임스템프 기록을 가진 메시지를 무시한다.

### 파이프
- 두 프로세스가 통신할 수 있게 하는 전달자
- 생산자-소비자 형태로 두 프로세스 간의 통신을 허용한다. 파이프는 한쪽으로만 데이터를 전송할 수 잇다.
- 파이프는 파이프를 생성한 프로세스 이외에는 접근할 수 없다. 부모와 자식 프로세스간의 통신하기 위하여 보통 사용된다.

### Named 파이프
- 보통의 파이프는 오직 프로세스들이 통신하는 동안에만 존재한다. 통신을 마치면 사라지게 된다.
- 네임드 파이프는 양방향으로 통신이 가능하며, 부모-자식 관계도 필요하지 않는다.
- 통신 프로세스가 종료하더라도 지명 파이프는 계속 존재하게 된다.
- Unix의 FIFO, windows의 namepipe가 있다.