# 다중 스레드 프로그래밍
- 사용자 스레드는 프로그래머는 알고 있지만, 커널은 그 존재를 모르는 스레드이고 커널 스레드는 커널에 의해서 지원되며 관리된다. 일반적으로 커널의 개입이 없기 때문에 커널 스레드 보다 사용자 스레드가 빠르게 생성되고 빠르게 관리된다.

## 스레드와 관련된 문제들
- 다중 스레드 프로그램에서는 fork()와 exec()의 의미가 달라질 수 있다. 
- fork()는 모든 스레드를 복사하는 것과 또는 fork()를 호출한 스레드만 복제하는 것을 제공한다. 어떤 방법을 사용할지는 애플리케이션에게 달려있다. fork()를 부르자마자 다시 exec()을 부른다면 exec()에서 지정한 프로그램이 곧 모든 것을 다시 대체할 것이기 때문에 호출한 스레드만 복사해주는 것이 적절하다. 그러나 새 프로세스가 fork()후 exec()을 하지 않는다면 새 프로세스는 모든 스레드들을 복제해야 한다.
- exec()는 보통의 역할과 똑같이 실행된다. 즉 어떤 스레드가 exec()를 부르면 exec()의 매개변수로 지정된 프로그램이 모든 스레드를 포함한 전체 프로세스를 대체시킨다.

## 취소
- 스레드 취소는 스레드가 끝나기 전에 강제 종료시키는 작업을 말한다. 취소되어야할 스레드를 `목적 스레드`라고 부른다.  목적 스레드의 취소는 비동기식과 지연식이 있다.
- 비동기식 취소: 한 스레드가 목적 스레드를 즉시 강제 종료시킨다.
- 지연 취소: 목적 스레드가 주기적으로 자신이 강제 종료해야 하는 지를 검사한다. 목적 스레드는 질서정연하게 자신을 강제 종료시킬 수 있는 기회가 주어진다.
- 스레드 취소를 어렵게 만드는 것은 취소 스레드들에게 할당된 자원 문제이다. 또한 스레드가 다른 스레드와 공유하는 자료구조를 갱신하는 도중에 취소 요청이 와도 문제가 된다. 
- 후자의 문제는 비동기식 취소의 경우 더 심각하다. 종종 OS는 취소된 스레드로부터 시스템 자원을 회수할 수도 있지만, 모든 시스템 자원을 다 회수하지 못하는 경우도 있다. 따라서 비동기식으로 스레드를 취소하면 필요한 시스템 자원을 모두 사용 가능한 상태로 만들지 못할수 있다.
- 지연 취소의 경우에는 한 스레드가 목적 스레드를 취소해야 한다고 표시하지만 실제 취소는 목적 스레드가 취소 여부를 결정하기 위한 플래그를 검사한 이후에야 일어난다. 스레드들은 자신이 취소되어도 안전하다고 판단되는 시점에서 취소 여부를 검사할수 있다. Pthreads는 이러한 지점을 취소점이라고 부른다.

## 신호 처리
- 신호는 UNIX에서 프로세스에게 어떤 사건이 일어났음을 알려주기 위해 사용된다.
- 신호는 알려줄 사건의 근원지나 이유에 따라 동기식 또는 비동기식으로 전달될 수 있다.
- 동기식이건 비동기식이건 모든 신호는 특정사건이 일어나야 생성된다. 그후 프로세스에게 전달되고, 전달된 신호는 반드시 처리되어야 한다.
- 동기식 신호의 예로는 불법적인 메모리 접근와 0으로 나누기 등이 있다. 실행 중인 프로그램이 이러한 행동을 하면 신호가 발생된다. 동기식 신호는 신호를 발생시킨 연산을 실행한 동일한 프로세스에게 전달된다.
- 신호가 실행중인 프로세스 외부로부터 발생되면 그 프로세스는 신호를 비동기식으로 전달 받는다. 이러한 신호의 예는 특수한 키를 눌러스 프로세스를 강제 종료시키거나 타이머가 만료되는 경우가 포함된다. 비동기식 신호는 통상 다른 프로세스에게 전달된다.
- 모든 신호는 디폴트 신호처리기(모든 신호마다 커널에 의해 실행)나 사용자 정의 신호 처리기에서 처리된다. 어떤 신호들은 그냥 무시될수도 있다. 어떤 신호는 그 프로세스는 그 프로세스를 강제 종료시켜 처리될 수 있다.
- 신호를 전달시 스레드를 선택할때는 신호가 적용될 스레드에게 전달하는 방법, 모든 스레드에게 전달하는 방법, 몇몇 스레드들에게만 선택적으로 전달하는 방법 그리고 특정 스레드가 모든 신호를 전달받도록 지정하는 방법이 있다.
- 신호를 전달하는 방법은 신호의 유형에 따라 다르다. 동기식 신호는 그 신호를 야기한 스레드에게 전달되어야 하고 다른 스레드에게 전달되면 안 된다. 그러나 비동기식 신호의 경우는 명확하지 않다.
- 대부분의 다중 스레드 UNIX는 스레드가 신호를 전달받거나 봉쇄할 수 있는 선택권을 준다. 따라서 어떤 경우에는 비동기식 신호를 받겠다고 지정한 스레드들에게만 신호를 전달한다. 그러나 신호를 오직 한번만 처리되어야 하기 때문에 그 신호를 받겠다고 선언한 스레드들 중 첫 번째 스레드에게만 신호가 전달된다. 
- Windows는 신호를 명시적으로 지원하지는 않지만 `비동기식 프로시저 호출(APC)`이라는 것을 사용해서 이를 대리 실행할 수 있다. APC는 사용자 스레드들이 특정 사건의 발생을 전달 받았을 때 호출될 함수를 지정할 수 있게 한다. APC는 프로세스에게 전달되는 것이 아니라 특정 스레드에게 전달되기 때문에 좀 더 간단하다.

## 스레드 풀
- 다중 스레드 서버는 여러 문제를 가진다. 서비스할 때 마다 스레드를 생성하는데 소요되는 시간이다 그리고 모든 요청마다 새 스레드를 만들어서 서비스해 준다면 시스템에서 동시에 실행할 수 있는 최대 스레드 수가 몇개 까지 가능할 수 있는 것인지 한계를 정해야 한다. 스레드를 무한정 만들면 언젠가는 CPU시간, 메모리 공간 같은 시스템 자원이 고갈된다. 이러한 문제들을 해결해 줄수 있는 방법 중 하나가 `스레드 풀`이다.
- 프로세스를 시작할 때 아예 일정한 수의 스레드들을 미리 풀로 만들어 두는 것이다.
- 스레드들은 요청이 들어오기 전까지 대기한다. 요청이 끝나면 다시 스레드 풀로 돌아가 대기한다.
- 풀에 남아있는 스레드가 바닥나면 서버는 가용 스레드가 하나 생길 때까지 기다려야 한다.

### 장점
- 새 스레드를 만들어 주기보다 기존 스레드로 서비스해 주는 것이 더 빠르다.
- 스레드 풀은 임의 시각에 존재할 스레드 개수에 제한을 둔다. 이러한 제한은 많은 수의 스레드를 병렬 처리할 수 없는 시스템에 도움이 된다.

## 스레드별 데이터
- 한 프로세스에 속한 스레드들은 그 프로세스의 데이터를 모두 공유한다. 그러나 상황에 따라서는 각 스레드가 자기만 액세스할 수 있는 데이터를 가져야 할 필요도 있다. 이것을 `스레드별 데이터`라 한다.
- 스레드 라이브러리는 어떤 형태로든 스레드별 데이터를 지원한다.

## 스케줄러 액티베이션
- 스레드 라이브러리와 커널의 통신 문제도 존재한다. 특히 다대다 및 두 수준 모델에서 반드시 해결해야 할 문제이다. 이러한 통신의 조정은 애플리케이션이 최고의 성능을 보이도록 보장하기 위하여 커널 스레드의 수를 동적으로 조절하는 것을 가능케한다.
- 다대다 또는 두 수준 모델을 구현하는 많은 시스템들은 사용자와 커널 스레드 사이에 중간 자료 구조를 둔다. 이 자료구조는 경량 프로세스 또는 `LWP`라고 불린다.
- 사용자 스레드 라이브러리에게 LWP 방식은 애플리케이션이 사용자 스레드를 실행하기 위하여 스케줄할 가상 처리기처럼 보인다.
- 각 LWP는 하나의 커널 스레드에 부속되어 있으며, 물리 처리기에서 스케줄하는 대상은 바로 이 커널 스레드이다. 입출력이 완료되기를 기다리는 동안과 같이 커널 스레드가 봉쇄되면 LWP도 같이 봉쇄된다. 또한, LWP에 부속된 사용자 스레드도 역시 봉쇄된다.
- 애플리케이션은 효율적으로 실행되기 위하여 임의의 개수의 LWP를 필요로 할 수도 있다. 통상 동시에 발생하는 봉쇄형 시스템 호출마다 하나의 LWP가 필요하다.
- 사용자 스레드 라이브러리와 커널 스레드 간의 통신 방법 중의 하나는 `스케줄러 액티베이션`이라고 하는 것이다.
- 스케줄러 액티베이션은 작동 방식은 커널이 애플리케이션에 LWP의 집합을 제공하고 애플리케이션은 사용자 스레드를 가용한 LWP로 스케줄 한다. 게다가 커널은 애플리케이션에게 특정 사건에 대해 알려줘야 한다. 이 프로시저를 `업콜`이라고 부른다. 업콜은 스레드 라이브러리의 업콜 처리기에 의해 처리되고, `업콜 처리기`는 LWP상에서 실행되어야 한다. 업콜을 일으키는 한 사건은 응용 스레드가 봉쇄하려고 할 때 발생한다.

## 운영체제 사례

### windows xp 스레드
- win32 API를 구현한다. 이것은 마이크로소프트에서 나오는 모든 OS의 기본적인 API다.
- 이 OS에서 실행되는 애플리케이션들은 프로세스 형태로 실행되며 이들 각 프로세스는 한 개 또는 그 이상의 스레드를 가질 수 있다.
- XP는 일대일 대응 모델을 사용한다.
- XP는 fiber 라이브러리도 제공한다. 이 라이브러리는 다대다 모델의 기능성을 제공한다. 
- 스레드 라이브러리를 사용하여 프로세스에 속한 모든 스레드들은 그 프로세스의 가상 주소 공간을 접근할 수 있다.
- 스레드의 일반적인 구성 요소는 각 스레드를 유일하게 나타내는 스레드 ID, 처리기의 상태를 나타내는 레지스터 집합, 사용자 모드에서 실행될 떄 필요한 사용자 스택, 커널 모드에서 실행될 때 필요한 커널 스택, 실행시간 라이브러리와 DLL등이 사용하는 개별 데이터 저장영역이 있다.
- 레지스터 집합, 스택, 개별 데이터 저장 영역들은 그 스레드의 문맥으로 불린다. 스레드를 위해서 ETHREAD(실행 스레드 블록), KTHREAD(커널 스레드 블록), TEB(스레드 환경 블록)을 가지고 있다.
- ETHREAD의 주요 내용은 그 스레드가 속한 프로세스를 가리키는 포인터와 그 스레드가 실행을 시작해야 할 루틴의 주소 등이다. KTHREAD에 대한 포인터도 가지고 있다.
- KTHREAD는 스레드의 스케줄링 및 동기화 정보를 가지고 있다. 또한, 이 스레드가 커널 모드에서 실행될 때 사용되는 커널 스택과 TEB에 대한 포인터를 가지고 있다.
- ETHREAD와 KTHREAD는 모두 커널 안에 존재한다. 이는 커널만이 이들을 접근할 수 있다는 것이다.
- TEB는 스레드 식별자, 사용자 모드 스택 및 스레드별 데이터를 저장하기위 한 배열을 가지고 있다.

### Linux 스레드
- 프로세스를 복제하는 기능을 가진 fork() 시스템 호출을 제공한다. Linux는 clone() 시스템 호출을 이용하여 스레드를 생성할 수 있는 기능도 제공한다. 그러나 Linux는 프로세스와 스레드를 구별하지 않는다.
- 사실 Linux는 프로그램 내의 제어 흐름을 나타내기 위하여 프로세스나 스레드보다 일반적인 태스크라는 용어를 사용한다. 
- clone()이 호출될 때 플래그의 집합이 전달되고 이 플래그들이 부모와 자식 태스크 간에 얼마만큼의 공유를 허용하는 지를 결정한다.
- clone()이 플래그를 전달 받으면, 부모 태스크와 자식 태스크는 같은 파일 시스템 정보 같은 메모리 공간, 같은 신호 처리기와 같은 열린 파일의 집합을 공유하게 된다.
- clone()을 사용하는 것은 부모 태스크가 자식 태스크와 거의 모든 자원을 공유하기 때문에 스레드를 생성하는 것과 같은 결과가 된다. 그러나 아무 플래그 없이 clone()이 호출되면 공유는 일어나지 않게 되고 fork()의 기능과 같은 것을 제공한다.
- Linux 커널이 태스크를 표현하는 방식 때문에 다양한 공유 수준이 가능하다. 시스템의 태스크 마다 고유한 커널 자료 구조가 존재한다. 
- 이 자료 구조는 태스크의 데이터를 저장하는 것이 아니라 데이터가 저장되어 있는 다른 자료 구조를 가리키는 포인터를 포함한다. 다른 자료구조에는 열린 파일의 리스트를 나타내는 자료구조, 신호 처리 정보 및 가상 메모리 등이 있다.
- fork()가 호출되면 부모 프로세스 해당 자료 구조를 복사함으로써 새로운 태스크를 생성한다. clone()을 사용하여 새로운 태스크를 생성할 수도 있다 그러나 모든 데이터를 복사하는 것이 아니라 플래그에 따라 부모 태스크의 자료구조를 가리키게 된다.
- 리눅스 대부분은 NPTL 스레드 라이브러리를 포함하는데, 이것은 Linux 시스템을 위하여 POSIX-호환 스레드 모델을 지원하고 NUMA 지원의 이점과 보다 나은 SMP 시스템 지원등이 포함된다. 또한, 스레드 생성시 드는 시작 비용이 전통 Linux 스레드 보다 적다. 마지막으로 NPTL을 이용하면 시스템은 매우 많은 수의 스레드를 지원할 수 있는 잠재력을 가지게 된다.