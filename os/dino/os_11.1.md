# 파일 시스템 구현

## 파일 시스템 구조
- 디스크는 재기록이 가능하다. 또한 디스크는 저장하고 있는 임의의 정보 블록을 직접 엑세스할 수 있다. 따라서 임의의 파일에 순차적 또는 무작위 방법으로 쉽게 접근할 수 있다. 그리고 한 파일부터 다른 파일로 전환이 요구 될 때, 읽기-쓰기 헤드를 이동시키고 디스크가 회전하는 동안 기다리면 된다.
- 입출력 효율을 향상시키기 위해 메모리와 디스크간의 입출력 전송은 블록 단위로 실행된다. 각 블록은 하나 이상의 섹터를 가진다.
- `파일 시스템`은 쉽게 데이터를 저장하고, 찾고 또한 인출할 수 있게 함으로써 디스크를 보다 효율적이고 편리하게 사용할 수 있게 한다. 파일 시스템은 크게 두가지의 설계 문제를 제기한다. 첫 번째는 파일 시스템이 사용자에게 어떻게 보여야 할지를 정의하는 것이다. 이 작업은 파일과 속성, 파일에 허용된 연산, 파일을 정리하기 위한 디렉터리 구조를 정의하는 것을 포함한다. 두 번째 문제는 논리 파일 시스템을 물리적인 2차 저장장치로 맵핑하는 알고리즘과 자료구조를 고안하는 것이다.
- 파일 시스템 자체는 여러 층으로 이루어져 있다. 제일 낮은 층인 입출력 제어 층은 `장치 드라이버`와 인터럽트 핸들러로 이루어져 있고 메모리와 디스크 시스템간의 정보 전송을 담당한다. 장치 드라이버는 번역기라고 생각할 수 있다. 입력은 "블록 23을 검색하라"와 같은 고수준의 명령이고, 출력은 하드웨어 제어기에 의해 사용되는 특정 하두웨어에 맞는 저수준의 명령으로, 이들 명령은 입출력장치를 시스템의 다른 부분에 접속시킨다. 장치 드라이버는 통상 입출력 제어기 메모리의 특별한 위치에 특정 비트 패턴을 설정하여 장치 내의 어떤 위치에 무슨 작업을 해야 할지를 알린다.
- `기본 파일 시스템`층은 적절한 장치 드라이버에게 디스크 상의 물리 블록을 읽고 쓰도록 일반적인 명령을 내리는 층이다. 이때 각 디스크 블록은 숫자로 표시된 디스크 주소에 의하여 식별된다. 이 층은 또한 다양한 파일 시스템, 디렉터리 및 데이터 블록을 저장하는 메모리 버퍼와 캐시를 관리한다. 버퍼 내의 블록은 디스크 블록의 전송이 일어나기 전에 할당된다. 이 버퍼가 가득 차면, 버퍼 관리자는 요청된 입출력이 완료될 수 있도록 더 많은 버퍼 메모리를 찾아내거나 버퍼의 자유 공간을 확보해야 한다. 캐시는 종종 성능을 향상시키기 위해 파일 시스템 메타데이터를 저장하는 데 사용된다. 따라서 최적의 성능을 위해서 캐시 내용의 관리는 필수적이다.
- `파일-구성 모듈`층은 물리 블록뿐만 아니라 파일과 파일의 논리 블록도 알고 있다. 사용 중인 파일 할당의 타입과 파일의 위치를 알고 있기 때문에 이 모듈은 논리 블록 주소를 물리 블록 주소로 변환할 수 있다. 각 파일이 놀리 블록은 0부터 N까지 번호가 매겨진다. 데이터를 저장하고 있는 물리 블록은 통상 논리 번호와 일치하지 않기 때문에 각 블록의 위치를 알아내기 위해서 변환이 필요하다. 파일-구성 모듈은 가용 공관 관리자도 포함하고 있는데, 이 관리자는 할당되지 않은 블록을 추적하고 요청이 있을 때 파일-구성 모듈에게 블록을 공급한다.
- `논리 파일 시스템`층은 메타데이터 정보를 관리한다. 메타데이터는 실제 데이터 또는 파일의 내용을 제외한 모든 파일 시스템 구조를 포함한다. 논리 파일 시스템은 디렉터리 구조를 관리하며, 심벌릭 이름이 주어지며, 파일-구성 모듈이 필요한 정보를 제공한다. 파일 구조는 파일 제어 블록을 통해 유지된다. `파일 제어 블록(FCB)`는 소유, 허가 그리고 파일 내용의 위치를 포함한 파일에 관한 정보를 가지고 있다. 대부분의 UNIX 파일 시스템에서는 `inode`로 구현된다. 논리 파일 시스템은 보호와 보안을 책임진다.
- 파일 시스템을 구현하기 위해 계층 구조를 사용할 때 코드의 중복이 최소화된다. I/O제어와 때로는 기본 파일 시스템 코드는 여러 파일 시스템에 의해 사용될 수 있다. 각 파일 시스템은 자신의 논리 파일 시스템과 파일-구성 모듈을 가진다. 불행히도 계층화는 더 많은 OS 오버페드를 야기하여 성능을 저하시킨다. 몇개의 계층을 사용하고 각 층은 무슨 작업을 할지는 설계의 주요 결정사항이다.
- 대부분의 OS가 하나 이상의 파일 시스템을 지원한다. 예로, CD-ROM들은 ISO 9660 포맷을 사용한다. 
- 이동 가능한 미디어 파일 시스템뿐 아니라 각 OS는 하나 이상의 디스크 기반 파일 시스템을 가진다. UNIX는 `UFS`을 사용한다. Windows XP는 디스크 파일 시스템으로 `FAT, FAT32, NTFS` 포맷을 지원한다. LINUX는 40가지가 넘는 파일 시스템을 지원하지만, 표준 파일 시스템은 `extended file system`이다. 현재 많이 사용되는 버전은 ext2 및 ext3 버전이다.

## 파일 시스템 구현
- 디스크에 존재하는 파일 시스템은 디스크에 저장된 OS를 어떻게 부트시키는지, 블록의 총 개수, 가용 블록의 수와 위치, 디렉터리 구조 그리고 개별 파일에 대한 정보를 가지고 있다.
- `부트 제어 블록`은 시스템이 볼륨으로부터 OS를 부트시키기 위해 필요한 정보를 가지고 있다. 디스크가 OS를 가지고 있지 않다면 부트 제어 블록은 비어 있을 것이다. 부트 제어 블록은 일반적으로 볼륨의 첫 번째 블록이다. UFS에서는 부트 블록, NTFS에서는 파티션 부트 섹터라 한다.
- `볼륨 제어 블록`은 볼륨의 블록의 수, 블록의 크기, 가용 블록의 수와 포인터, 그리고 가용 FCB 수와 포인터 같은 상세한 볼륨 정보를 가진다. UFS에서는 수퍼 블록, NTFS에서는 마스터 파일 테이블이라 한다.
- 디렉터리 구조는 파일 시스템마다 존재하며 파일을 조직하는 데 사용된다. UFS에서는 디렉터리 구조에 파일 이름 및 해당 inode 번호가 저장된다. NTFS에서는 디렉터리 구조가 마스터 파일 테이블에 저장된다.
- 파일별 FCB는 자세한 파일 정보를 가지고 있다. FCB는 디렉터리 항목과의 연결을 위한 고유한 식별 번호를 가지고 있다. NTFS에서 이 정보는 실제적으로 마스터 파일 테이블 안에 저장되며, 파일마다 행을 가진 관계 DB 구조를 사용한다.
- 메모리 내의 정보는 파일 시스템 관리와 캐싱을 통한 성능 향상을 위해 사용된다. 이 정보들은 마운트 시점에 적재되고, 파일 시스템 동작 중에 갱신되며, 마운트 해제 시에 제거된다. 메모리 내 마운트 테이블은 각 마운트된 볼륨 정보를 포함한다. 메모리 내 디렉터리 구조 캐시는 최근 접근된 디렉터리의 디렉터리 정보를 유지한다. `범시스템 열린 파일 테이블`은 다른 정보와 더불어 모든 열린 각 파일의 FCB의 복사본을 가지고 있다. `프로세스별 열린 파일 테이블`은 다른 정보뿐만 아니라 범 시스템 오픈 파일 테이블 내의 해당 항목에 대한 포인터를 포함한다. 버퍼는 파일 시스템이 디스크로부터 읽혀지거나 써빌 때 파일 시스템 블록을 저장한다.
- 새로운 파일을 생성하기 위해 애플리케이션은 논리 파일 시스템을 호출한다. 논리 파일 시스템은 디렉터리 구조의 포맷을 알고 있다. 새로운 파일을 생성하기 위해 파일 시스템은 새로운 FCB을 할당한다.(파일 시스템 구현이 파일 시스템 생성시에 모든 FCB를 만들어 둔다면, 가용 FCB 집합으로부터 FCB를 할당받는다.) 그런 후에 해당 디렉터리를 메모리로 읽어 새로운 파일 이름과 FCB로 디렉터리를 갱신하여 디스크에 다시 쓴다. 전형적인 FCB에는 파일 허가, 파일 날짜, 소유자, 그룹, ACL, 크기, 데이터 블록들이 저장되어 있다.
- UNIX를 포함하여 몇몇 OS에서는 디렉터리를 파일을 처리하는 방식과 정확히 같은 방식으로 처리한다. 물론 디렉터리는 타입 필드가 디렉터리임을 할당받는다. Windows 같은 OS는 파일과 디렉터리를 위한 개별 시스템 호출을 구현하고, 디렉터리를 파일과는 다른 개체로 취급한다. 더 큰 구조적 쟁점이 무엇이든 간에 논리적 파일 시스템은 디렉터리 입출력을 디스크 블록 번호로 맵핑하기 위하여 파일-구성 모듈을 호출한다. 이 블록 번호는 기본 파일 시스템과 입출력 제어 시스템에게 전달된다.
- open() 시스템 호출은 논리적 파일 시스템에게 파일 이름을 넘겨준다. open() 시스템 호출은 우선 파일이 이미 다른 프로세스에 의해 사용 중인지 확인하기 위하여 범 시스템 열린 파일 테이블을 검색한다. 사용 중이면, 기존 범 시스템 열린 파일 테이블을 가리키는 프로스세별 열린 파일 테이블 항목이 생성된다. 이 알고리즘은 상당한 오버헤드를 줄일 수 있다. 만일 파일이 오픈되지 않았다면, 주어진 파일 이름을 디렉터리 구조에서 찾는다. 디렉터리 연산의 속도를 향상시키기 위해 통상 디렉터리 구조의 일부를 메모리에 캐싱한다. 파일이 발견되면 FCB가 메모리 내의 범 시스템 열린 파일 테이블에 복사된다. 이 테이블은 FCB를 저장할 뿐만 아니라, 파일을 연 프로세스의 수도 추적한다.
- 범시스템 열린 파일 테이블의 항목을 가리키는 포인터와 기타 필드를 갖는 새로운 항목이 프로세스별 열린 파일 테이블 안에 만들어진다. 이 필드들은 파일 안의 현재 위치를 가리키는 포인터와 파일이 열린 접근 모드 등을 포함한다. open() 시스템 호출은 프로세스별 파일 시스템 테이블 내의 해당 항목에 대한 포인터를 반환한다. 그 후 모든 파일 연산은 이 포인터를 통해 실행된다. 일단 해당 FCB를 디스크에서 찾으면 시스템은 파일 이름을 더 이상 사용하지않기 때문에, 파일 이름은 열린 파일 테이블의 한 부분이 아니다. 그러나 같은 파일을 여는 이후의 open() 호출 시, 시간을 절약하기 위해 캐시될 수 있다. 이 항목은 UNIX에서는 `파일 디스크립터`라고 하고, Windows에서는 `파일 핸들`이라고 한다.
- 프로세스가 파일을 닫을 때, 프로세스별 테이블 항목이 제거되며 범 시스템 항목의 열린 계수는 감소된다. 열렸던 모든 사용자가 파일을 닫으면 디스크 기반 디렉터리 구조에 업데이트 된 파일 정보가 복사되며, 범 시스템 열린 파일 테이블에서 그 항목이 삭제된다.
- 어떤 시스템에서는 네트워킹과 같은 다른 시스템 요소에 대한 인터페이스로 파일 시스템을 사용하기 때문에 이러한 기법을 더욱 복잡하게 한다. 예를 들어, UFS에서 범 시스템 열린 파일 테이블은 파일과 디렉터리를 위한 inode와 기타 정보를 저장하고 있다. 또한, 네트워크 연결과 장치에 대해서도 비슷한 정보를 저장한다. 이런 방법으로 하나의 기법을 여러 목적으로 사용할 수 있다.
- 파일 시스템 구조에 캐싱 측면을 간과해서는 안된다. 대부분의 시스템은 실제 데이터 블록을 제외하고 열린 파일의 모든 정보를 메모리에 저장한다. 디스크 입출력 작업을 줄일 수 있으면 어디에나 캐시를 사용하는 전형적인 예로는 BSD UNIX 시스템을 들수 있다. 평균 캐시 적중률이 85%라는 사실은 이러한 기술이 구현할 가치가 있다는 것을 말해준다.

### 파티션과 마운팅
- 디스크는 여러 파티션으로 분할될 수 있고, 또는 하나의 볼륨이 여러 디스크의 여러 파티션에 걸쳐 있을 수 있다.
- 각 파티션은 파일 시스템을 포함하지 않는 raw 파티션이나 파일 시스템을 포함하는 가공 파티션으로 나누어질 수 있다. Raw 디스크는 어떤 파일 시스템도 적합하지 않는 곳에 사용된다. 예를 들어, UNIX 스왑 공간은 디스크 상에 자신의 고유 포맷을 사용하고 파일 시스템을 사용하지 않으므로 이 raw 파티션을 사용한다. 마친가지로 몇몇 DB에서 raw 디스크를 사용하여 데이터를 그들의 요구에 맞게 포맷한다. 또한 raw 디스크는 RAID 시스템에서 필요한 정보를 저장할 수 있으며, 어느 블록이 미러드(mirrored)되었는지, 또는 어느 블록이 변경되어 미러드될 필요가 있는지를 가리키는 비트맵이 그러한 예 중 하나다. 유사하게 raw 디스크는 어느 디스크가 각 RAID 세트의 멤버인지를 가리키는 RAID 구성 정보를 수록한 축소형 DB를 포함할 수 있다.
- 부트 정보는 별도의 파티션에 저장될 수 있다. 부트할 때 시스템은 파일 시스템 코드가 적재되어 있지 않으며, 따라서 파일 시스템 형식을 해석할 수가 없으므로, 부트 정보는 자신의 형식을 가진다. 부트 정보는 통상 일련의 순차 블록으로 메모리에 하나의 이미지로 로드된다. 이 이미지의 실행은 첫 번째 바이트 같은 미리 정해진 위치에서부터 시작된다. 이 부트 로더는 이번에는 커널의 위치를 찾아 적재하고 실행할 수 있도록 파일 시스템의 구조를 충분히 알고 있다. 이 부트 로더는 최소한 특정 OS를 부트할 수 있는 명령어들을 포함하고 있다. 
- 여러 파일 시스템과 여러 OS들을 인식하는 부트 로더가 부트 공감을 점유할 수 있다. 일단 로드되면, 그 디스크에서 이용 가능한 OS 중 하나를 부트할 수 있다. 디스크는 여러 파티션을 가질 수 있는데 각 파티션이 다른 종류의 파일 시스템과 다른 OS를 포함할 수도 있다.
- OS 커널과 더불어 다른 시스템 파일을 포함하고 있는 루트 파티션은 부트 시에 마운트된다. 다른 파티션은 부트 시에 자동으로 마운트되거나 OS에 따라 수동으로 나중에 마운트된다. 마운트 연산 중에 OS는 시스템이 유효한 파일 시스템을 가지고 있는 가를 확인한다. OS는 디바이스 드라이버에게 디바이스 디렉터리를 읽도록 요청하고 디렉터리가 유효한 포맷을 가졌는지 확인함으로써 이 과정을 실행한다. 포맷이 유효하지 않다면 사용자의 중재에 의하거나 또는 중재 없이 파티션의 일관성을 검사하고 가능하다면 바로잡으려 할 것이다. 
- 마지막으로 OS는 메모리에 존재하는 마운트 테이블에 파일 시스템이 마운트되었다는 사실과 파일 시스템의 타입을 기록한다. 이 기능의 세부 사항은 OS에 의해 결정된다. Windows 기반 시스템은 각각의 파티션을 문자와 콜론으로 표기되는 독립적인 지명 공간에 마운트한다. 예를 들어, 파일 시스템이 F:에 마운트된 것을 기록하기 위해 OS는 F:에 대응하는 디바이스 구조의 한 필드에 파일 시스템을 가리키는 포인터를 기록한다. 프로세스가 드라이브 문자를 지정하면, OS는 적절한 파일 시스템 포인터를 찾고, 지정된 파일이나 디렉터리를 찾기 위해 그 디바이스 상의 디렉터리 구조를 탐색한다.
- UNIX에서 파일 시스템은 어떤 디렉터리에도 마운트될 수 있다. 마운팅은 디렉터리 inode의 메모리 복사본의 플래그를 설정함으로써 구현된다. 플래그는 디렉터리가 마운트 포인트임을 가리킨다. 이 경우 한 필드가 마운트 테이블의 한 항목을 가리켜 어느 디바이스가 그곳에 마운트되었는가를 알려준다. 마운트 테이블 항목은 그 디바이스 상의 파일 시스템의 수퍼 블록을 가리키는 포인터를 포함한다. 이 기법은 OS가 디렉터리 구조를 순회할 때, 흔적 없이 다양한 유형의 파일 시스템을 교차할 수 있게 한다.

### 가상 파일 시스템
- 여러 타임의 파일 시스템을 구현하는 명확하고 차선의 방법은 각 타입별로 디렉터리와 파일 루틴을 작성하는 것이다. 그러나 이러한 구현 대신 UNIX를 포함하여 대부분의 OS는 구현을 단순화하고, 조직화하고, 모듈화하기 위해 객체지향 방법을 사용한다. 이러한 방법을 사용함으로써 NFS와 같은 네트워크 파일 시스템을 포함하여 크게 다른 파일 시스템 타입이 같은 구조안에 구현되는 것을 허용한다. 사용자는 로컬 디스크의 여러 파일 시스템이나, 심지어 네트워크를 통해 이용 가능한 파일 시스템에 포함된 파일에 접근할 수도 있다.
- 세부적인 구현 사항으로부터 기본 시스템 호출 기능을 격리시키기 위해 자료구조와 프로시저가 사용된다. 그러므로 파일 시스템의 구현은 3가지 주요 계층으로 구성된다.
- 첫 번째 계층은 열기, 읽기, 쓰기, 닫기 호출과 파일 디스크립터에 기반을 둔 파일 시스템 인터페이스이다.
- 두 번째 계층은 가상 파일 시스템(VFS) 계층이다. 이 층은 두 가지 중요한 기능을 제공한다. 첫째, NFS는 VFS 인터페이스를 명확하게 정의함으로써 파일 시스템의 일반적 연산을 구현과 분리시킨다. VFS 인터페이스에 대한 많은 구현들이 같은 기계상에 공존할 수 있으므로, 다른 형태의 파일 시스템을 지역적으로 마운트함으로써 투명한 접근을 가능케 한다. 두번째, VFS는 파일을 네트워크 전체에서 고유하게 표현할 수 있는 기법을 제공한다. VFS는 vnode라 불리는 파일 표현 구조에 기반을 둔다. vnode는 네트워크 전체에서 유일한 파일에 대한 수치 지정자를 포함하고 있다(UNIX inode는 한 파일 시스템 내에서만 유일하다). 네트워크 파일 시스템을 지원하려면 범 시스템 상에서 유일해야 한다. 커널은 각 활성 노드(파일/ 디렉터리)에 대해 하나의 vnode 구조를 가진다.
- 그러므로 VFS는 원격 파일과 로컬 파일을 구분하고, 로컬 파일들은 파일 시스템 타입에 따라 더 세부적으로 구분된다.
- VFS는 특정 파일 시스템의 연산을 구동시킴으로써 파일 시스템 타입에 따라 로컬 요청들을 처리하며, 원격 요청에 대해서는 NFS 프로토콜 프로시저를 호출한다. 파일 핸들은 관련된 vnode들로부터 구성되며, 이들 프로시저에 인자로 전달된다. 파일 시스템 타입이나 원격 파일 시스템 프로토콜을 구현하는 계층은 그 구조의 최하부층이다.
- LINUX의 VFS구조에서 4가지 기본 객체 타입은 inode(각 파일을 나타냄), file 객체(오픈 파일을 나타냄), superblock 객체(전체 파일 시스템을 나타냄), dentry 객체(각 디렉터리 항목을 나타냄)이다.
- 네 가지 객체 타입 각각에 대하여 VFS는 반드시 구현되어야 할 연산의 집합을 정의한다. 각 유형의 모든 객체는 함수 테이블을 가리키는 포인터를 가진다. 함수 테이블은 각 객체의 정의 연산을 구현한 실제 함수의 주소를 나열한다. 예를 들면, 파일 객체를 위한 연산의 처리 함수로 open(), read(), write(), mmap()들이 포함된다. 특정 파일 유형을 위한 file 객체를 구현할 때에는 file 객체의 정의에 명시된 각 함수를 반드시 구현해야 한다.
- 따라서 VFS 소프트웨어 층은 현재 다루고 있는 객체의 종류가 정확히 무엇인지 미리 알 필요 없이 그 객체의 함수 테이블에서 적절한 함수를 호출하여 이러한 객체를 대상으로 연산을 실행할 수 있다. VFS는 inode가 디스크-파일, 디렉터리 파일 또는 원격 파일을 알지 못하거나 신경 쓰지 않는다. 그 파일의 read() 연산에 해당하는 적절한 함수가 언제나 함수 테이블의 동일한 위치에 있을 것이고, VFS 소프트웨어 층은 실제 데이터가 읽히는 방식에는 신경 쓰지 않고 그 함수만 호출하면 된다.

## 디렉터리 구현

### 선형 리스트
- 디렉터리를 구현하는 가장 간단한 방법은 파일 이름과 데이터 블록을 가리키는 포인터들의 선형 리스트를 사용하는 것이다. 이 방법은 프로그램이 쉽지만 실행시간이 길다.
- 새로운 파일을 생성하기 위해서는 먼저 디렉터리를 탐색하여 같은 이름을 가진 파일이 존재하지 않는다는 것을 확인한 후, 디렉터리의 끝부분에 새로운 항목을 첨가하면 된다. 한 파일을 삭제하려면 디렉터리에서 이름을 찾아 그 파일에 할당된 공간을 방출한다. 
- 그 디렉터리 항목을 다시 사용하려면 몇 가지 방법이 있다. 해당 항목을 미사용으로 표시하거나 디렉터리 항목의 가용 리스트에 연결할 수 있다. 표시하는 방법에는 전부가 공백인 이름과 같은 특수한 이름을 부여하거나 각 항목의 사용-미사용 비트 표시가 가능하다. 세 번째 대안은 디렉터리의 제일 마지막 항목을 삭제 때문에 빈 공간이 된 항목에 복사해서 디렉터리의 길이를 하나 줄이는 방법이다. 또한, 파일 삭제 시간을 줄이기 위해 연결 리스트를 사용할 수 있다.
- 선형 리스트로 구성된 디렉터리의 가장 큰 단점은 파일을 찾기 위해 선형 탐색을 해야 한다는 점이다. 디렉터리의 정보는 빈번하게 사용되고, 속도가 느리면 사용자는 이를 바로 느낄 것이다. 실제 많은 OS는 가장 최근에 사용된 디렉터리 정보를 저장하기 위해 소프트웨어 캐시를 구현하고 있다. 캐시에서 적중되면 그 정보를 매번 디스크로부터 읽어오는 것을 피할 수 있다. 정렬된 리스트는 이진 탐색을 가능케 하며 평균 탐색시간을 줄인다. 그렇지만, 리스트가 정렬 상태를 유지하려면 파일을 생성하거나 삭제하는 일이 복잡해질 수 있다. 왜냐하면, 정렬을 유지하기 위해 상당한 정보를 이동해야 할 수도 있기 때문이다. 보다 정교한 트리 자료구조, 예를 들면 B-트리가 도움이 될 수 있다. 정렬된 리스트의 장점은 별도의 정렬 작업 없이 정렬된 디렉터리 목록을 만들 수 있다.

### 해시 테이블
- 이 방법에서는 선형 리스트에 디렉터리 항목들이 저장되기는 하지만 해싱도 함께 사용한다. 해시 테이블은 파일 이름으로부터 계산된 값을 받아서 선형 리스트의 파일 이름을 가리키는 포인터를 반환한다. 그러므로 디렉터리 탐색시간을 상당히 개선할 수 있다. `충돌`(둘 이상의 파일명이 같은 위치를 지정하는 경우)에 대한 대비가 필요하지만, 삽입과 삭제가 쉽다.
- 해시 테이블의 문제점은 일반적으로 해시 테이블이 고정된 크기를 가진다는 점과 해시 테이블의 크기에 따라 해시 함수도 제한을 받는다는 점이다. 만약 해시 테이블보다 많은 파일을 만든다면, 해시 테이블을 키워야 한다. 또한, 기존 디렉터리 항목을 새로운 해시 값에 맞게 새로 조직해야 한다.
- 대안으로 체인 오버플로우 해시 테이블을 사용할 수 있다. 각 해시 항목은 하나의 값이 아니라 연결 리스트가 되고, 새로운 항목을 연결 리스트에 추가함으로써 충돌을 해결한다. 이제 이름을 찾으려면 충돌하는 테이블 항들의 연결 리스트를 살펴보아야 하기 때문에 찾기 작업은 늦어지지만, 이러한 연산은 전체 디렉터리를 선형으로 찾는 것보다 훨씬 빠르다.
