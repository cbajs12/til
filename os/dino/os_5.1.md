# CPU 스케줄링
- 스레드를 지원하는 OS에서는 실질적으로 OS는 프로세스가 아니라 커널 수준 스레드를 스케줄한다. 그러나 프로세스 스케줄링과 스레드 스케줄링 용어는 상호 교환적으로 사용된다.
- 다중 프로그래밍의 목적은 CPU 이용률을 최대화하기 위해 항상 실행 중인 프로세스를 가지게 하는 데 있다.
- 어떤 프로세스가 대기해야 할 경우, OS는 CPU를 그 프로세스로부터 회수해 다른 프로세스에 할당한다.

### CPU-I/O 버스트 사이클
- 프로세스 실행은 CPU 실행과 입출력 대기의 사이클로 구성된다. 프로세스들은 이들 두 상태 사이를 교대로 왔다 갔다 한다.
- 프로세스 실행은 CPU 버스트로 시작된다. 뒤이어 입출력 버스트가 발생하고 다시 다른 CPU 버스트가 발생하는 식으로 진행된다. 결국 마지막 CPU 버스트는 실행을 종료하기 위한 시스템 요청과 함께 끝난다.
- CPU 버스트(사용)때는 load store, add store, 파일로부터 read등의 작업을 한다.
- I/O 버스트(사용)때는 입출력을 기다리는 작업을 한다.
- 입출력 중심의 프로그램은 전형적으로 짧은 CPU 버스트를 많이 가질것이고 CPU 중심 프로그램은 다수의 긴 CPU 버스트를 가질 수 있다.

### CPU 스케줄러
- CPU가 유휴 상태가 될 때마다 OS는 준비완료 큐에 있는 프로세서들 중에서 실행될 프로세스를 선택해야 한다.
- 선택 절차는 단기(CPU) 스케줄러에 의해 실행된다. 이 스케줄러는 실행 준비가 되어 있는 메모리 내의 프로세스들 중에서 선택하여 이들 중 하나에게 CPU를 할당한다.
- 준비완료 큐는 반드시 FIFO방식의 큐가 아니어도 된다. 준비완료 큐는 선입 선출 큐, 우선순위 큐, 트리 또는 단순히 순서가 없는 연결 리스트로 구현할 수 있다.
- 큐에 있는 레코드들은 일반적으로 프로세스들의 PCB들이다.

### 선점 스케줄링
- CPU 스케줄링은 4가지 상황에서 발생할 수 있다. 
- 1) 한 프로세스가 실행 상태에서 대기 상태로 전환될 때(입출력 요청이나, wait를 호출할 때)
- 2) 프로세스가 실행 상태에서 준비완료 상태로 전환될 때( 인터럽트가 발생할 때)
- 3) 프로세스가 대기 상태에서 준비완료 상태로 전환할 때(입출력 종료시)
- 4) 프로세스가 종료될때
- 상황 1과 4에서만 스케줄링이 발생할 경우, `비선점 스케줄링`이라고 한다. 다른 상황에서는 `선점스케줄링`이라고 한다.
- 비선점 스케줄링에서는 일단 CPU가 한 프로세스에 할당되면, 프로세스가 종료하든지 대기 상태로 전환해  CPU를 방출할 때까지 CPU를 점유한다.
- 선점 스케줄링은 공유 자료를 접근하는 경우 비용을 유발한다. 또한 OS 커널 설계에 영향을 준다. 시스템 호출을 처리하는 동안 커널은 중요한 자료 변경을 하는 중일 수도 있는데 이러한 경우에 선점이 될경우 문제가 발생할 수 있다. 대부분의 OS는 문맥 교환을 실행하기 전에 시스템 호출의 완료 혹은 I/O 봉쇄를 기다리므로써 문제를 해결한다. 그러나 이 방법은 실시간 컴퓨팅과 다중처리를 지원하기에는 좋지 않다. 
- 선점은 동기화가 필요하며 timer(하드웨어)가 필요하다.
- 인터럽트는 어느때나 일어날 수 있고 커널에 의해서 항상 무시될 수는 없기 때문에 인터럽트에 의해서 영향을 받는 코드는 반드시 동시 사용으로 부터 보호되어야 한다. 따라서 이러한 코드 부분은 다수 프로세스가 병형으로 접근 할 수 없도록 그 진입점에서 인터럽트를 불능화하고, 출구에서 인터럽트를 다시 가능화 한다.

### 디스패처
- 디스패처는 CPU의 제어를 CPU 스케줄러가 선택한 프로세스에게 주는 모듈이다.
- 하는 일은 문맥을 교환하는 일, 사용자 모드로 전환하는 일 그리고 프로그램을 다시 시작하기 위해 사용자 프로그램의 적절한 위치로 이동하는 일이 있다.
- 다스패처는 모든 프로세스의 문맥 교환시 호출되므로, 가능한 한 빨라야 한다.
- 디스패처가 하나의 프로세스를 중단시키고 다른 프로세스를 실행시키는 데까지 소요되는 시간을 디스패치 지연이라고 한다.

## 스케줄링 기준
- CPU 스케줄링 알고리즘을 비교할 때 어느 특성을 사용하느냐에 따라서 최선의 알고리즘을 결정하는 데 큰 차이가 발생한다.
- CPU 이용률: 가능한 CPU를 최대한 바쁘게 유지하기를 원한다. 대부분 40 ~ 90%를 유지한다.
- 처리량: 작업량 측정의 한 방법은 단위 시간당 완료된 프로세스의 개수이다. 
- 총처리 시간: 프로세스의 제출 시간과 완료 시간의 간격을 총처리 시간이라고 한다. 이것은 메모리에 적재되기 위해 기다리며 소비한 시간, 준비완료 큐에서 대기한 시간, CPU에서 실행하는 시간, 그리고 입출력 시간을 합한 시간이다.
- 대기 시간: 준비완료 큐에서 대기하는 시간의 양에만 영향을 준다.
- 응답 시간: 응답이 시작되는 데까지 걸리는 시간
- CPU 이용률과 처리량을 최대화하고 총 처리 기간, 대기 시간, 응답 시간을 최소화하는 것이 바람직하다.

## 스케줄링 알고리즘

### 선입 선처리(FCFS) 스케줄링
- CPU를 먼저 요청하는 프로세스가 CPU를 먼저 할당받는다. 이 방법의 구현은 FIFO 큐로 쉽게 할 수 있다. 프로세스가 준비완료 큐에 진입하면, 이 프로세스의 PCB를 큐의 끝에 연결한다.
- 부정적인 측면으로 FIFO 정책하에서 평균 대기 시간은 대단히 길 수 있다. 
- 모든 다른 프로세스들이 하나의 긴 프로세스가 CPU를 양도하기를 기다리는 것을 `호위 효과`라고 한다. 이효과는 짧은 프로세스들이 먼저 처리되도록 허용될 때보다 CPU와 장치 이용률이 저화되는 결과를 낳는다.
- FIFO 알고리즘은 비선점형이다.
- FIFO 알고리즘은 시분할 시스템에 문제가 되는데, 그 이유는 시분할 시스템에서는 각 사용자가 규칙적인 간격으로 CPU의 몫을 얻는 것이 매우 중요하기 때문이다.

### 최단 작업 우선(SJF) 스케줄링
- 각 프로세스에 다음 CPU 버스트 길이를 연관시킨다. CPU가 이용가능해 지면, 다음 CPU 버스트가 가장 작은 프로세스에게 할당한다. 두 프로세스의 다음 CPU 버스트가 같다면, 순위를 정하기 위해 FIFO을 적용한다.
- SJF 알고리즘은 주어진 프로세스 집합에 대해 최소의 평균 대기시간을 가진다는 점에서 최적이다.
- SJF 알고리즘의 어려움은 다음 CPU 요청의 길이를 파악하는 것이다.
- 장기 스케줄의 경우 사용자가 작업을 제출할 때 명시한 프로세스 시간제한 길이를 이용할 수 있다. 그러므로 SJF 스케줄링은 장기 스케줄링에서 자주 사용된다. 
- 단기 CPU 스케줄링 수준에서는 구현할 수 없다. 단기 스케줄에서 할 수 있는 한가지 방식은 SJF 스케줄링과 가깝게 스케줄링 하는 것이다. 다음 CPU 버스트의 길이를 알수 없으나, 그 값을 예측하는 것이다. 다음 CPU 버스트가 이전의 버스트와 길이가 비슷하다고 기대한다. 다음 CPU 버스트는 일반적으로 이전의 CPU 버스트들의 측정된 길이를 지수 평균한 것으로 예측한다.
- SJF 알고리즘은 선점 또는 비선점형일 수 있다. 이전 프로세스가 실행되는 동안 새로운 프로세스가 준비완료 큐에 도착하면 선택 상황이 발생한다. 선점형 SJF는 현재 실행하는 프로세스를 선점할 것이고, 비선점형 SJF는 현재 실행하고 있는 프로세스가 자신의 CPU 버스트를 끝내도록 허용한다.
- 선점형 SJF는 때때로 최소 잔여시간 우선 스케줄링이라고 불린다.

### 우선순위 스케줄링
- 우선순위가 각 프로세스들에게 연관되어 있으며, CPU는 가장 높은 우선순위를 가진 프로세스에게 할당된다.
- 우선순위가 같은 프로세스들은 선인 선처리 순서로 스케줄된다.
- 우선순위는 내부적 또는 외부적으로 정의될 수 있다. 
- 내부적으로 정의된 우선순위는 프로세스의 우선순위를 계산하기 위해 시간 제한, 메모리 요구, 열린 파일의 수, 평균 입출력 버스트의 평균 CPU 버스트에 대한 비율 등이 우선순위의 계산에 사용된다.
- 외부적 우선순위는 프로세스의 중요성, 컴퓨터 사용을 위해 지불되는 비용의 타입과 양, 그 작업을 후원하는 부서 그리고 OS 외부적 기준에 의해 결정된다.
- 우선순위 스케줄링은 선점형이거나 비선점형일수 있다.
- 프로세스가 준비완료 큐에 도착하면, 새로 도착한 프로세스의 우선순위를 현재 실행 중인 프로세스의 우선순위와 비교한다. 선점형 우선순위 스케줄링은 새로 도착한 프로세스의 우선순위가 현재 실행되는 프로세의 우선순위보다 높다면 CPU를 선점한다. 비선점형 우선순위 스케줄링은 단순히 준비완료 큐의 헤드에 새로운 프로세스를 넣는다.
- 우선순위 스케줄링의 주요 문제는 기아 상태이다. 실행 준비는 되어 있으나 CPU를 사용하지 못하는 프로세스는 CPU를 기다리면서 봉쇄된 것으로 간주될 수 있다. 낮은 우선순위 프로세스들이 CPU를 무기한 대기하는 경우가 발생한다.
- 낮은 우선순위 프로세스들의 무기한 봉쇄하는 문제의 한가지 해결 방안은 노화이다. 노화는 오랜 시간 시스템에서 대기하는 프로세스들의 우선순위를 점진적으로 증가시키는 기법이다. 노화된 프로세스들은 우선순위가 증가한다.

### 라운드 로빈(RR) 스케줄링
- 이 알고리즘은 시분할 시스템을 위해 설계되었다.
- FIFO 알고리즘과 유사하지만 시스템이 프로세스들 사이를 옮겨 다닐 수 있도록 선점이 추가된다.
- 시간 슬라이스라는 작은 단위의 시간을 정의한다. 또한, 준비완료 큐는 원형 큐로 동작한다. CPU 스케줄러는 준비완료 큐를 돌면서 한 번에 한 프로세스에게 한 번의 시간 슬라이스 동안 CPU를 할당한다.
- RR을 구현하기 위해 준비완료 큐를 프로세스들의 FIFO큐로 유지한다. 새로운 프로세스들은 준비완료 큐의 꼬리에 추가된다. CPU 스케줄러는 준비완료 큐에서 첫 번째 프로세스를 선택해 한번 의 시간 슬라이스 이후에 인터럽트를 걸도록 타이머를 설정한 후, 프로세스를 디스패치한다.
- 이러한 경우 두 가지 경우 중 하나가 발생한다. 첫 번째는 프로세스의 CPU 버스트가 한 번의 시간 슬라이스보다 작을 수 있다. 이 경우에는 프로세스 자신이 CPU를 자발적으로 방출할 것이다. 스케줄러는 그 후 준비완료 큐에 있는 다음 프로세스로 진행할 것이다. 두 번째는 현재 실행 중인 프로세스의 CPU 버스트가 한 번의 시간 슬라이스보다 긴 경우로, 타이머가 만료되면 OS에 인터럽트를 건다. 문맥 교환이 일어나고 실행하던 프로세스는 준비완료 큐의 꼬리에 넣어진다.
- RR알고리즘은 선점형이다.
- RR알고리즘의 성능은 시간 슬라이스의 크기에 매우 많은 영향을 받는다. 또한 소프트웨어 측면에서 문맥 교환이 RR 스케줄링의 성능에 미치는 영향을 고려해야 한다. 그러므로 문맥 교환 시간을 고려하면 시간 슬라이스는 길게 주어져야 한다. 그리고 총처리 시간 또한 시간 슬라이스의 크기에 좌우된다. 한 프로세스 집합의 평균 총처리 시간은 시간 슬라이스의 크기가 증가하더라도 반드시 개선되지는 않는다. 작은 시간 슬라이스에 대해서는 더 많은 문맥 교환이 요구되기 때문에 평균 총처리 시간이 증가한다.
- 시간 슬라이스가 너무 커지면 FCFS과 같은 방식이 되어 버린다.
- CPU 버스트의 80%는 시간 슬라이스보다 짧아야 한다.

### 다단계 큐 스케줄링
- 준비완료 큐를 다수의 별도의 큐로 분류한다. 메모리 크기, 프로세스의 우선순위 혹은 프로세스 유형과 같은 프로세스의 특성에 따라 한 개의 큐에 영구적으로 할당된다. 각 큐는 자신의 스케줄링 알고리즘을 갖고 있다.
- 큐와 큐 사이에 스케줄링도 반드시 있어야 하며, 일반적으로 고정 우선순위의 선점형 스케줄링으로 구현된다. 각 큐는 낮은 우선순위의 큐보다 절대적인 우선순위를 가진다. 낮은 우선순위의 큐의 프로세스가 실행중에 높은 우선순위의 큐의 프로세스가 들어오면 선점된다.
- 다른 방식은 큐들 사이에 시간을 나누어 사용하는 것이다. 각 큐는 CPU 시간의 일정량을 받아서 자기 큐에 잇는 다양한 프로세스들을 스케줄 할 수 있다.
- 일반적으로 프로세스들이 시스템 진입 시에 영구적으로 하나의 큐에 할당된다. 이러한 방식은 스케줄링 오버헤드가 적은 장점이 있으나 융통성이 적다.

### 다단계 피드백 큐 스케줄링
- 프로세스가 큐 사이를 이동하는 것을 허용한다. 
- 어떤 프로세스가 CPU 시간을 너무 많이 사용하면, 낮은 우선순위의 큐로 이동된다. 또한 낮은 우선순위의 큐에서 너무 오래 대기하는 프로세스는 높은 우선순위의 큐로 이동할 수 있다.
- 다단계 피드백 큐 스케줄러는 큐의 개수, 각 큐를 위한 스케줄링 알고리즘, 한 프로세스를 높은 우선순위 큐로 올려주는 시기를 결정하는 방법, 한 프로세스를 낮은 우선순위 큐로 강등시키는 시기를 결정하는 방법, 프로세스가 서비스를 필요로 할 때 프로세스가 들어갈 큐를 결정하는 방법에 의해 정의된다.

## 스레드 스케줄링
- 사용자와 커널 스레드를 지원하는 OS에서는 스케줄되는 대상은 커널 스레드이다.
- 사용자 스레드는 커널 수준 스레드에 맵핑되어야 한다.

### 경쟁 범위
- 사용자와 커널 스레드의 차이 중 하나는 스케줄 되는 방식에 있다.
- 다대일, 다대다 모델을 구현하는 시스템에서는 스레드 라이브러리는 사용자 스레드를 가용한 LWP 상에서 스케줄한다. 이 구조는 동일한 프로세스에 속한 스레드들 사이에서 CPU를 경쟁하기 때문에 `프로세스 경쟁 범위(PCS)`라 한다.
- 스레드 라이브러리가 사용자 스레드를 가용한 LWP 상에서 스케줄한다고 말하는 경우, 스레드가 실제로 CPU상에서 실행중이라는 것을 의미하지 않는다. 실제로 CPU 상에서 실행되기 위해서는 OS가 커널 스레드를 물리적인 CPU로 스케줄하는 것을 필요로 한다. CPU 상에 어느 커널 스레드를 스케줄할 것인지 결정하기 위해서 커널은 `시스템 경쟁 범위(SCS)`를 사용한다. SCS 스케줄링에서의 CPU에 대한 경쟁은 시스템 상의 모든 스레드 사이에서 일어난다.
- 일대일 모델을 사용하는 시스템은 SCS만을 사용하여 스케줄한다.
- PCS는 우선순위에 따라 행해진다. 즉 스케줄러는 가장 높은 우선순위를 가진 실행 가능한 프로세스를 선택한다. 사용자 스레드의 우선순위는 프로그래머에 의해 지정되고 스레드 라이브러리에 의해 조정되지 않는다. 그러나 몇몇 스레드 라이브러리는 프로그래머가 스레드의 우선순위를 변경하는 것을 허용한다.
- PCS는 통상 더 높은 우선순위의 스레드를 위하여 현재 실행 중인 스레드를 선점한다는 것을 주의해야 한다.
