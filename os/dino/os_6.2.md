# 프로세스 동기화

## 세마포어
- 세마포어 S는 정수 변수로서 초기화를 제외하고는 단지 두 개의 표준 원자적 연산 wait()와 signal()로만 접근이 가능하다.

```cpp
wait(S){
   while(S<=0)
      ; // do nothing
   S--;
}

signal(S){
   S++;
}
```

- 한 스레드가 세마포어 값을 변경하면, 다른 어떤 스레드도 동시에 동일한 세마포어 값을 변경할 수 없다.
- wait(S)는 S의 정수 값을 검사하는 작업(S<=0)과 그에 따라 실행될 수 있는 변경(S--)하는 작업은 인터럽트 되지 않고 실행되어야 한다.

### 사용법
- OS는 카운팅과 이진 세마포어를 구분한다. 
- 카운트 세마포어의 값은 제한 없는 영역을 가진다. 유한한 개수를 가진 자원에 대한 접근을 제어하는 데 사용된다. 세마포어는 가용한 자원의 개수로 초기화된다.
- 이진 세마포어의 값은 0과 1 사이의 값만 가능하다. 어떤 이진 세마포어가 상호 배제를 제공하는 락이기 때문에  `mutex 락`이라고 한다. 다중 프로세스들 사이의 임계 영역을 다루기 위하여 이진 세마포어를 사용한다. n개의 프로세스들은 mutex라는 세마포어를 공유하고 초기값은 1이다.

```cpp
do{
   wait(mutex);
      //critical section
   signal(mutex);
      // remainder section
}while(TRUE);
```

- 각 자원을 사용하려는 프로세스는 세마포어에 wait() 연산을 실행하며, 세마포어 값은 감소된다. 프로세스가 자원을 방출할 때는 signal() 연산을 실행하고 세마포어는 증가하게 된다. 세마포어의 값이 0이 되면 모든 자원이 사용 중임을 나타낸다. 자원을 사용하려는 프로세스는 세마포어 값이 0보다 커질 때까지 봉쇄된다.

```cpp
//P1 code
S1;   
signal(synch);

//P2 code
wait(synch);   
S2;
```
- P1은 S1 명령문을, P2는 S2 명령문을 병행하게 실행하는 두 프로세스를 고려할때, P1, P2가 세마포어 synch를 공유하도록 하고, synch는 0으로 초기화 한후, P1에 P1code를 넣고, P2에 P2code를 넣어두면 synch 값은 0으로 초기화 되어 있으므로 P2가 S2를 실행하는 것은 P1이 signal(synch)를 호출한 후에만 가능하다. 그리고 이 호출은 S1을 실행한 이후에만 가능하다.

### 구현
- 세마포어의 주된 단점은 모두 `바쁜 대기`를 요구한다는 점이다. 한 프로세스가 자신의 임계 영역에 있으면, 자신의 임계 영역에 진입하려는 프로세스는 진입 코드를 계속 반복 실행해야 한다. 이러한 반복은 하나의 CPU가 여러 프로세스들에 의해 공유되는 다중 프로그래밍 시스템에 CPU 시간을 낭비하는 문제를 만든다.
- 프로세스가 락을 기다리는 동안 회전하기 때문에 이런 타입의 세마포어를 `spinlock`이라고 부르기도 한다.
- spinlock은 프로세스가 락을 기다려야 하고 문맥 교환이 상당한 시간이 걸릴경우에 문맥 교환이 필요하지 않는다는 점에서 유용하다. 즉, 락이 짧은 시간 동안만 소유될 것이 예상될경우 유용하다. 
- 바쁜 대기를 극복하기 위해 wait()와 signal() 세마포 연산의 정의를 변경할 수 있다. 프로세스가 wait() 연산을 실행하고 세마포어 값이 양수가 아닌 것을 발견하면, 프로세스는 반드시 대기해야 한다. 그러나 바쁜 대기 대신에 프로세스는 자신을 봉쇄시킬수 있다. 봉쇄 연산은 프로세스를 세마포어에 연관된 대기 큐에 넣고, 프로세스의 상태를 대기 상태로 전환한다. 그리고 나서 제어가 CPU 스케줄러로 넘어가고, 스케줄러는 다른 프로세스를 선택하여 실행시킨다.
- 세마포어 S를 대기하면서 봉쇄된 프로세스는 다른 프로세스가 signal() 연산을 실행하면 재시작되어야 한다. 프로세스는 wakeup() 연산에 의하여 재시작되는데 이것은 프로세스의 상태를 대기상태에서 준비완료 상태로 변경한다. 그리고 프로세스는 준비완료 큐에 넣어진다.

```cpp
typedef struct{
   int value;
   struct process *list;
}semaphore;
```

- 각 세마포어는 한 개의 정수 value와 프로세스 리스트를 가진다. 프로세스가 세마포어를 기다려야 한다면, 이 프로세스를 세마포어의 프로세스 리스트에 추가한다. signal() 연산은 프로세스 리스트에서 한 프로세스를 꺼내서 그 프로세스를 깨워준다.

```cpp
void wait(semaphore *S){
   S->value--;
   if(S->value < 0){
      이 프로세스를 S->list에 넣는다;
      block();
   }
}

void signal(semaphore *S){
   S->value++;
   if(s->value <= 0){
      S->list로부터 프로세스(P) 하나를 꺼낸다;
      wakeup(P);
   }
}
```

- block() 연산은 자기를 호출한 프로세스를 보류시킨다. wakeup(P) 연산은 봉쇄된 프로세스 P의 실행을 재개시킨다.
- 바쁜 대기를 하는 세마포어의 고전적 정의에서 세마포의 값은 음수를 가질수 없으나, 변경된 구현에서는 가질수 있다. 세마포어의 값이 음수일때 그 절대 값은 세마포어를 대기하고 있는 프로세스들의 수이다.
- 대기하는 프로세스들의 리스트는 각 PCB에 있는 연결 필드에 의해 쉽게 구현될 수 있다. 각 세마포어는 정수 값과 PCB의 리스트에 대한 포인터를 가지고 있다. 한정된 대기를 보장하도록 리스트에 프로세스를 추가하고 삭제하는 한 가지 방법은 FIFO 큐를 사용하는 것으로 세마포어가 큐의 머리와 꼬리에 대한 포인터를 모두 갖게 된다. 그러나 일반적으로 리스트는 임의의 큐잉 전략을 사용할 수 있다.
- 세마포어가 원자적으로 실행되어야 한다는 것은 중요하다. 같은 세마포어에 대해 두 프로세스가 동시에 wait()와 signal() 연산들을 실행할 수 없도록 반드시 보장해야 한다. 단일처리기 환경에서는 단순히 wait(), signal() 연산들이 실행되는 동안 인터럽트를 금지시킴으로써 해결할 수있다. 다중처리기 환경에서는 모든 인터럽트를 금지시키는 것은 할수 없기때문에 SMP 시스템은 원자적 실행을 보장하기 위하여 spinlocks와 같은 다른 락킹 기법을 제공해야한다.
- 바쁜대기에 대한 완전하게 제거하지 못하고 진입 영역에서 애플리케이션 영역의 임계 영역으로 이동시켰다.

### 교착상태와 기아
- 세마포어가 대기 큐를 가지고 있는 경우, 둘 이상의 프로세스가 어떤 사건을 무한정 기다리고 있고, 이 사건은 오직 한 프로세스만 실행 시킬수 있다. 특히 사건이란 signal() 연산의 실행을 의미할수 있다. 이런 상태를 `교착상태(dead lock)`라 한다.
- 두개의 프로세스 a, b가 1로 지정된 세마포어 s와 q에 접근한다고 할때, a가 wait(s) b가 wait(q)를 실행한다고 가정하자. a이 wait(q)를 실행할 때 a는 b가 signal(q)를 실행할 때까지 기다려야 한다. b가 wait(s)를 실행할 때는 b는 a가 signal(s)를 실행할 때까지 기다려야 한다. 이들 signal() 연산들은 실행될 수 없기 때문에 a와 b는 교착상태가 된다. 즉, 한 집합 내의 모든 프로세스들이 그 집합 내의 다른 프로세스만이 유발할 수 있는 사건을 기다릴때, 이 프로세스들의 집합이 교착상태에 있다고 한다.
- 프로세스들이 세마포어에서 무기한 대기하는 것을 `기아 상태`라고 한다. 기아 상태는 세마포어와 연관된 큐에서 프로세스들을 LIFO순서로 제거할 경우 발생할 수 있다.

### 우선순위 역전
- 높은 우선순위 프로세스가 현재 낮은 우선순위 프로세스 또는 연속된 낮은 우선순위 프로세스들에 의해 접근되고 있는 커널 데이터를 읽거나 변경할 필요가 있을 때 스케줄링에 어려움이 생긴다. 커널 데이터는 통상 락에 의해 보호된다.
- 낮은 우선순위 프로세스가 자원을 사용을 마칠 때까지 높은 우선순위 프로세스는 기다려야 한다. 낮은 우선 순위 프로세스가 또 다른 높은 우선순위 프로세스에 의해 선점되는 경우 상황은 더 복잡해진다. 이러한 문제를 `우선순위 역전`이라 한다.
- 통상 시스템들은 우선순위 상속 프로토콜을 구현함으로써 해결한다. 이 프로토콜은 더 높은 우선순위 프로세스가 필요로 하는 자원을 접근하는 모든 프로세스들은 문제가 된 자원의 사용이 끝날 때까지 더 높은 우선순위를 상속받는다. 자원 사용이 끝나며 원래 우선순위로 되돌아간다.

## 고전적인 동기화 문제들
- 동기화 문제들에 대한 세마포어 해결법

### 유한 버퍼(생산자, 소비자) 문제
- n개의 버퍼들로 구성된 풀이 있으며, 각 버퍼들은 한 항목을 저장할 수 있다고 가정한다. mutext 세마포어는 버퍼 풀을 접근하기 위한 상호 배제 기능을 제공하며 1로 초기화된다. empty와 full 세마포어들은 각각 비어 있는 버퍼의 수와 꽉 찬 버퍼의 수를 기록한다. 세마포어 empty는 n값으로 초기화 되고, full은 0으로 초기화된다. 

### readers-writers 문제
- 하나의 DB가 다수의 병행 프로세스들 간에 공유된다고 가정
- 프로세스들 중의 일부는 DB 내용을 읽기(read)만 하고, 어떤 프로세스들은 DB를 쓰기(write)만 원할 수 있다. 두 reader가 동시에 공유 데이터를 접근하더라도 불행한 결과가 발생하지 않는다. 그러나 하나의 writer와 어떤 다른 스레드(write or reader)가 동시에 DB에 접근하면, 혼란이 올수 있다. 이러한 문제를 해결하기 위해 writer가 쓰기 작업을 하는 동안 공유 DB에 대해 배타적 접근 권한을 갖게 할 필요가 있다. 이것은 `readers-writers 문제`라 한다.
- 단순히 writer가 공유 객체 사용 허가를 기다리고 있기 때문에 다른 reader들이 끝날 때까지 기다리는 reader가 있어서는 안된다. 그러나 writer가 기아상태가 될수 있다.
- writer가 객체를 접근하려고 기다리고 있다면, 새로운 reader들은 읽기를 시작하지 못한다. 그러나 reader가 기아상태가 될 수 있다.

```cpp
   semaphore mutex, wrt;
   int readcount;
```

- writer 기아상태를 방지 하기 위한 해결안은 reader 프로세스는 위의 자료구조를 공유한다.
- mutex와 wrt 세마포어는 1로 초기화되고, readcount는 0으로 초기화된다.
- wrt 세마포어는 reader와 writer가 모두 공유한다. mutext 세마포어는 readcount를 갱신할 때 상호 배제를 보장하기 위해 사용된다. readcount는 현재 몇개의 프로세스들이 객체를 읽고 있는지 알려준다. wrt 세마포어는 writer들을 위한 상호 배제 세마포어이다. 이것은 또한 임계 영역으로 진입하는 첫 번째 reader와 임계 영역을 빠져나오는 마지막 reader에 의해서도 사용된다. 그러나 다른 reader들이 임계 영역 안에 있는 동안 임계 영역을 드나드는 reader들은 이것을 사용하지 않는다.

```cpp
do{
   wait(wrt);
   // writing is performed
   signal(wrt);
}while(TRUE);

do{
   wait(mutex);
   readcount++;
   if(readcount == 1)
      wait(wrt);
   signal(mutext);
   // reading is performed
   wait(mutex);
   readcount--;
   if(readcount == 0)
      signal(wrt);
   signal(mutex);
}while(TRUE);
```

- writer가 임계 영역에 있고 n 개의 reader들이 기다리고 있으면 한개의 reader만이 wrt와 관련된 큐에 삽입되고, 나머지 n-1개의 reader들은 mutex와 관련된 큐에 삽입된다.
- writer가 signal(wrt)을 실행하면 대기 중인 여러 reader들 혹은 대기 중인 한 개의 writer의 실행이 재개된다. 어느 쪽을 실행할지는 스케줄러가 결정한다.
- 몇몇 시스템은 reader-writer락을 제공한다. 프로세스가 공유 데이터를 읽기만 원한다면 read락을 요청하고, 수정하고 싶다면 write락을 요청해야 한다. read락은 여러 프로세스들이 동시에 획득하는 것이 가능하다. writer락은 오직 하나의 프로세스만이 락을 획득할 수 있다.

### 식사하는 철학자들 문제
- 원형 테이블을 공유하며, 5명의 철학자가 식사를 한다. 테이블 중앙에는 한 사발의 밥이 있고, 테이블에는 5개의 젓가락(짝이 아닌)이 놓여 있다. 철학자가 생각할 때는 다른 동료들과 상호작용 하지 않는다. 철학자는 배가 고파질때 자신에게 가장 가까이 있는 두 개의 젓가락을 집으려고 한다. 철학자는 한번에 한개 혹은 두개의 젓가락을 잡을수 있다. 철학자는 두개를 잡을 경우 식사를 한다. 식사를 마치면 젓가락 모두 놓는다.
- 교착상태와 기아를 발생시키지 않고 여러 스레드에게 여러 자원을 할당해야 할 필요를 나타낸 문제이다.
- 하나의 해결책은 각 젓가락을 세마포어로 표현하는 것이다. 철학자는 세마포에 wait() 연산을 실행하여 젓가락을 집으려고 한다. 또한 식사를 마치면 signal() 연산으로 자신의 젓가락을 놓는다.
- 세마포어 원소들은 모두 1로 초기화된다.

```cpp
   semaphore chopstick[5];
   
   do{
      wait(chopstic[i]); //left
      wait(chopstic[(i+1) % 5]) //right
      // eat
      signal(chopstic[i]);
      signal(chopstic[(i+1) % 5])
      // think
   }while(TRUE)
```

- 이 해결안은 인접한 두 철학자가 동시에 식사하지 않는다는 것을 보장하지만, 교착상태를 야기할 가능성이 있다. 5명의 철학자가 모두 배가 고파 각각의 자신의 왼쪽 젓가락을 잡는다고 가정하면, 모든 젓가락은 0이 되어 각 철학자가 오른쪽 젓가락을 집으려고 하면 영원히 기다려야 한다.
- 교착상태 문제에 대한 해결책으로는 최대 4명의 철학자들만이 테이블에 동시에 앉을수 있도록 하는 것과 한 철학자가 젓가락 두 개를 모두 집을 수 있을 때만 집도록 허용하는 것과 비대칭으로 홀수 번호 철학자는 먼저 왼쪽 젓가락 집고 오른쪽 젓가락을 집고 짝수는 반대로 실행하는 방법들이다.
- 그러나 교착상태의 해결안이 기아의 가능성도 제거하는 것은 아니다.

## 모니터
- 세마포어는 타이밍 오류가 발생할 수 밖없다. 예로 모든 프로세스들은 mutex라는 세마포 변수를 공유하며, 그 초기값은 1이다. 각 프로세스는 임계영역에 진입하기 전에 wait(mutex)를 실행해야하며, 임계 영역을 나올 때 signal(mutex)를 실행해야한다. 만일 이 순서가 지켜지지 않으면 두 프로세스가 동시에 임계 영역 안에 있을 수 있다. 이러한 문제는 여러 프로세스들중 하나만 잘못 행동하더라도 발생하게 된다.
- 세마포어에 대한 wait()와 signal() 연산의 순서가 바뀌어 코드가 실행되거나(상호 배제 요구 조건 위반) signal()을 써야 할 곳에 wait()을 쓰거나(교착상태), 프로세스가 wait()과 signal() 모두 빠트리는(교착/상호배제 위반) 상황등처럼 프로그래머가 세마포어를 잘못 사용하는 상황에서 오류가 발생한다.
- 이러한 오류를 처리하기 위하여 `모니터`를 사용한다.

### 사용법
- 추상화된 데이터 형(ADT)은 private data와 public methods와 함께 캡슐화 하는데, 공개 메서드는 사적 데이터에 대한 연산을 한다. 모니터는 모니터 내부에서 상호 배제를 제공받는 프로그래머가 정의한 일련의 연산자 집합을 제공하는 ADT이다.
- 모니터는 변수들의 선언을 포함하고 있는데 이변수들의 값은 모니터 형에 해당하는 한 인스턴스의 상태를 정의한다. 그리고 이 변수들을 조작할 수 있는 함수들도 포함하고 있다. 즉, 모니터 내 정의된 함수로만 모니터 내 변수들을 접근할 수 있다.
- 모니터는 모니터 안에 항상 하나의 프로세스만이 활성화도록 보장해준다. 그러므로 프로그래머들은 동기화 제약 조건을 명시적으로 코딩할 필요가 없다.

```cpp
monitor monitor name{
   // shared variable declartions
   procedure a(...){
      ...
   }
   procedure b(...){
      ...
   }
      .
      .
      .
   procedure n(...){
      ...
   }
   initialization code(...){
      ...
   }
}
```

- 그러나 모니터는 동기화 책략을 모델링할 만큼 강력하지 않다. 동기화 책략을 모델링하기 위해서는 부가적인 동기화 기법을 정의해야 한다. 이러한 동기화 기법들은 condition이라는 것으로 제공될 수 있다.
- 프로그래머는 하나 이상의 condition 형의 변수를 정의할 수 있다. condition 형 변수에 호출될 수 있는 연산은 오직 wait()과 signal()이다. `condition.wait();` 연산을 호출한 프로세스는 다른 프로세스가 `condtion.signal();`을 호출할 때까지 보류되야 한다느 것을 의미한다.
- condtion.signal() 연산은 정확히 하나의 보류된 프로세스를 재개시킨다. 보류된 프로세스가 없으면 아무런 효과를 내지 않는다. signal() 연산의 경우에는 항상 세마포어의 상태에 영향을 준다.
- condtion.signal() 연산이 프로세스 p에 의해 호출 될때 condition x와 연관되어 있는 보류된 프로세스 q가 있다고 하면, 보류된 프로세스 q가 실행을 재개하도록 허용된다면, signal을 보낸 프로세스 p는 반드시 대기해야 한다. 그렇지 않으면 p와 q는 모니터 안에서 동시에 활성화 된다. 그러나 두 프로세스들은 개념적으로 그들의 실행을 계속할 수 있다. 두가지의 가능성이 있다.
- 1) Signal and wait : p는 q가 모니터를 떠날 때까지 가디리거나 또는 다른 condition을 기다린다.
- 2) Signal and continue: q는 p가 모니터를 떠날 때까지 기다리거나 또는 다른 condition을 기다린다.

### 모니터를 사용한 식사하는 철학자 해결안
- 이 해결안은 철학자는 양쪽 젓가락 모두 얻을 수 있을 때만 젓가락을 집을 수 있다는 제한을 강제한다. 
- 철학자의 상태를 thinking, hungry, eating의 상태로 나눌 수 있다. 철학자는 그의 양쪽 두 이웃이 식자하지 않을 때만 식사 상태로 변경할 수 있다. 철학자는 자신이 배고플 때 자기 자신을 연기할 수는 있으나, 그가 필요한 젓가락들을 집을 수는 없다.

```cpp
monitor DinignPhilosophers{
   enum {THINKING, HUNGRY, EATING} state[5];
   condition self[5];

   void pickup(int i){
      state[i] = hungry;
      test(i);
      if(state[i] != eating)
         self[i].wait();
   }
   
   void putdown(int i){
      state[i] = thinking;
      test((i+4) % 5);
      test((i+1) % 5);
   }

   void test(int i){ // 먹을수 있는지 확인
      if((state[(i+4) % 5] != eating) && (state[i] == hungry) && (state[(i+1) % 5] != eating)){ // 왼쪽이 비고 오른쪽이 비고 배고픈 상태인지를 확인
         state[i] = eating;
         self[i].signal();
      }
   }

   initalization_code(){
      for(int i=0; i<5; ++i)
         state[i] = thinking;
   }
}

DiningPhilosophers.pickup(i);
// eat
DiningPhilosophers.putdown(i);
```

- 각 철학자는 식사하기전에 pickup() 연산을 반드시 호출해야 한다. 프로세스는 보류될수도 있다. 연산이 성공적으로 끝나면, 철학자는 식사할수 있다. 식사를 마친후, 철학자는 putdown() 연산을 호출한다.
- 기아상태를 해결하기 위해서는 기아상태를 확인하여 그 프로세스에서 우선권을 주는 것이 필요하다.

### 세마포를 이용한 모니터 구현
- 각 모니터마다 mutex라는 세마포어가 정의되고, 그 초기값은 1이다. 프로세스는 모니터로 들어가기 전에 wait(mutex)를 실행하고, 모니터를 나온 후에 signal(mutex)를 실행해야 한다.
- signal()을 호출한 프로세스는 실행이 재개된 프로세스가 모니터를 떠나든지 wait()할 때까지 그 자신이 다시 기다려야 하므로 next라는 세마포어가 추가로 필요하게 되고 0으로 초기화 한다. signal()을 호출한 프로세스는 자신을 중단시키기 위해 next를 사용할 수 있다. 정수형 변수 `next_count`도 next에서 보류되는 프로세스의 개수를 세기위해 제공된다.

```cpp
wait(mutex);
   // body of procedure
if(next_count > 0)
   signal(next);
else
   signal(mutex);

void wait(...){
   x_count++;
   if(next_count > 0)
      signal(next);
   else
      signal(mutex);
   wait(x_sem);
   x_count--;
}

void signal(...){
   next_count++;
   signal(x_sem);
   wait(next);
   next_count--;
}
```

- 이와 같이 하면 모니터 안에서 상호 배제는 보장된다.
- condition의 signal()과 wait()은 각 condition형 x마다 `x_sem`이라는 세마포어와 `x_count`라는 정수형 변수를 도입하고 둘다 초기값을 0으로 준다.

### 모니터 내에서 프로세스 실행 재개
- condition x에 여러 프로세스들이 보류되어 있고 어떤 프로세스가 x.signal() 연산을 실행했다면 어떤 보류 프로세스를 재개할 것인지에 대한 방법중 간단한 방법은 FCFS이다. 그러나 많은 경우에는 이 방법이 충분치 않을 수 있다.
- 이를 위해 conditional-wait을 사용한다.

```cpp
ResourceAllocator.acquire(t);
// access the resource
ResourceAllocator.release();

monitor ResourceAllocator{
   boolean busy;
   condition x;

   void acquire(int time){
      if(busy)
         x.wait(time);
      busy = TRUE;
   }

   void release(){
      busy = FALSE;
      x.signal();
   }

   initialization_code(){
      busy = FALSE;
   }
}
```

- wait()연산이 호출될 때 값이 계산 되는 정수 수식 time를 도입한다. time의 값은 우선순위 번호라 불리며 보류되는 프로세스의 이름과 함께 저장된다. signal()이 실행되면 가장 작은 우선순위 번호를 가진 프로세스가 다음번에 실행재개 된다.
- 각 프로세스는 자원을 할당받기 원한다면 그 자원을 사용할 최대 시간을 지정한다. 모니터는 이중 가장 적은 시간을 희망한 프로세스에게 자원을 할당해 준다.
- 그러나 프로세스가 자원에 대한 허락을 받지 않고 자원을 액세스하는 경우, 프로세스가 자원에 대한 허락을 받은 다음 자원을 방출하지 않을 경우, 프로세스가 자원에 대한 허락을 받지 않았는데도 그 자원을 방출할 경우, 프로세스가 자원에 대한 허락을 받은 다음 방출하지 않은 상태에서 또 그 자원을 요청할 경우에는 문제 발생할 수 있다. 이 문제는 세마포어를 사용할 때도 발생할 수 있다.
- 프로세스들이 올바른 순서를 지키도록 보장하기 위해서는 ResourceAllocator 모니터와 모니터가 관리하는 자원을 사용하는 모든 프로그램을 검사해야 한다. 프로세스들이 모니터를 정확한 순서에 맞추어 호출하는지와 비협조적인 프로세스가 액세스 제어 프로토콜을 사용하지 않아서 모니터가 정한 상호 배제 규칙 경로를 무시하여 공유자원을 직접 액세스 하지 않는다는 것을 보장해야 한다.

## 동기화 사례

### Java 모니터
- 자바는 스레드 동기화를 위해 모니터와 유사한 기법을 제공한다.
- 자바의 모든 객체들은 하나의 락과 연관되어 있다. 메서드가 `synchronized`로 선언되면 이 메서드를 호출하기 위해서는 그 객체의 락을 획득해야만 한다. 이 락을 다른 스레드가 소유했다면 이 스레드는 대기를 하고 객체의 락을 위한 진입 set에 놓여진다. 진입 set은 락이 사용할수 있을때 까지 대기한다.
- 또한 자바는 wait(). signal과 같은 wait()과 notify()를 제공한다.

### Solaris 동기화
- 솔라리스는 적응적 mutex, reader-writer락, tunrstiles등을 제공한다.
- 적응적 mutex는 모든 임계 데이터 함목에 대한 접근을 보호한다. 다중처리기 시스템에서 적응적 mutex는 spinlock으로 구현된 포준 세마포어로 출발한다. 데이터가 사용중이면 적응적 mutex는 두가지중 한가지 일을 한다.
- 1) 다른 cpu에서 실행 중인 스레드가 락을 소유하고 있으면 그 스레드는 락이 사용 가능하게 되기를 기다리면서 spin한다. 락을 소유하고 있는 스레드가 현재 실행 상태가 아니면, 그 스레드는 봉쇄되고 락이 방출되어 깨어날 때까지 잠자게 된다.
- 2) 단일처리 시스템에서는 한번에 한 스레드만 실행될 수 있으므로, 락이 다른 스레드에 의해 검사되고 있으면 락을 소유하고 있는 스레드는 결코 실행되지 않는다. 그러므로 스레드가 락을 만나게 되면 spin하지 않고 항상 잠들게 된다.
- 솔라리스는 짧은 코드에 대해서만 적응적 mutex를 사용한다. 긴 코드에 대해서는 공회전에 대한 오버헤드로 비효율적이 될수 있다.
- 솔라리스는 reader-writer락이나 적응적 mutex를 얻기 위하여 기다리는 스레드들의 순서를 정해주기 위해 turnstile을 사용한다. 이것은 락 때문에 봉쇄된 스레드들을 수용하는 큐 구조이다.
- 솔라리스는 객체마다 turnstile을 두지 않고 커널 스레드마다 둔다. 스레드는 한 순간에 오직 하나의 객체에 대해서만 봉쇄되기 때문에 커널 스레드에 두는 것이 효율적이다.
- turnstile은 우선순위 역전 현상을 방지하기 위해 우선순위 상속 프로토콜에 의해 구성된다.
- 커널에 의해 사용되는 락 기법이 사용자 스레드에도 구현되어 있다. 둘의 차이는 우선순위의 상속 프로토콜이다. 커널의 락 루틴은 스케줄러에 의해 사용되는 우선순위 상속 방법을 고수한다. 사용자 스레드 락은 이것을 제공하지 않는다.

### windows XP 동기화
- XP 커널이 단일 처리기에서 전역 정보를 엑세스할 때에는 인터럽트를 잠시 동안 금지시킨다. 다중처리기에서는 spinlock을 써서 정보 엑세스를 통제한다. 솔라리스와 같이 짧은 코드에만 spinlock을 사용한다. 또한 효율성을 위해 스레드가 스핀락을 가지고 있는 동안에는 선점되지 않도록 보장한다.
- 커널 외부에서 스레드를 동기화하기 위하여 dispathcer 객체를 제공한다. 스레드는 dispatcher 객체를 사용하여 뮤텍스, 세마포어를 포함한 다양한 기법에 맞추어 동기화할 수 있다.
- Event는 condition 변수와 유사하다. 즉, 기다리는 조건이 만족되면 기다리고 있는 스레드에게 통지해 줄수 있다.
- 타이머는 지정한 시간이 만료되면 하나이상의 스레드에게 통지하는 데 사용한다.
- Dispatcher 객체는 signaled(객체가 사용 가능하고 그 객체를 얻을 때 그 스레드가 봉쇄되지 않음)과 nonsignaled(객체가 사용 가능하지 않고 그 객체를 얻으려고 시도하면 봉쇄됨)의 상태로 구성된다.
- 스레드가 nonsignaled 상태에 있는 dispatcher 객체 때문에 봉쇄되면 그 스레드의 상태는 준비로부터 대기 상태로 바뀌고 그 객체의 대기 큐에 넣어진다. dispathcer 객체의 상태가 signaled로 바뀌면 객체를 기다리는 스레드를 파악한후 하나의 스레드를 대기 상태에서 준비상태로 바꾸어서 실행을 재개하도록 한다. 커널이 대기 큐로부터 선택하는 스레드의 개수는 dispatcher 객체의 유형에 달려있다.

### 리눅스 동기화
- 리눅스 커널은 완전히 선점 가능하며, 커널 모드에서 실행 중일때에도 태스크는 선점될 수 있다.
- 커널 안에서의 락킹을 위하여 spinlock과 세마포어 및 두 락의 reader-writer 버전도 제공한다.
- SMP 기계에서는 기본적인 락킹 기법은 spinlock이다. 또한 이것은 짧은 시간 동안만 소유되도록 커널이 설계되었다. 락이 오래동안 지속된다면 세마포어를 사용한다.
- 단일 처리기에서는 락킹를 얻으면 커널 선점을 불가능하게 하고 락을 반환하면 커널 선점을 가능케한다.

### Pthreads 동기화
- Pthreads API는 동기화를 위해 mutex, condition, read-write락을 제공한다. 이 API는 커널의 일부분이 아닌 프로그래머가 사용할 수 있다.

## 원자적 트랜잭션
- 임계 영역의 상호 배제는 임계 영역이 중단되지 않는 하나의 단위로 실행된다는 것을 보장한다.

### 시스템 모델
- 하나의 논리적인 기능을 실행하는 명령어의 집합을 `트랜잭션`이라고 한다.
- 트랜잭션을 처리하는 데 있어 주요 문제는 컴퓨터 시스템 안에서 어떤 고장이 발생할 가능이 있더라도 원자성을 보장해야 한다.
- 시스템에 의해 거절된 트랜잭션은 접근된 데이터의 생태에 어떠한 영향도 주어서는 안된다. 따라서 철회된 트랜잭션에 의해 접근된 데이터의 상태는 트랜잭션 시작 이전의 값들로 복원시켜 주어야 한다. 이것을 `롤백`한다고 한다.

### 트랜잭션 메모리
- 트랜잭션 메모리는 스레드-안전 동시실행 애플리케이션 개발을 위한 대체 전략을 제공한다.
- 원자적인 메모리 읽기-쓰기 연산의 연속된 순서를 의미한다. 모든 연산이 완료되면, 메모리 트랜잭션은 완료된다. 그렇지 않으면 연산은 철회되고 롤백되어야 한다.
- 이것에 사용에 대한 이점은 락과 세마포어과 같은 동기화 기법의 잠재적인 문제를 가지는데 이에 대한 책임을 개발자가 가지는 것이 아니라 트랜잭션 메모리 시스템이 지는 것이다.
- 트랜잭션 메모리는 소프트웨어 또는 하드웨어로 구현될 수 있다.
- 소프트웨어 트랜잭션 메모리는 트랜잭션 블록안에 검사 코드를 삽입함으로써 동작한다. 이 코드는 컴파일러에 의해 삽입되어 low-level단의 락킹이 필요한 지점을 검사함으로써 트랜잭션을 관리한다.
- 하드웨어 트랜잭션 메모리는 개별 처리기 캐시에 존재하는 공유 데이터의 충돌을 해결하고 관리하기 위하여 하드웨어 캐시 계층구조와 캐시 일관성 프로토콜을 사용한다.

### 로그 기반 복구
- 원자성을 보장해 주는 한 방법은 트랜잭션에 의해 접근된 데이터에 가해지는 모든 변경 내역을 안전 저장장치에 기록해 놓는 것이다. 이러한 형태의 기록을 얻기 위해 가장 많이 사용되는 기법은 `로그 우선 쓰기` 방식이다.
- 로그의 정보는 다양한 트랜잭션에 의해 접근된 데이터 항목의 값을 복원시키는 데 사용되므로 안전 저장장치에 해당 로그 레코드를 기록하기 전에는 데이터 항목에 대한 실제 갱신을 허용하지 않는다.
- 고장으로 부터 복구 알고리즘은 undo와 redo가 있다. undo는 트랜잭션이 갱신한 데이터 값을 이전의 상태로 돌려 놓는것이고, redo는 갱신한 데이터 값에 새로운 값들을 넣는것이다. 이들 연산은 `idempotent`해야한다. 즉, 여러번 실행해도 한번 실행한것과 동일한 결과를 내야한다.

### 검사점
- 로그에 대한 조사를 하면서 발생되는 오버헤드를 줄이기 위하여 트랜잭션이 완료될때 마라 검사점을 두는 것이다. 이것은 검사점까지의 작업은 오류없이 변경을 끝냈다는 것을 의미한다.

### 동시 실행 원자적 트랜잭션
- 각 트랜잭션들은 원자적이기 때문에 여러 트랜잭션들을 병렬로 실행시키면 그 결과는 모든 트랜잭션들을 어떤 임의의 순서에 따라 하나씩 차례로 순차적으로 실행시킨 것과 같아야 한다. 이러한 성질을 `serializability`라 한다.

#### serializability(직렬 가능성)
- 각 트랜잭션들이 원자적으로 실행되는 스케줄을 `직렬 스케줄`이라고 한다.
- 직렬 스케줄은 여러 트랜잭션들의 명령어들의 순서로 구성되고 특정 트랜잭션에 속한 명령어들은 연속된 한 집합 형태로 나타난다.
- 두개의 트랜잭션을 중첩되게 실행시키면 그 결과는 직렬 스케줄이 아니다 그러나 이러한 비직렬 스케줄이 잘못된 것은 아니다.
- 예로 두 개 트랜잭션의 명령어 중에는 서로 충돌을 일으키지 않을 수 있는 명령어들이 있을 수 있다. 이런 명령어 들은 각자의 트랜잭션 처리 때 서로 스왑을 하여 처리할 수 있다. 이러한 처리가 가능한 스케줄을 `충돌 직렬가능`하다고 한다.

#### 락킹 프로토콜
- 직렬 가능성을 보장하는 한 가지 방법은 데이터 항목마다 락을 두고 각 트랜잭션이 일정한 락킹 프로토콜에 맞추어 락을 획득/반납 하도록 하는 것이다. 이러한 방식은 reader-writer 알고리즘과 비슷하다.
- 트랜잭션은 이전에 락을 걸었던 데이터 항목에 대해서 락을 해제할 수 있다. 그러나 데이터 항목을 엑세스하는 기간 동안에는 계속 락을 유지해야 한다. 또한 데이터 항목에 대한 마지막 엑세스가 끝나자마자 바로 락을 해제하는 것은 직렬가능성이 보장되지 않을수도 있다. `두 단계 락킹 프로토콜`은 직렬가능성을 보장해준다.
- 두 단계 락킹 프로토콜은 각 트랜잭션이 락과 언락을 두 단계로 실행할 것을 요구한다.
- 확장 단계: 트랜잭션은 락을 새로 얻을수 있지만 얻었던 락을 반납해서는 안된다.
- 수축 단계: 트랜잭션은 얻었던 락을 반납할 수는 있지만 새로운 락을 얻어서는 안된다.
- 트랜잭션은 최초 확장 단계에서 시작한다. 트랜잭션은 필요한 만큼의 락을 확보한다. 그러나 트랜잭션이 한 개의 락을 해제하기 시작하며 수축 단계로 들어가며 그 이후부터는 새로운 락을 획득해서는 안된다.
- 이 방법은 충돌 직렬가능성을 보장한다. 그러나 교착상태 문제로부터 자유롭지 못하다.

#### 타임스탬프 기반 프로토콜
- 직렬 가능한 순서를 결정하는 다른 방법은 미리 순서를 선택하는 방법이다. 가장 많이 사용하는 방법은 타임스탬프 순서 기법이다.
- 시스템의 각 트랜잭션 마다 고유한 고정 타임스탬프를 부여한다. 이 타임스탬프는 트랜잭션을 실행하기 전에 시스템에 의해 부여된다.
- 시스템 클록의 값을 타임스탬프로 이용: 트랜잭션의 타임스탬프는 이 트랜잭션이 시스템에 도착할 당시 클록의 값이 된다. 그러나 이 방법은 별도의 시스템에서 실행되거나 두 처리가 클록을 공유하지 않는 환경에서 실행되는 트랜잭션들에 대해서는 사용될 수 없다.
- 논리적인 카운터를 타임스탬프로 사용: 트랜잭션의 타임스탬프는 이 트랜잭션이 시스템에 도착할 당시 논리적인 카운터의 값이 된다. 카운터는 새 타임스탬프가 부여된후 증가된다.
