# 보호

## 접근 행렬
- 보호 모델은 추상적으로 접근 행렬이라 불리는 하나의 행렬로 볼 수 있다. 접근 행렬의 행은 영역을 나타내고, 열은 객체를 나타낸다. 행렬의 각 항은 접근 권한의 집합으로 구성된다. 객체들은 열에 의하여 명시적으로 정의되므로, 접근 권한에서 객체 이름을 생략할 수 있다. 항 access(i,j)는 영역 Di내에서 실행 중인 프로세스가 객체 Oj에 대해 호출 가능한 연산의 집합을 정의한다.
- 접근 행렬 기법은 여러 정책을 지정할 수 있는 기법을 우리에게 제공한다. 이러한 기법은 접근 행렬의 구현과 앞서 언급한 semantic의 특성의 성립 보장으로 이루어진다. 
- 접근 행렬은 프로세스와 영역간의 정적, 동적 연관을 위한 엄격한 제어를 정의하고 구현하는 적절한 기법을 제공한다. 프로세스를 한 영역에서 다른 영역으로 전환할 때, 객체에 대해 연산을 실행하는 것이다. 영역을 접근 행렬의 한 객체로 취급함으로써 영역 전환을 제어할 수 있다. 접근 행렬의 내용을 변환시킨다는 것은 접근 행렬이라는 객체에 대해 연산을 실행하는 것이다. 마찬가지로 접근 행렬 자체를 하나의 객체로 포함시킴으로써 이러한 변화를 제어할 수 있다. 실제로, 접근 행렬 내의 각 항목들이 개별적으로 변경될 수 있으므로, 접근 행렬 내의 각 항들을 보호되어야 할 객체로 간주해야 한다.

## 접근 행렬의 구현
- 일반적으로 접근 행렬은 희소 핼렬이다. 
- 대부분의 시스템은 접근 리스트와 자격의 조합을 사용한다. 프로세스가 객체를 처음 접근하려고 시도할 때 접근 리스트가 탐색된다. 만약 접근이 거부되면, 예외 상황이 발생하고, 그렇지 않으면 하나의 자격이 생성되어 그 프로세스에 부착된다. 추가의 참조는 이 자격을 사용하여 접근이 허락되는지를 신속히 나타낸다. 마지막 접근 후 그 자격은 파괴된다.
- 예를 들어, 하나의 파일 시스템에서 각 파일은 하나의 연관된 접근 리스트를 가지고 있다. 프로세스가 파일을 열 때 파일을 찾기 위하여 디렉터리 구조가 검색되고, 접근 허용 여부가 검사되며, 버퍼가 할당된다. 이런 모든 정보가 프로세스에 연관된 파일 테이블 안의 새로운 항에 기록된다. 이 연산은 이 테이블에서 새로 열린 파일을 위한 항의 인덱스를 돌려준다. 이 파일에 대한 모든 연산은 이 파일 테이블에 대한 인덱스를 지정함으로써 행해진다. 파일 테이블 내의 항은 다시 파일과 그 버퍼를 가리킨다. 파일이 닫힐 때 그 파일에 대한 파일 테이블 항이 제거된다. 파일 테이블이 OS에 의해 유지되므로, 파일 테이블은 사용자에 의해 오염될 수 없다. 따라서 사용자가 접근할 수 있는 파일은 이미 열려 있는 파일들뿐이다. 파일이 열릴 때 접근이 검사되기 때문에 보호가 보장된다.
- 접근 권한은 매번 접근할 때마다 반드시 검사해야 하며, 파일 테이블의 항은 단지 허용된 연산에 대한 자격만을 가진다는 것에 유의하라. 만일 파일이 읽기를 위해 열렸다면, 파일 테이블 항에는 읽기 접근을 위한 자격만이 존재한다. 그러나 파일에 대한 쓰기가 시도되면, 시스템은 요구된 연산과 파일 테이블 항 내의 자격을 비교함으로써 이를 보호 위반이라고 결정한다.

## 접근 제어
- 각 파일과 디렉터리에는 소유자, 그룹, 혹은 가능한 사용자의 리스트가 할당되고 각 항목마다 접근제어 정보가 부여된다.
- Solaris 10은 `역할기반 접근제어(RBAC)`를 이용하여 최소 권한의 원칙을 명시적으로 추가함으로서 보호를 개선했다. 이 기능은 특권 주위에서 순환한다. 특권은 시스템 호출을 실행하거나 옵션을 부여하여 시스템 호출을 사용할 수 있는 권리이다. 특권은 프로세스에 연관되어 정확히 일을 실행하는데 필요한 접근만 가능하도록 제한한다. 또 특권과 프로그램은 역할이 배정될 수 있다. 사용자는 역할이 배정되거나 역할에 부여된 패스워드에 기반하여 역할을 획득할 수 있다. 이러한 특권의 구현은 슈퍼유저나, setuid 프로그램과 연관된 보안 위협을 경감시킨다.

## 접근 권한의 취소
- 동적 보호 시스템에서 서로 다른 사용자에 의하여 공유되는 객체에 대한 접근 권한을 취소해야 할 필요가 있다.
- 취소에 대하여 즉시 발생인가 지연 발생인가 또는 선택적 객체대해서만 영향인가 아니면 모든 사용자에 대해 영향인가 또는 객체에 연관된 권한 일부인가 아니면 모든 권한 인가 또는 접근이 영구적으로 취소인가 일시적인가를 고려해야 한다.
- 접근 리스트 기법에서 취소는 쉽다. 접근 리스트에서 취소할 접근 권한을 탐색하여 리스트에서 제거한다.
- 자격은 시스템 전체에 걸쳐 분포되어 잇으므로, 자격을 취소하려면 먼저 그것을 찾아야만 한다.
- 재획득: 주기적으로 자격들이 각 영역에서 제거된다. 만일 한 프로세스가 어떤 자격을 사용하기를 원한다면, 그 자격이 제거되었음을 발견할 것이다. 이때 그 프로세스는 그 자격을 다시 획득하려 할 수 있다. 만일 접근이 취소되었다면, 그 프로세스는 자격을 재획득할 수 없을 것이다.
- 후방 포인터: 각 객체마다 그 객체와 연관된 모든 자격을 가리키는 포인터 리스트를 유지한다. 취소가 요구될 때는 이들 포인터를 따라가면서 필요에 따라 자격을 변경시킬 수 있다.
- 간접: 자격이 객체를 직접 가리키지 않고, 대신 간접적으로 가리킨다. 각 자격은 전역 테이블의 유일한 항을 가리키며, 그 항은 다시 객체를 가리킨다. 취소는 전역 테이블을 탐색하여 원하는 항을 찾아 그것을 제거함으로써 구현된다. 후에 접근이 시도될 때는 자격이 불법적인 테이블 항을 가리키고 잇음을 발견하게 될 것이다. 자격과 테이블 항은 객체의 유일한 이름을 수록하고 있기 때문에 어려움없이 다른 자격을 위하여 재사용될 수 있다.
- 키: 키는 각 자격에 연관될 수 있는 유일한 비트 패턴이다. 이러한 키는 자격이 만들어질 때 정의되며, 그 자격을 소유한 프로세스에 의하여 변경되거나 검사될 수 없다. 각 객체에 연관된 마스터 키는 키 설정 연산으로 정의되거나 대체될 수 있다. 한 자격이 생성될 때 마스터키의 현재 값이 그 자격에 연관 지어진다. 그 자격이 행사될 때 그 키가 마스터키와 비교된다. 만일 그 키들이 일치하면 연산은 계속 실행되도록 허용하며, 그렇지 않으면, 예외 상황이 제기된다. 취소는 키 설정 연산에 의하여 마스터키를 새로운 값으로 대체하며, 이 객체에 대한 이전의 모든 자격을 무효화 한다. 이 기법에서는 오직 하나의 마스터키가 각 개체와 연관 지어지므로 선택적 취소가 허용되지 않는다. 만일 각 객체에 키의 리스트를 연관시킨다면, 선택적 취소가 구현될 수 있다. 마지막으로, 모든 키들을 하나의 전역키 테이블로 모을 수 있다. 한 자격은 그 키가 전역 테이블 내의 어떤 키와 일치할 경우에만 유효하다. 취소는 테이블로부터 일치하는 키를 제거함으로써 구현된다. 이 방법에서 하나의 키가 여러 객체에 연관될 수 있으며, 각 객체에 여러 개의 키가 연관될 수 있어 최대한의 융통성을 제공한다. 키 기반 기법에서 키를 정의하거나, 키를 리스트 내에 삽입하거나 제거하는 연산은 모든 사용자가 이용할 수 있게 해서는 안된다.

## 자격 기반 시스템

### Hydra의 예
- Hydra는 자격 기반 보호 시스템으로 상당한 융통성을 제공한다. 이 시스템은 시스템이 알고 있으며 또한 해석하는 가능한 접근 권한의 고정된 집합을 제공하고 있다. 이러한 권한은 메모리 세그먼트의 읽기, 쓰기, 실행 권한과 같은 기본 형태의 접근을 포함한다. 추가로, 시스템은 사용자가 부가적인 권한을 선언할 수 있는 방법을 제공한다. 사용자가 정의한 권한의 해석은 단지 사용자 프로그램에 의해서만 실행되지만, 시스템은 시스템이 정의한 권한의 사용에 대해서는 물론이고 사용자가 정의한 권한을 사용하는 데에 대해서도 접근 보호를 제공한다. 이러한 설비는 보안 이론의 주요한 발전에 해당한다.
- 객체에 대한 연산은 절차적으로 정의된다. 그러한 연산을 구현하는 절차는 그 자체가 하나의 객체이고, 그들은 자격에 의해 간접적으로 접근된다. 보호 시스템이 사용자가 정의한 프로시저의 이름이 보안 시스템에 식별되어야만 한다. 객체의 정의가 Hydra에게 알려지면, 타입에 대한 연산의 이름이 보조 권한이 된다. 보조 권한은 타입의 인스턴스를 위한 자격에 서술될 수 있다. 한 프로세스가 타입을 가진 객체에 하나의 연산을 실행하려면, 그 프로세스가 그 객체에 대해 보유한 자격에 서술된 보조 권한에 호출되는 연산의 이름을 반드시 포함해야 한다. 이 제한은 접근 권한의 구별을 인스턴스별 그리고 프로세스별로 할 수 있게 한다.
- Hydra는 또한 권한 확대를 제공한다. 이 기법은 한 프로시저를 실행할 수 있는 권한을 갖고 있는 임의의 프로세스를 대신하여 그 프로시저가 명시된 타입의 형식 파라미터에 대해 동작하는 것을 신뢰할 수 있다고 보증할 수 있게 한다. 신뢰할 수 있는 프로시저가 가진 권한은 호출 프로세스가 가진 권한에 독립적이며, 그 권한을 초과할 수도 있다. 그러나 그러한 프로시저는 보편적으로 신뢰할 수 있다고 생각되어서는 안되며, 신뢰성은 그 프로세스가 실행하는 다른 프로시저나 프로그램 세그먼트로 확장될 수 없다.
- 확장성은 구현 프로시저가 추상화된 데이터 유형의 변수 값에 접근하는 것을 허용한다. 예를 들어, 프로세스가 타입을 가진 객체 A에 대해 자격을 가지고 있다면, 이 자격은 어떤 연산 P를 실행할 수 있는 보조 권한을 포함할 수도 있지만, A를 나타내는 세그먼트에 읽거나 쓰거나 또는 실행시킬 수 있는 소위 커널 권한은 하나도 포함할 수 없다. 그러한 자격은 프로세스에게 A의 표현에 대해 간접 접근의 수단을 제공하지만 그 접근은 오직 명시된 목적에 한한다.
- 반면에, 객체 A에 대해 프로세스가 연산 P를 호출하였을때 A에 접근하기 위한 자격은 P의 코드에 제어가 전달되면서 확대할 수 있다. 이러한 확대는 P가 추상 자료 타입에 대해 정의한 연산을 구현하기 위해 P에게 A를 표현하는 저장장치 세그먼트에 대한 접근 권한을 허용하기 위해 필요할 수 있다. 비록 P를 호출한 프로세스는 할 수 없지만 P의 코드가 A의 세그먼트에 읽기, 쓰기를 할 수 있도록 허용될 수 있다. P로부터 복귀할 때 A에 대한 자격은 원래의 확대되지 않은 상태로 돌아간다. 이와 같은 상황은 보호된 세그먼트에 대한 프로세스의 접근 권한이 실행될 테스크에 따라 동적으로 변해야하는 전형적인 경우이다. 권한을 동적으로 조정하는 것은 프로그래머가 정의한 추상화의 일관성을 보장하기 위하여 실행된다. 권한의 확대는 Hydra OS에서 추상 자료 타입을 선언할 때 명시적으로 표현할 수 있다.
- 사용자가 프로시저에 인자로 객체를 전달할 때 그 프로시저가 그 객체를 변경할 수 없음을 보장할 필요가 있을 수도 있다. 우리는 변경 권한이 없는 접근 권한을 전달함으로써 이 제한을 쉽게 구현할 수 있다. 그렇지만 만일 확대가 일어나면 변경할 수 있는 권한은 회복될 수 있으며, 따라서 사용자 보호 요구를 우회할 수 있다. 일반적으로, 사용자는 어떤 프로시저가 주어진 태스크를 정확하게 실행한다고 신뢰할 수도 있다. 그렇지만 이 가정은 하드웨어와 소프트웨어 에러 때문에 항상 정확하지는 않다. Hydra는 권한 확대를 제한함으로써 이 문제를 해결하였다.
- Hydra의 프로시저 호출 기법은 상호 불신 서브시스템 문제에 대한 직접 해결책으로 설계되엇다. 이 문제는 다음과 같이 정의된다. 다수의 다른 사용자들에 의해 서비스로 호출될 수 있는 프로그램이 제공된다고 가정하자. 사용자가 이 서비스 프로그램을 호출할 때 그 프로그램이 오작동하여 주어진 자료를 손상시키거나 나중에 사용이 가능하도록 자료에 대한 일부 접근 권한을 그대로 유지하는 위험을 감수해야 한다. 유사하게, 서비스 프로그램은 호출하는 사용자 프로그램이 직접 접근할 수 없는 다수의 사유 파일을 가질 수도 있다. Hydra는 이 문제를 직접 다루기 위한 기법을 제공한다.
- Hydra 서브시스템은 보호 커널 위에 설치되었고, 자신의 구성요소에 대한 보호를 요구할 수도 있다. 서브시스템은 커널이 정의한 프리미티브들의 집합에 대한 호출을 통해 커널과 상호작용한다. 이 프리미티브들은 서브시스템에 의해 정의된 자원에 대한 접근 권리를 정의한다. 사용자 프로세스에 의하여 이러한 자원이 사용되도록 하는 정책은 서브시스템 설계자에 의하여 정의될 수 있으나 그들은 자격 시스템이 감당하는 표준 접근 보호에 의해 시행 가능하다.
- 프로그래머는 참조 매뉴얼에서 보호 시스템의 기능을 알아본 다음 보호 시스템을 직접 사용할 수 있다. Hydra는 사용자 프로그램에서 부를 수 있는 시스템 정의 프로시저 라이브러리를 제공한다. Hydra 시스템의 사용자는 프로그램 코드에 시스템 프로시저에 관한 호출을 명시적으로 혼합하여 사용하거나 또는 Hydra와 인터페이스하는 프로그램 번역기를 사용할 수 있다.

### 캠브리지 CAP 시스템
- 캠브리지 CAP 시스템의 설계에서는 자격 기반 보호에 대해 다른 접근 방법을 채택하였다. CAP의 자격 시스템은 Hydra보다 단순하고 표면적으로는 강력하지 못하다. 그러나 좀 더 자세히 검토하면 이것 역시 사용자가 정의한 객체를 안전하게 보호할 수 있다. CAP에는 두 가지 종류의 자격이 있다. 통상적인 종류는 자료 자격이다. 자료 자격은 객체에 대한 접근을 제공하지만 제공되는 유일한 권한은 객체와 연관된 개개의 저장장치 세그먼트에 대한 읽기, 쓰기, 실행뿐이다. 자료 자격은 CAP 기계 내의 마이크로코드에 의해 해석된다.
- 두 번째 종류의 자격인 소프트웨어 자격은 CAP 마이크로코드에 의해 보호되지만 해석되지는 않는다. 소프트웨어 자격은 보호되는 프로시저에 의해 해석되는데, 보호되는 프로시저는 서브시스템의 한 부분으로 응용 프로그래머에 의해 작성도리 수 있다. 특별한 종류의 권한 확대가 보호되는 프로시저에 연된되어 있다. 이러한 프로시저의 코드를 실행할 때 프로세스는 일시적으로 소프트웨어 자격 자체의 내용을 읽거난 쓰는 권한을 얻는다. 이러한 특정 종류의 권한 확대는 자격에 대한 봉인과 개방의 구현에 해당한다. 물론, 이러한 특권은 지정된 추상 타입을 위한 소프트웨어 자격만이 그러한 임의의 프로시저에 전달되는 것을 보장하기 위해 타입 검증을 받아야 한다. CAP 기계의 마이크로코드 이외의 어떤 코드도 보편적인 신뢰를 받을 수 없다.
- 소프트웨어 권한의 해석은 완전히 서브시스템에 달려 있는데, 이 해석은 서브시스템내의 보호된 프로시저에 의해 이루어진다. 이 기법에 의해 다양한 보호 정책을 구현할 수 있다. 프로그래머가 자신의 보호된 프로시저를 정의할 수 있지만 전체 시스템의 보안은 훼손될 수 없다. 기본적인 보호 시스템은 자신이 들어 있는 보호 환경에 속하지 않은 임의의 저장장치 세그먼트를 검증되지 않고, 사용자가 정의한, 보호된 프로시저가 접근하는 것을 허용하지 않는다. 불안전한 보호 프로시저의 가장 나쁜 결과는 자신이 책임져야 할 서브시스템의 보호를 파괴하는 것이다.
- CAP 시스템의 설계자는 소프트웨어 자격의 사용이 추상적 자원의 요구에 상응하는 보호 정책을 조직하고 구현하는 데 있어서 상당한 경제성이 있다. 그러나 이러한 기능을 사용하기 원하는 서브시스템의 설계자는 CAP에서와 같이 단순히 참고 매뉴얼만 볼 수는 없다. 그 대신 시스템이 프로시저 라이브러리를 제공하지 않기 때문에 보호의 원리와 기술을 반드시 배워야 한다.

## 언어 기반의 보호
- 커널은 보호되는 자원에 접근하려는 모든 시도를 검사하고 확인하기 위한 보안 대리자 역할을 한다. 광범위한 접근 확인 잠재적으로 상당한 부담의 원인이 될 수 있으므로, 각 확인 비용을 줄이기 위하여 하드웨어 지원을 제공하거나, 시스템 설계자가 보호의 목표를 다소 완화하는 것을 허용해야 한다. 보호 정책을 구현하기 위한 융통성이 시스템이 제공하는 지원기법에 의해 제한되거나, 또는 보호 환경이 보다 높은 연산 효율을 보장하는 데 필요한 것보다 필요 이상으로 클 경우 이와 같은 모든 목표를 만족시키는 어렵다.
- OS가 복잡해지고, 특히 보다 높은 수준의 사용자 인터페이스를 제공하려고 시도함에 따라 보호의 목표는 좀 더 세분화되었다. 이러한 세분화에서 보호 시스템의 설계자들은 프로그래밍 언어, 특히 추상 자료 타입의 아이디어를 크게 잠조 했다.  보호 시스템은 이제 접근이 시도되는 자원의 신원뿐만 아니라 그 접근의 기능적 특성에도 관심을 둔다. 최신의 보호 시스템에서 호출 가능한 기능에 대한 관심은 표준 파일 접근 방법과 같은 시스템이 정의한 기능 집합 이외에 사용자가 정의한 기능까지도 포함하도록 확장되었다.
- 또한, 자원 이용 정책은 애플리케이션에 따라서 변할 수 있으며, 시간이 지남에 따라 변경될 수도 있다. 이러한 이유로 보호는 더 이상의 OS 설계자만의 문제는 아니다. 응용 서브시스템의 자원을 부정 조작이나 오류의 영향으로부터 보호하기 위하여 애플리케이션의 설계자가 사용할 수 있는 도구가 있어야 한다.

### 컴파일러 기반 시행
- 시스템 내의 공유 자원 접근에 대해 요구되는 제어를 지정하는 것은 그 자원에 관한 선언문을 작성하는 일이다. 이러한 종류의 선언문은 프로그래밍 언어의 타이핑 설비를 확장함으로써 언어에 통합될 수 있다. 자료 타이핑과 함께 보호가 선언되면, 각 서브시스템의 설계자는 시스템 내의 다른 자원에 대한 사용 요구뿐만 아니라, 그 자신의 보호에 대한 요구도 지정할 수 있다. 이러한 지정은 프로그램이 구성될 때 그 프로그램 자체를 작성한 언어로 직접 주어져야 한다. 이러한 방법은 여러 이점을 가진다. 첫째, 보호 요구는 OS의 프로시저에 대한 일련의 호출로서 프로그램화되기 보다는 단순히 선언된다. 둘째, 보호 요구가 특정 OS에 의해 제공되는 설비와 독립적으로 기술될 수 있다. 셋째, 시행을 위한 방법이 서브시스템 설계자에 의해 제공될 필요가 없다. 마지막, 접근 특권이 자료 타입이라는 언어적 개념과 밀접한 관게가 있기 때문에 선언적 표기법이 자연스럽다.
- 보호를 시행하기 위해 프로그램 언어 구현에 의해 제공되는 여러 가지 기법이 있지만, 이들은 모두 그 아래에 존재하는 기계와 그 OS로부터 어느 정도의 지원에 반드시 의존해야 한다. 
- 예를 들어, 어떤 언어가 CAP 시스템에서 실행될 코드를 생성하는 데 사용된다면, 이 시스템에서 아래에 존재하는 하드웨어에 대한 모든 저장장치 참조는 자격을 통하여 간접적으로 발생한다. 이 제약은 어느 때든지 한 프로세스가 자신의 보호 환경 밖에 잇는 자원에 접근하지 못하도록 방지한다. 그러나 한 프로그램은 임의의 프로세스의 특정 코드 세그먼트를 실행 중에 어떻게 자원이 사용될 것인지에 대해 임의의 제약을 부과할 수 있다. 그러한 제한은 CAP에 의해 제공되는 소프트웨어 자격을 이용하여 쉽게 구현할 수 있다. 한 언어 구현이 소프트웨어 자격을 해석하는 표준적으로 보호되는 프로시저를 제공할 수 있으며, 이들 소프트웨어 자격은 그 언어에서 지정할 수 있는 보호 정책을 실현한다. 이 방법은 정책 명세를 프로그래머가 마음대로 지정할 수 있게 하는 반면, 그 시행을 위한 자세한 구현 방법에 대해서는 신경 쓰지 않도록 해준다.
- 설사 어떤 시스템이 Hydra나 CAP 같은 강력한 보호 커널을 제공하지 않는다 하더라도 프로그래밍 언어 안에서 주어지는 보호 명세를 구현할 수 있는 기법이 있다. 주요 차이점은 이러한 보호에 의해 제공되는 보안은 보호 커널에 의해 제공되는 보안만큼 클 수는 없다. 그 이유는 그 기법이 시스템의 동작 상태에 대한 여러 가정에 의존해야 하기 때문이다. 컴파일러는 보호 위반이 발생할 수 없다고 보장할 수 있는 참조를, 보호 위반이 가능할 수도 있는 참조로부터 분리하고, 이들을 달리 취급할 수 있다. 이런 형태의 보호에 의해 제공되는 보안은 컴파일러에 의해 생성된 코드가 실행 전이나 또는 실행 중에 변경되지 않을 것이라는 가정에 의존한다.
- 보안: 커널에 의한 시행이 컴파일러에 의한 보호 검사 코드 생성 방식보다 보호 시스템 자체의 보안을 한층 더 높여 준다. 컴파일러 지원 기법에서 보안은 번역기의 정확성, 번역되어 실행되는 코드를 수록한 세그먼트를 보호하는 저장장치관리 기법, 그리고 궁극적으로는 적재된 프로그램을 수록한 파일의 보안에 의존한다. 이들 동일한 고려사항 중 몇 가지가 소프트웨어에 의해 지원되는 보호 커널에도 역시 적용된다. 그러나 커널이 고정된 물리 저장장치 세그먼트에 존재하고, 단지 지정 파일로부터만 적재되기 때문에 그 정도가 다소 떨어진다. 꼬리표가 붙은 자격 시스템에 있어서는 모든 주소 계산이 하드웨어나 고정된 마이크로프로그램에 의하여 시행되므로 보다 철저한 보안이 가능하다. 하드웨어에 의해 지원되는 보호도 역시 하드웨어나 시스템 소프트웨어의 고장의 결과로 유발될 수 있는 보호 위반에 대해 상대적으로 염려할 필요는 없다.
- 융통성: 보호 커널은 시스템이 자신의 정책을 시행하는 데는 적절한 설비를 제공할 수 있으나, 사용자가 정의한 정책을 구현하는 데 있어서는 그 융통성에 한계가 있다. 프로그래밍 언어를 사용할 경우 보호 정책을 선언할 수 있으며, 시행은 필요에 따라 구현에 의해 제공된다. 언어가 충분한 융통성을 제공하지 않으면, 현재 서비스 중인 시스템에 OS 커널의 변경에 의하여 야기된 것보다 더 적은 혼란을 초래하면서 언어가 확장되거나 또는 대체될 수 있다.
- 효율성: 보호의 시행이 하드웨어에 의해 직접 지원될 때 최대의 효율을 얻을 수 있다. 소프트웨어 지원이 요구되는 한 언어 기반의 시행은 컴파일할 때 오프라인으로 정적 접근 시행이 검증될 수 있다는 이점이 있다. 또한 시행 기법이 지정된 요구를 만족시키기 위해 지능형 컴파일러에 의해 조정될 수 있기 때문에 커널 호출의 고정된 오버헤드를 피할 수 있다.
- 요약하면 프로그래밍 언어에 의한 보호 명세는 자원의 할당과 이용에 대한 정책을 높은 수준에서 기술할 수 있게한다. 언어의 의한 구현은 하드웨어에 의해 지원되는 자동 검사가 이용 불가능할 때 보호 시행을 위한 소프트웨어를 제공할 수 있다. 또한, 하드웨어나 OS가 어떤 보호 시스템을 제공하든지 그에 대한 호출을 생성하도록 보호 명세를 해석할 수 있다.
- 애플리 케이션이 보호를 이용 가능하게 하는 한 가지 방법은 계산 객체로 이용될 수 있느 소프트웨어 자격을 사용하는 방법이다. 이 개념에 내재된 아이디어는 몇몇 프로그램 구성요소가 이러한 소프트웨어 자격을 생성하거나 조사할 특권을 가질 수 있다는 것이다. 자격-생성 프로그램은 자료구조를 봉인하는 기본 연산을 실행하여, 봉인 또는 개방 특권을 갖지 않는 프로그램 구성요소가 그 자료구조의 내용을 접근하지 못하게 한다. 그러한 구성요소들은 봉인된 자료구조를 복사하거나 그 주소를 다른 프로그램 구성요소로 전달할 수는 있으나, 그 내용을 접근할 수는 없다. 이와 같은 소프트웨어 자격을 도입한 이유는  프로그래밍 언어에 보호 기법을 제공하기 위한 것이다. 현재 제안된 이러한 개념의 유일한 문제점은 봉인 또는 개방 연산이 보호 지정을 위해 절차적 방법을 취한다는 것이다. 비절차적 또는 선언적 표기법이 프로그래머가 보호를 이용할 수 있도록 하는 더 좋은 방법이다.
- 시스템 자원에 대한 자격을 사용자 프로세스 간에 분산하기 위한 안전하고 동적인 접근 제어 기법이 필요하다. 그것이 시스템의 전체 신뢰도에 기여할 수 있으려면, 접근 제어 기법이 안전하게 사용 가능해야 한다. 또한 그것이 실제 유용하려면 납득할 정도로 효율적이어야 한다. 이러한 요구가 몇몇 고나리되는 자원의 사용에 대해 프로그래머가 여러 제한을 선언할 수 있게 하는 다수의 언어 구조를 개발하도록 하였다. 이들 구조들은 프로세스들 간에 안전하고 효율적인 자격 분배(특히, 이 기법들은 그 자원에 대한 자격이 주어졌을 경우에만 사용자 프로세스가 관리되는 자원을 사용할 것을 보장한다.), 특정 프로세스가 하나의 할당된 자원에 대해 호출할 수 있는 연산의 종류를 지정(모든 사용자 프로세스에 동일한 권한 집합을 부여해서는 안되며 프로세스가 접근 제어장치의 인가를 받은 경우를 제외하고는 접근 권한 집합을 확대시킬 수 없도록 해야 한다.), 특정 프로세스가 한 자원에 대하여 다양한 연산을 호출하는 순서를 지정(두 프로세스가 할당된 자원에 대한 연산을 호출하는 순서에 대하여 각각 다른 제한을 부여할 수 있어야 한다.)과 같은 기법을 제공한다.

### 자바의 보안
- 자바는 분산 환경에서 동작하도록 설계되었기 때문에 JVM은 많은 내장된 보호 기법을 가진다.  자바 프로그램은 데이터 필드와 이 필드를 이용하는 메서드라 불리는 함수의 집합인 클래스로 구성된다. JVM은 클래스의 인스턴스를 생성하라는 요구에 대한 응답으로 그 클래스를 로드한다. 자바의 가장 큰 특징은 네트워크를 통해 신뢰할 수 없는 클래스를 동적으로 로드하는 것을 지원하고 같은 JVM안에서 상호 신뢰하지 않는 클래스들을 실행하는 것을 지원한다.
- 자바의 이런 기능 때문에 보안은 매우 중요하다. 같은 JVM상에서 동작되는 클래스들이라도 소스가 다르거나 동등하게 신뢰되지 않을 수 있다. 그 결과 JVM 프로세스 수준에서 보호를 시행하는 것으로는 불충분하다. 직관적으로, 파일 열기 요청을 허용할지 여부는 일반적으로 어느 클래스가 열기를 요구했는가에 좌우된다. 하지만 OS는 이런 정보가 부족하다.
- 그러므로 그러한 보호 결정은 JVM 안에서 해결되어야 한다. JVM이 클래스를 로드할 때 JVM은 그 클래스의 허가를 부여하는 보안 도메인을 그 클래스에 할당한다. 클래스에 할당되는 보안 도메인은 클래스가 로드되었던 URL과 클래스 파일의 전자 서명에 의존한다. 구성 가능한 정책 파일이 그 도메인에게 주어지는 허가를 결정한다. 예를 들어, 신뢰하는 서버로부터 로드된 크래스는 사용자의 홈디렉터리의 파일을 접근할 수 있는 보호 영역에 넣는 반면, 신뢰하지 않은 서버로부터 로드된 클래스는 아무런 파일 접근 허가를 갖지 못할 수 있다.
- 보호되는 자원에 대한 접근 요청을 어떤 클래스가 책임질 지를 JVM이 결정하는 것은 복잡하다.  접근은 종종 시스템 라이브러리 또는 다른 클래스들을 통하여 간접적으로 실행되기도 한다. 예를 들어, 네트워크 연결을 열도록 허가받지 못한 클래스의 경우, 이 클래스가 URL 콘텐츠 적재를 요청하기 위해 시스템 라이브러리를 호출할 수 있다. JVM은 이 요청을 위해 네트워크 연결을 열지에 대해 결정해야 한다.
- Java에서 채택된 철학은 라이브러리 클래스가 명시적으로 네트워크 연결을 허용하도록 하는 것이다. 이를 보다 일반화하면, 보호된 자원에 접근하기 위해서는 요청을 유발한 호출 순서 내의 어떤 메서드가 그 자원을 접근하기 위한 특권을 주장해야 한다. 그렇게 함으로써 이 메서드가 그 요구에 책임을 진다. 아마도 이 메서드는 또한 요청의 안전성을 보장하기 위한 모든 점검을 실행할 것이다. 물론 임의의 메서드가 특권을 주장하도록 허용해서는 안된다. 오직 그 클래스가 특권을 사용하도록 허용된 보안 도메인 내에 있을 때만 그렇게 할 수 있다.
- 이러한 구현 접근 방법을 `스택 검사`라 한다. JVM 내의 모든 스레드는 자신이 진행 중인 메서드 호출의 스택을 가지고 있다. 그 호출자가 신뢰될 수 없으면, 메서드는 보호되는 자원에 직접 또는 간접으로 접근을 실행하기 위해 `docPrivileged` 블록 안에서 접근 요청을 실행한다. docPrivileged()는 AccessController 클래스의 정적인 메서드로 호출할 run() 메서드가 존재하는 클래스에 전달한다. docPrivileged 블록이 실행될 때, 이 메서드의 스택 프레임에 이 사실을 나타내는 주석을 붙인다. 이어 블록의 콘텐츠가 실행된다. 후에 이 메서드 또는 이 메서드가 호출하는 메서드에 의해 보호되는 자원에 접근이 요청되면 요청이 허용되는지 결정하기 위하여 checkPermissions()을 호출하여 스택 검사를 실행한다. 검사는 가장 최근에 추가된 프레임에서 시작하여 가장 오래된 프레임으로 진행하면서 호출하는 스레드의 스택 상의 스택 프레임을 검사한다. docPrivileged() 주석을 가진 스택 프레임이 처음 발견되면 checkPermissions()이 즉시 그리고 조용히 복귀하고 접근을 허용한다. 메서드의 클래스의 보호 도메인에 기반하여 접근이 허용되지 않은 스택 프레임이 먼저 발견되면 checkPermissions()은 예외를 발생시킨다. 이들 두 타입에 해당하는 프레임을 발견하지 못하고 스택 검사가 끝나버리면, 접근 허용 여부는 구현에 좌우된다.
- 물론 스택 검사가 작동하려면, 프로그램은 자신의 스택 프레임 상의 주석을 변경하거나 스택 검사를 조작할 수도 없어야 한다. 이것이 자바와 다른 언어와의 차이점 중 하나이다. 자바 프로그램은 직접 메모리에 접근할 수 없다. 자바는 오직 자신이 참조를 갖고 있는 객체만을 조작할 수 있다. 참조는 위조할 수 없고, 조작은 잘 정의된 인터페이스를 통해서만 행해진다. 이런 규칙의 준수는 로드 타임과 런타임 검사의 복잡한 집합을 통해 시행된다. 그 결과, 객체는 스택이나 보호 시스템의 다른 구성요소에 대한 참조를 얻를 수 없기 때문에 런타임 스택을 조작할 수 없다.
- 좀 더 일반화하면, 자바의 로드 타임과 런타임 검사는 자바 클래스의 타입 안전을 시행한다. 타입 안전은 클래스들이 정수를 포인터로서 사용할 수 없고, 배열의 마지막 부분을 넘어서 쓸 수 없게 하거나, 그렇지 않다면 임의의 방법으로 메모리에 접근할 수 없게 한다. 프로그램은 오히려 클래스에 의해 객체에 대해 정의된 메서드를 통해서만 객체에 접근한다. 이것이 자바 보안의 기초이다. 이것은 클래스가 자신의 데이터와 메서드를 같은 JVM  상에 로드된 다른 클래스로부터 캡슐화하고 보호한다.
