# 시스템 구조

## 운영체제 구조

### 간단한 구조
- MS-DOS의 경우에는 인터페이스와 기능 계층이 잘 분리되지 않았다. 또한 이중모드와 하드웨어 보호기능을 제공하지 않았다.
- 최초 UNIX의 경우에는 커널이 메모리 관리, 하드웨어 관리등 한 계층에서 다루기 힘든 많은 기능을 담당하였다.

### 계층적 접근
-  top-down식의 접근법을 사용하여 전체적인 기능과 특징을 결정하고 구성요소로서 분리한다.
-  시스템은 모듈화를 하여 운영을 하게 하였다.
-  장점으로 구현과 디버깅의 간단함이 있는데, 각 층들은 단지 자신의 하위 층들의 서비스와 기능들만을 사용하도록 선택되기 때문이다.
-  어려운 점은 여러 층을 적절히 정의하는 것과 다른 유형의 구현 방법보다 각 층을 마다 시스템 호출에 대한 오버헤드를 발생하므로 효율성이 낮은 것들이 있다.

### 마이크로 커널
- 모든 중요치 않은 구성요소를 커널로부터 제거하고, 제거된 요소들을 시스템 및 사용자 수준 프로그램으로 구현하여 OS를 구성하는 방법이다.
- 마이크로커널의 주 기능은 클라이언트 프로그램과 사용자 공간에서 실행되는 다양한 서비스 간에 통신을 담당하는 것이다. 상호간 통신은 직접 교환이 아닌 커널을 통한 간접 교환을 한다.
- 장점으로는 운영체제의 확장이 용의하다. 커널의 변경 없이 사용자 공간에 새로운 서비스를 추가하기 때문이다. 이로써 이식이 쉬워지고 보안성과 신뢰성을 제공한다.
- 마이크로커널은 가중된 시스템 동작 오버헤드 때문에 성능이 감소한다.

### 모듈
- 객체지향적인 프로그래밍 기법을 사용한다. 
- 커널은 핵심적인 구성요소(스케줄링, 파일시스템, 시스템 호출, 드라이버등)을 가지고 있고 부팅때, 실행 중에 동적으로 부가적인 서비스들을 링크한다. 
- 커널은 핵심 기능만을 가지고 있고 다른 모듈의 적재 방법과 어떻게 통신하는지 안다는 점에서는 마이크로 커널과 유사하지만 통신을 위하여 메시지 전달을 호출할 필요는 없다.

## 가상기계(VM)
- 컴퓨터의 하드웨어를 추상화하여 다수의 다른 실행 환경을 제공하도록 하는것
- CPU 스케줄링과 가상 메모리 기법으로 OS 호스트는 각 프로세스가 자신의 전용 메모리를 갖는 전용 처리기에서 실행되는 것처럼 환상을 만든다.
- 가상기계는 OS 호스트의 하드웨어와 동일한 인터페이스를 제공한다. 각 게스트 프로세스에게 호스트의 복사본이 제공된다.
- 장점: 호스트 시스템은 가상기계들로부터 보호된다. 게스트 OS안의 바이러스는 그 OS를 손상시킬 수 있지만 호스트나 다른 게스트를 손상시킬 수 없다.
- 가상기계들은 자원을 직접 공유할 수 없다. 공유하는 방안으로 파일 시스템 볼륨을 공유 혹은 가상기계들이 네트워크를 구성하여 공유하는 방식이 있다.

### 반가상화
- 전체적인 가상화를 하는 것이 아닌 일부만을 가상화를 하여 게스트에 제공하는 것이다.
- Solaris 10은 컨테이너라는 것으로 OS와 응용 사이에 가상화 층을 생성한다. 여기에는 오직 하나의 커널만이 설치되며, 하드웨어는 가상화되지 않는다. 각 컨테이너에는 OS와 장치들이 가상화되며, 각 게스트 OS는 자신만의 스택과 애플리케이션을 가질수 있다.

### 사례(JVM)
- 추상 컴퓨터를 위한 명세
- 클래스 적재기와 아키텍처 중립적인 바이트 코드를 실행하는 인터프리터로 구성된다.
- 클래스 적재기는 인터프리터에 의해 실행될 수 있도록 Java 프로그램과 API 모두로 부터 .class 파일을 적재한다.
- JVM은 가비지 컬렉터를 가지고 있다.
- 바이트코드 연산을 높이기 위해서 JIT 컴파일러를 사용한다.

### 사례(.NET 프레임워크)
- 이것으로 개발된 프로그램은 하드웨어나 OS 특성에 Free하다.
- .NET 프레임워크의 실행 환경은 자세한 사항들을 추상화하고 실행 프로그램과 기저의 구조 사이에 가상기계를 제공한다.
- 이 프레임워크의 핵심에는 Common Language Runtime이 존재하는데, 가상기계 상에 구현된다. 이것은 .NET 프레임워크를 대상으로 하는 임의의 언어로 작성된 프로그램을 실행하기 위한 환경을 제공한다.

## 운영체제 디버깅
- 디버깅은 시스템의 오류 또는 버그를 발견하고 고치는 행위이며, 성능 조정도 이것에 포함된다.
- 운영체제는 프로세스가 실패하면, 오류 정보를 로그 파일에 기록한다 또한 프로세스가 사용하던 메모리를 캡처한 코어덤프를 생성한다. 이 이미지는 차후 분석을 위하여 파일로 저장된다.
- 커널 고장은 crash라 불린다. 이것 또한 오류 정보를 로그에 저장하고 메모리의 상태가 충돌 덤프에 저장된다.
- 성능 튜닝을 위해서는 시스템 동작을 측정하고 분석하여 병목지점을 발견하과 비효율성을 발견한다.

## 운영체제 생성(SYSGEN)
- 운영체제는 보통 ISO 이미지로 배포된다. ISO 이미지는 CD-ROM의 형태를 가지는 파일을 말한다.
- SYSGEN 프로그램은 하드웨어 시스템의 특성 구성에 관한 정보를 운영자에게 요구하거나, 주어진 파일로부터 읽거나 구성요소를 결정하기 위하여 하드웨어를 직접 시험한다.
- 정보들이 결정되면 운영체제가 완전히 컴파일된다. 데이터 선언, 초기화등을 통하여 정보들에 맞게 운영체제를 만든다.

## 시스템 부트
- 부팅: 커널을 적재하여 컴퓨터를 시동하는 절차
- 작은 크기의 코드인 부트스트랩 로더가 커널을 찾아서 주 메모리에 적재하고, 커널의 실행을 시작한다.
- 일반 PC의 경우 간단한 부트스트랩이 디스크의 복잡한 부트스트랩을 불러 커널을 적재한다.
- 전원을 키면 명령 레지스터는 미리 지정된 메모리 위치를 가리키게 되고 그곳에서 있는 부트스트랩으로 부터 실행을 시작한다. 
- 부트스트랩은 ROM에 저장된다.
- 부트 프로그램은 기계의 상태를 진단하고 CPU 레지스터, 주 메모리등의 초기화하고 OS를 시작시킨다.
- 하드웨어와 소프트웨어의 중간적 특성을 갖으며 또한, OS를 가지며 실행하는 ROM을 펌웨어라고 한다.
