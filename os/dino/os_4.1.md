# 다중 스레드 프로그래밍
- 스레드는 CPU 이용의 기본 단위이다.
- 스레드는 스레드 ID, 프로그램 카운터, 레지스터 집합, 그리고 스택으로 구성된다.
- 스레드는 같은 프로세스에 속한 다른 스레드와 코드, 데이터 섹션, 그리고 열린 파일이나 신호와 같은 OS 자원들을 공유한다.
- 전통적인 중량 프로세스는 하나의 제어 스레드를 가지고 있다. 프로세스가 다수의 제어 스레드를 가진다면, 프로세스는 동시에 하나 이상의 작업들을 실행할 수 있다.

## 장점
- 응답성: 한 작업 중에도 다른 작업을 할수 있는 애플리키이션을 제작할 수 있다.
- 자원 공유: 프로세스는 공유 메모리 또는 메시지 전달 기법을 통해서만 자원을 공유한다. 이러한 기법은 프로그래머에 의해 명시적으로 처리되어야 한다. 그러나 스레드는 자동적으로 그들이 속한 프로세스의 자원들과 메모리를 공유한다. 코드와 데이터 공유의 이점은 한 애플리케이션이 같은 주소 공간 내에 여러 개의 다른 작업을 하는 스레드를 가질 수 있다.
- 경제성: 프로세스 생성을 위해 메모리와 자원을 할당하는 것은 비용이 많이 든다. 스레드는 프로세스의 자원들을 공유하기 때문에 스레드를 생성하고 문맥을 교환하는 것이 보다 더 경제적이다.
- 규모 가변성: 다중처리기 구조에서 더욱 증가할 수 있다. 다중 스레딩은 병렬성을 증가시킨다.

## 다중코어 프로그래밍
- 하나의 코어는 한 번에 오직 하나의 스레드만 실행할 수 있기 때문에 코어가 한 개인 시스템 상에서 병행성은 단순히 스레드의 실행이 시간에 따라 교대로 실행된다는 것을 의미한다. 여러 코어를 가진 시스템에서는 각 코어가 스레드를 처리하여 병렬성을 키운다.

### 다중코어 구성을 위한 과제
- 작업 나누기: 애플리케이션을 분석하여 각 태스크가 개별 코어 상에서 병렬적으로 실행될 수 있도록 애플리케이션을 독립된 병행가능 태스크로 나누는 작업을 말한다.
- 균형: 전체 작업에 균등한 기여도를 가지도록 태스크로 나누는 것도 중요하다.
- 데이터 분리: 태스크가 접근하고 조작하는 데이터는 개별 코어에서 사용할 수 있도록 나누어져야 한다.
- 데이터 종속성: 태스크가 접근하는 데이터는 둘이상의 태스크 사이에 종속성이 없는지 검토되어야 한다. 종속성이 있다면, 프로그래머가 데이터 종속성을 수용할 수 있도록 태스크의 실행을 잘 동기화해야 한다.
- 테스트 및 디버깅: 병행 프로그램을 시험하고 디버깅하는 것은 단일 프로그램보다 어렵다.

## 다중 스레드 모델
- 사용자 스레드는 커널 위에서 지원되며 커널의 지원 없이 관리된다. 반면, 커널 스레드는 OS에 의해 직접 지원되고 관리된다.

### 다대일 모델
- 많은 사용자 스레드를 하나의 커널 스레드로 매핑한다.
- 스레드 관리는 사용자 공간의 스레드 라이브러리에 의해 행해진다.
- 한 스레드가 봉쇄형 시스템 호출을 할 경우 전체 프로세스가 봉쇄된다.
- 한번에 하나의 스레드만이 커널에 접근할 수 있기 때문에 다중 스레드가 다중처리기에서 돌아도 병렬로 작동할 수 없다.

### 일대일 모델
- 각 사용자 스레드를 각각 하나의 커널 스레드로 매핑한다.
- 하나의 스레드가 봉쇄적 시스템 호출을 호출하더라도 다른 스레드가 실행될수 있어서 병렬성을 제공한다.
- 사용자 스레드를 생성할 때 그에 따른 커널 스레드를 생성해야 한다는 단점이 있다. 커널 스레드를 생성하는 오버헤드가 애플리케이션의 성능을 저하시킬 수 있다.

### 다대다 모델
- 여러 개의 사용자 스레드를 그보다 작은 혹은, 같은 수의 커널 스레드로 멀티플레스한다.
- 커널 스레드의 수는 애플리케이션이나 특정 머신에 따라 결정된다.
- 다대일 모델은 개발자가 원하는 만큼의 사용자 스레드를 생성하도록 허용하지만, 한 번에 하나의 스레드만이 커널에 의해서 스케줄되기 때문에 진정한 동시성을 획득할 수 없다. 일대일 모델은 더 많은 병렬성을 제공하지만, 개발자가 한 애플리케이션에 많은 스레드를 생성하지 않도록 주의해야 한다.
- 다대다 모델에서는 개발자는 필요한 만큼 많은 사용자 스레드를 생성할 수있다. 그리고 상응하는 커널 스레드가 다중처리기에서 병렬로 실행될 수도 있다.
- 다대다 모델의 변형은 멀티플레스시키는 것은 유지하지만 하나의 사용자 스레드가 하나의 커널 스레드에 종속되도록 허용한다. 이것을 two-level 모델이라고 한다.

## 스레드 라이브러리
- 프로그래머에게 스레드를 생성하고 관리하기 위한 API를 제공한다.
- 커널의 지원없이 완전히 사용자 공간에서만 라이브러리를 제공하는 방법과 라이브러리를 위한 코드와 자료 구조는 커널 공간에 존재하고 라이브러리 API를 호출하는 것은 커널 시스템 호출을 부르는 결과를 낳는다.

### Pthreds
- POSIX가 스레드 생성과 동기화를 위해 제정한 표준 API
- 스레드의 동작에 관한 명세일 뿐이지 자체를 구현한 것은 아니다.
- 개별 스레드가 공유하는 데이터는 전역변수로 선언된다.

### Win32 스레드
- 많은 점에서 Pthreads기법과 유사하다.
- `windows.h` 헤더 파일을 포함해야 한다.
- 개별 스레드가 공유하는 데이터는 전역변수로 선언된다.

### Java 스레드
- 모든 Java 프로그램은 적어도 하나의 단일 제어 스레드를 포함하고 있다. 단지 main 함수로만 이루어진 단순한 Java 프로그램 조차 JVM 내 하나의 단일 스레드로 실행된다.
- 스레드를 생성하는 기법에는 Thread 클래스로부터 파생된 새로운 클래스를 생성하고, Thread 클래스의 run() 메서드를 무효화하는 것이다. 다른 방법은 Runnable 인터페이스를 구현하는 클래스를 정의하는 것이다. Runnable을 구현할때는 run() 메서드를 구현해야 한다.
- Thread 객체를 생성하는 것은 구체적으로 말하면 새로운 스레드를 생성하는 것은 아니다. 새로운 스레드를 실제로 생성하는 것은 start() 메서드이다.
- start() 메서드를 호출하면, 메모리가 할당되고 JVM 내에 새로운 스레드가 초기화된다. run() 메서드를 호출하면 스레드가 JVM에 의해 실행될 자격을 갖게 한다. 절대로 run() 메서드를 직접 호출하지 말라.
- Java 프로그램에서 둘 이상의 스레드가 데이터를 공유해야한다면 공유 객체에 대한 참조를 적당한 스레드에게 전달함으로써 공유 한다.

### JVM과 호스트 OS
- JVM의 전형적인 구현은 호스트 OS 위에 구현된다. 이 구조는 JVM이 하부 OS의 구현 내용을 숨길 수 있게 하고, JVM을 지원하는 어떠한 플렛폼에서 JAVA 프로그램이 작동할수 있도록 하고 일관되고 추상적인 환경을 제공한다.
- 전형적으로 Java 스레드는 사용자 스레드로 간주되며, JVM은 스레드 관리를 책임진다.
- JVM은 OS에서 지원하는 다중 스레드 모델에 맞춰서 맵핑한다.
- OS의 스레드 라이브러리와 Java 스레드 라이브러리 사이에는 서로 연관이 있을수 있다. JVM이 스레드를 생성할때 OS 라이브러리의 API를 사용한다.