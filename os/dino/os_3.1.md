# 프로세스
- 실행중인 프로그램

## 개념
- 프로세스는 프로그램 카운터의 값과 처리기 레지스터의 내용으로 대표되는 현재 활동을 포함한다.
- 프로세스는 함수의 매개변수, 복귀 주소와, 임시적인 자료등을 가지는 `프로세스 스택`과 전역 변수들을 수록하는 `데이터 색션`을 포함한다. 그리고 동적으로 할당되는 메모리인 `힙 메모리`를 포함한다.
- 프로세스는 다음에 실행할 명령어를 지정하는 프로그램 카운터 및 관련 자원의 집합을 가진 능동적인 존재이다. 실행파일이 메모리에 적재될 때 프로세스가 된다.

### 프로세스 상태
- new: 프로세스가 생성 중이다.
- running: 명령어들이 실행되고 있는 중이다.
- waiting: 프로세스가 어떤 사건이 일어나기를 기다리는 상태
- ready: 프로세스가 처리기에 할당되기를 기다림
- terminated:  프로세스가 실행을 종료
- 어느 한순간에 하나의 처리기 상에서의 하나의 프로세스만 실행된다.
- running상태에서 인터럽트가 일어나면 ready로 변한다.
- running상태에서 I/O 혹은 사건 대기가 일어나면 waiting으로변한다.
- waiting에서 I/O 혹은 사건 완료가 되면 ready로 변한다.
- ready에서 스케쥴러에 의하여 디스패치되면 running으로 변한다.

### PCB(프로세스 제어 블록) 
- 각 프로세스는 OS에서 PCB에 의해 표현된다.
- PCB는 특정 프로세스와 연관된 여러 정보를 수록한다.
- 프로세스 상태: new, ready등의 상태이다.
- 프로그램 카운터: 프로세스가 다음에 실행할 명령어의 주소를 가르킨다.
- CPU 레지스터들: 누산기, 인덱스 레지스터, 스택 레지스터등과 상태 코드 정보가 포함되며, 이러한 정보는 인터럽트 발생시에 프로그램 카운터와 함께 저장되어야 한다. 인터럽트 처리후 중단된 지점으로부터 정상 실행될수 있도록 도와준다.
- CPU-스케줄링 정보: 프로세스 우선순위, 스케줄 큐에 대한 포인터와 다른 스케줄 매개변수들을 포함한다.
- 메모리 관리 정보: 운영체제가 지원하는 메모리 시스템에 따라 기준 레지스터와 한계 레지스터의 값, 페이지/세그먼트 테이블등과 같은 정보를 포함한다.
- 회계 정보: CPU가 사용된 양과 실제 사용된 시간, 계정번호 잡 또는 프로세스 번호등을 포함한다.
- I/O 상태 정보: 프로세스에 할당된 입출력장치들과 열린 파일의 목록등을 포함한다.
- 요약: 프로세스별로 달라지는 모든 정보에 대한 저장소 역할을 한다.

### 스레드
- 한 프로세스가 여러 실행 스레드를 가질 수 있도록 하여 한순간에 하나 이상의 일을 할수 있게 한다.
- 스레드를 지원하는 시스템에서 PCB는 각 스레드에 관한 정보를 포함하도록 확장한다.

## 프로세스 스케줄링
- 시분할 프로그래밍에서는 각 프로그램이 실행되는 동안 사용자가 상호작용할 수 있도록 프로세스들 사이에서 CPU를 빈번하게 교체하는 것이다.

### 스케줄링 큐
- 프로세스가 시스템에 들어오면 `잡 큐`에 놓여진다. 잡 큐에는 시스템 안의 모든 프로세스로 구성된다.
- 주 메모리에 존재하면서 ready상태에서 실행을 기다리는 프로세스들은 `ready 큐` 리스트에 유지된다. ready 큐의 헤더는 리스트의 첫 번째와 마지막 PCB를 가르키는 포인터를 포함한다. 각 PCB는 ready 큐에 있는 다음 프로세스를 가리키는 포인터 필드를 가진다.
- `device 큐`는 프로세스들이 특정 입출력 장치를 사용하기 위하여 대기하는 리스트이다. 각 장치는 자신의 device 큐를 가진다.
- 새로운 프로세스는 ready 큐에 놓이고 CPU에게 dispatch 될때까지 대기한다. 일단 디스패치가 되면, 프로세스는 입출력을 요청하여 I/O 큐에 놓여지거나, 서브프로세스를 생성하고 대기를 하거나, 인터럽트로 인하여 ready 큐로 돌아갈수있다.
- 실행이 완료되면 모든 큐에서 삭제되고, 자신의 PCB와 자원을 반납한다.

### 스케줄러

#### 일괄배치 시스템
- 즉시 실행될 수 있는 것보다 많은 프로세스들이 실행되면, 프로세스들은 디스크에 저장되어 나중에 실행될 때까지 그곳에 유지된다. `잡 스케줄러`는 이 풀에서 프로세스들을 선택하여 실행하기 위하여 메모리로 적재한다. `CPU 스케줄러`는 ready 상태의 프로세스들 중에서 선택하여 CPU를 할당한다.
- CPU 스케줄러는 CPU를 위해 자주 새로운 프로세스를 선택하여야 하므로 실행빈도가 잦다.
- 잡 스케줄러는 실행 빈도수가 훨씬 적다. 메모리에 있는 프로세스들의 수를 제어한다. 또한 잡 스케줄러는 입출력 중심과 CPU 중심 프로세스들이 적절히 혼합되도록 선택하는 것이 중요하다.

#### 시분할 시스템
- 추가로 중간 수준의 스케줄링을 도입한다. `중기 스케줄러`는 메모리에서 프로세스들을 제거하여, CPU를 위한 경쟁정도를 낮춘다. 차후에 다시 프로세스를 메모리로 불러와서 중단되었던 지점에서부터 실행을 재개한다.(`스와핑 기법`)
- 스와핑은 프로세스 혼합 상태를 개선하고 메모리 요구 변화가 가용 메모리를 초과하여 메모리를 비우기 위해 필요하다.

### 문맥 교환(context switch)
- 인터럽트가 발생하면 시스템은 인터럽트 처리가 끝난후에 문맥을 복구할 수 있도록 현재 실행 중인 프로세스의 현재 문맥을 저장할 필요가 있다. 이러한 문맥은 PCB에 표현된다.
- CPU를 다른 프로세스로 교환하려면 현재 프로세스의 상태를 저장하고 다른 프로세스의 저장된 상태를 복구하는 작업이 필요하고 이것이 문맥 교환이다.
- 문맥 교환이 일어나면, 커널은 과거 프로세스의 문맥을 PCB에 저장하고, 스케줄된 새로운 프로세스의 저장된 문맥을 복구한다. 문맥 교환이 진행될 동안 시스템이 아무런 일을 못하기 때문에 `문맥 교환은 순수한 오버헤드`이다.
- 간단한 문맥교환은 현재 레지스터 집합에 대한 포인터를 변경하기만 하면 되지만, 운영체제가 복잡할수록 더 많은 작업을 해야한다.

## 프로세스에 대한 연산

### 프로세스 생성
- 프로세스는 실행 도중 프로세스 생성 시스템 호출을 통해서 여러 개의 새로운 프로세스들을 생성할 수 있다.
- 생성하는 프로세스를 부모 프로세스, 생성된 프로세스를 자식 프로세스라고 한다.
- 대부분의 OS는 `pid(프로세스 식별자)`에 의해 프로세스를 구분하는데 이 값은 통상적으로 정수 값이다.
- 자식 프로세스는 OS로부터 직접 자원을 얻거나 부모 프로세스 자원의 부분 집합을 사용하도록 강요받을 수 있다.
- 부모 프로세스는 자원을 분할하여 자식들에게 나누어 주거나, 여러 자식들과 일부 자원을 공유할 수도 있다.
- 프로세스가 새로운 프로세스를 생성할때 두가지 실행 가능성이 있는데 부모가 계속해서 자식과 병렬로 실행되는 것과 부모가 모든 자식 또는 일부 자식이 끝날 때까지 기다리는 것이다.
- 주소 공간 측면에서 볼때 두가지 가능성이 있는데, 자식 프로세스는 부모 프로세스의 복사본(`fork()`)이거나 자식 프로세스가 자신에게 적재될 새로운 프로그램을 가진 것(`fork() + exec()`)이다.
- fork()를 통한 부모 프로세스의 주소 공간에서 새로운 복사본으로 구성하는 방식은 부모와 자식간의 통신을 가능케 한다. fork()의 반환 값은 부모에겐 자식 pid가 자식에겐 0이 반환된다.
- fork() 호출 후에 두 프로세스 중 하나가 자신의 메모리 공간을 새로운 프로그램으로 바꾸기 위해서 exec() 시스템 호출을 사용한다. 이 호출은 이진 파일을 메모리로 적재(이때 exec() 시스템 호출을 포함하는 원 프로그램의 메모리 이미지를 파괴한다.)하고 적재된 프로그램의 실행을 시작한다. 이 방법으로 두 프로세스는 통신을 할 수 있고, 각자의 할일을 한다. 부모는 더 많은 자식을 만들수 있고, 할 일이 없다면 ready 큐에서 자신을 제거하기 위하여 wait()을 호출 한다.

### 프로세스 종료
- 프로세스가 마지막 문장의 실행을 끝내고 exit()을 사용하여 OS에게 자신의 제거를 요청하면 종료한다.
- 자식 프로세스의 경우 부모 프로세스에게 상태 값을 반환할 수 있다.
- 물리 메모리, 가상 메모리등의 프로세스의 모든 자원이 OS로 반납된다.
- 부모 프로세스는 자식 프로세스의 종료를 유발할 수 있다.
- 부모 프로세스가 죽으면 모든 자식 프로세스들은 종료도어야 한다. OS가 시행한다.
- wait()는 부모가 자식들 중에 어느 프로세스가 종료되었는지 알수 있도록, 종료된 자식의 pid를 반환한다. 그러나 부모가 종료하면, 모든 자식은 init 프로세스를 그들의 새로운 부모로 지정받는다.