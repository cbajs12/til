# 분산 파일 시스템
- 분산 시스템이란 통신 네트워크로 연결된 약결함된 기계들의 집합이다. 이러한 컴퓨터들은 물리적으로 퍼져 있는 파일을 분산 파일 시스템(DFS)을 통하여 공유할 수 있다.
- 파일 시스템은 클라이언트에게 파일 서비스를 제공하는 시스템이다. 파일 서비스를 위한 클라이언트 인터페이스는 파일 생성, 파일 삭제 등의 기본적인 파일 연산들의 집합으로 구성되어 있다. 파일 서버가 제어하는 가장 중요한 하드웨어는 보조 저장장치들인데, 사용자의 요청에 의해 이 보조 보조장치에 파일이 저장되고 검색된다.
- DFS는 파일 시스템의 클라이언트와 서버, 저장장치가 분산 시스템의 기계들 사이에 흩어져 있는 형태이다. 따라서 서비스는 네트워크를 통해 실행되며, 자료도 중앙 집중형이 아닌 분산된 다수의 독립적인 저장장치에 저장된다. 분산 파일 시스템의 가장 큰 특징은 시스템 내에 다수 개의 클라이언트와 서버가 존재하고, 각각은 독립적으로 동작한다는 것이다.
- 이상적인 DFS는 클라이언트에게 그 파일 시스템이 전통적인 파일 시스템처럼 보여야 한다. 즉, 지리적으로 분산된 다수의 서버와 저장장치는 클라이언트에게 투명성을 보장해 주어야 한다. 즉, 클라이언트 인터페이스가 지역 파일과 원격 파일에 대해서 동일해야 한다. 또한, DFS는 데이터 전송 시 파일의 위치 결정 및 설정에 대해서도 투명해야 한다. 투명성을 지는 DFS는 사용자가 로그인한 장소에 상관없이 동일한 사용자의 환경을 제공함으로써 사용자 이동성을 제공한다.
- DFS의 가장 중요한 성능의 척도는 이와 같은 다양한 서비스들을 제공하기 위해서 요구되는 지연시간이다. 전통적인 시스템에서 이와 같은 지연시간은 디스크 접근 시간과 중앙처리장치의 처리 시간으로 구성된다. 그러나 DFS의 원격 접근 서비스에는 분산 구조의 특성에 따른 추가 부담이 수반된다. 추가 부담에는 서버에게 요청을 전달하는 데 필요한 네트워크 지연시간과 클라이언트에게 응답하는 네트워크 지연시간이 포함된다. 또한, 각각의 전송 방향에 대해 정보의 실제 전송 시간과 통신 프로토콜의 처리를 위한 CPU의 부하가 추가된다. DFS의 성능은 그 DFS가 제공해야 할 투명성의 또 다른 차원으로 볼 수도 있다.
- DFS가 분산된 저장장치들의 집합을 관리할 수 있다는 사실은 DFS의 가장 주요한 특징이다. DFS에 의해서 운영되는 전체 저장장치 공간들은 서로 다르고 원격에 위치한 작은 크기의 저장장치들로 구성된다. 이렇게 구성된 저장 공간과 파일의 집합들은 일대일로 대응된다. 단일 기계에 저장될 수 있는 최소의 파일 집합을 구성단위라고 한다. 이 구성단위는 다른 단위들과는 독립적으로 저장되고, 같은 구성단위에 속해 있는 파일들은 같은 기계에 위치해야 한다.

## 지명과 투명성
- 지명은 논리 객체들과 물리 객체들 간의 맵핑을 말한다. 물리 데이터 블록은 디스크 블록에 차례로 맵핑되는 저수준의 숫자로 표현된다. 이런 다단계 맵핑은 파일이 실제적으로 어떤 방식으로 어느 위치에 저장되어 있는지에 대한 상세한 정보를 사용자로부터 숨기는 파일의 추상화를 제공한다.
- 투명한 DFS는 네트워크 내에서 파일이 저장되어 있는 위치를 숨기는 추가적인 추상화 기능을 가진다. DFS에서 지명 범위는 파일이 저장된 디스크 내의 주소뿐 아니라, 그 디스크를 소유하는 기계들의 위치까지 포함된다. 추상화를 이용한 파일 처리의 보다 진보된 단계는 파일 중복을 제공하는 것이다. 하나의 파일 이름이 주어졌을 때 지명은 그 파일 이름에 해당하는 중복 파일들의 위치들의 집합을 반환한다. 이런 추상화의 개념을 통해서 여러 개의 복사본들과 그 위치가 감춰질 수 있다.

### 지명 구조
- DFS에서 지명에 관련된 두 가지의 중요 개념은 위치 투명성과 위치 독립성이다.
- 위치 투명성: 파일의 이름이 파일의 물리 저장 위치에 대한 어떠한 정보도 나타내지 않는다.
- 위치 독립성: 파일의 물리 저장장치의 위치가 변경되어도 파일의 이름이 변경되지 않는다.
- 이 두 가지의 정의는 위에서 언급한 지명의 수준에 따라 상대적이다. 이것은 파일들이 수준에 따라 서로 다른 이름을 갖기 때문이다. 즉, 파일은 사용자 수준의 텍스트로된 이름과 시스템 수준의 숫자로 된 식별자를 가진다. 위치 독립적인 지명 기법은 동적 맵핑으로서 동일한 파일 이름을 다른 시점에서는 다른 위치로 맵핑한다. 따라서 위치 독립성은 위치 투명성보다 더 강한 속성을 가진다.
- 파일들은 디스크 블록의 특정 집합과 영구적인 관계를 유지한다. 파일과 디스크가 기계들 사이에서 수동으로 이동될 수는 있으나, 파일 이주는 파일이 OS에 의하여 자동으로 이동됨을 의미한다.
- 위치 독립성에 의한 데이터와 위치의 분리는 더 좋은 파일 추상화를 제공한다. 파일 이름은 파일의 가장 중요한 속성을 표시해야 한다. 속성이란 파일의 위치가 아니라 파일의 내용을 의미한다. 위치 독립적인 파일은 특정 저장장치의 위치와 연관리 없는 논리적인 데이터 용기로 간주된다. 만일 정적 위치 투명성만 지원된다면, 파일 이름은 감춰져 있긴 하지만 특정 물리적 디스크 블록의 집합을 가리킨다.
- 정적 위치 투명성은 사용자에게 편리한 데이터 공유 방법을 제공한다. 위치 투명하게 파일을 지명함으로써 사용자는 파일이 자신의 로컬 저장장치에 있는 것처럼 원격 파일을 공유할 수 있다. 하지만, 논리 파일 이름이 여전히 물리 저장장치와 연관되어 있기 때문에 저장 공간의 공유에 불편이 있다. 위치 독립성은 데이터 객체들과 마찬가지로 저장장치 자체의 공유를 증진시킨다. 파일의 이동성이 제공되면, 전체 시스템의 저장장치 자체의 공유를 증진시킨다. 파일의 이동성이 제공되면, 전체 시스템의 저장장치는 단일의 가상적인 데이터처럼 보인다. 이런 관점에서 얻어지는 이점은 시스템 전체의 디스크 사용을 균등화시킬 수 있다는 점이다.
- 위치 독립성은 저장장치의 계층 구조와 컴퓨터간 계층 구조로부터 지명의 계층을 분리해 준다. 역으로, 정적 위치 투명성이 사용되면, 구성단위와 기계들 사이의 대응 관계를 쉽게 알 수 있다. 이런 기계들은 지명 구조와 유사한 형태로 구성된다. 이것은 시스템 구조를 불필요하게 제한할 수 있으며, 또한 다른 문제를 유발 시킬 수 있다.
- 이름과 위치가 분리되면, 원격 서버에 위치하고 있는 파일이 여러 클라이언트들에 의해서 공유될 수 있다. 실제로 클라이언트들은 로컬 디스크를 가지고 있지 않을 수 있으므로, OS 커널을 비롯해 모든 파일을 서버에게 의존할 수 있다. 하지만, 시스템 부팅을 위해 서버가 커널을 제공하기 위해서는 특수한 프로토콜이 필요하다. 디스크가 없는 시스템은 커널이 없기 때문에 커널을 가져오기 위해 DFS 코드를 사용할 수 없다. 대신 클라이언트의 ROM에 내장되어 있는 특수한 부트 프로토콜이 실행된다. 이 프로토콜은 네트워킹을 가능케 해서 지정된 시스템으로부터 단 한 개의 지정된 파일만을 가져올 수 있따. 커널이 네트워크로 전송되고 클라이언트의 메모리에 적재되면, DFS 코드를 통해 모든 다른 시스템의 파일을 사용할 수 있다. 디스크가 없는 클라이언트는 디스크가 없으므로 비용이 저렴할 뿐만 아니라 OS가 갱신되었을 때 서버만 갱신하면 되므로 편리하다는 장점이 있다. 반면, 복잡한 부트 프로토콜이 추가되어야 하는 부담이 있고, 로컬 디스크를 사용하지 않음으로써 발생되는 네트워크 사용으로 성능이 떨어진다는 단점을 가진다.

### 지명 기법
- DFS의 지명 기법에는 세가지 방법이 있다. 간단한 방법은 파일의 이름을 그들의 호스트 이름과 로컬 이름의 조합으로 구성하는 것이다. 이 방법은 시스템에서 고유한 이름을 보장해 준다. 이런 지명 기법은 위치 투명성도, 위치 독립성도 없다. 그렇지만 동일한 파일 연산이 로컬 또는 원격 파일 모두에 대해 적용될 수 있다. 여기서, DFS는 전통적인 파일 시스템들을 구성단위로 하는 집합으로 구조화된다.
- 두 번째 방법은 NFSv3에 대장화된 방법이다. 이 방법은 원격 디렉터리들을 로컬 디렉터리에 부착할 수 있는 방법을 제공함으로써, 로컬과 원격의 구별없이 일관된 디렉터리 트리를 표현할 수 있도록 한다. 파운트 포인트의 테이블과 파일 구조 명칭을 기반으로 필요시에 마운트가 이루어지게 할 수 있게 되었다. 컴포넌트들은 투명한 공유를 위해서 통합된다. 반면에 이 통합 과정은 각 시스템이 다른 원격 디렉터리를 그 시스템의 트리에 연결시키기 때문에 제한적이며 동일성을 가지지 못한다.
- 세 번째 방법을 이용해서 모든 구성요소 파일 시스템을 통합시킬 수 있다. 여기서는 하나의 전역 이름 구조가 시스템 내의 모든 파일에게 적용된다. 이상적으로 구성된 파일 시스템의 구조는 전통적인 파일 시스템의 구조와 동일한 형태이어야 한다. 그러나 실제로는 이러한 목표를 어렵게 만드는 특별한 파일이 존재한다.

### 구현 기법
- 투명성을 제공하는 지명 기법을 구현하기 위해서 먼저 파일 이름을 대응하는 위치로 맵핑하는 일이 선행되어야 한다. 이러한 맵핑을 유지하기 위해서는 파일의 집합들을 구성단위들로 재구성하고, 단일 파일이 아니라 구성단위 기반의 맵핑을 제공해야 한다. 이러한 재구성은 관리에 사용되기도 한다. UNIX 계열의 시스템은 계층적 디렉터리 트리를 이용해서, 이름-위치 맵핑을 제공하고 또한 파일들을 재귀적으로 디렉터리로 구조화한다.
- 중요한 맵핑 정보의 가용성을 증가시킬 목적으로, 중복, 로컬 캐싱, 또는 두 방법 모두를 사용할 수 있따. 위치 독립성은 시간에 따라 맵핑이 변하는 것을 의미한다. 따라서 맵핑의 중복은 이러한 맵핑 정보를 단순하고 일관성 있게 갱신하는 것을 불가능하게 한다. 이러한 문제를 해결 하기 위해, 저수준의 위치 독립적인 파일 식별자를 도입한다. 텍스트로 된 파일 이름은 그 파일이 속한 구성단위를 지정하는 저수준의 파일 식별자로 맵핑된다. 이 식별자는 여전히 위치 독립성을 유지한다. 이러한 식별자들은 구성단위의 이주에 의해 무효화되지 않으며 중복되거나 캐시될 수 있다. 구성단위를 위치로 맵핑하는, 단순하지만 일관된 갱신 방법을 갖는 두 번째 레벨의 맵핑이라는 대가를 치러야 한다. 이러한 낮은 레벨의 위치 독립적인 식별자를 사용하여 UNIX 비슷한 디렉터리 트리를 구현하면, 구성단위를 이주해도 전체 계층이 변하지 않게 할 수 있다. 오직 구성단위-위치 맵핑만 변할 뿐이다.
- 이러한 저수준의 식별자를 구현하는 일반적인 방법은 구조적 이름을 사용하는 것이다. 이런 이름은 보통 두 부분으로 구성된 비트 스트링이다. 첫 번째 부분은 파일이 속해 있는 구성단위를 식별하고, 두 번째 부분은 단위 내의 특정 파일을 식별한다. 하지만 구조화된 이름들의 변하지 않는 특성은 각 부분들이 나머지 부분이 주어졌을 때 항상 고유하다는 의미이다. 이미 사용되는 파일 이름을 재사용하지 않거나, 충분한 비트로 식별자를 표현하거나, 또는 타임스탬프를 이름의 한 부분으로 사용함으로써 항상 고유성을 얻을 수 있다. 이러한 과정에 대한 또 다른 관점은 위치 투명성을 갖는 시스템에 추상화 레벨을 추가함으로써 위치 독립성을 갖는 지명 기법을 만든다는 것이다.

## 원격 파일 접근
- 지명 기법에 의해 파일을 가지고 있는 서버를 알아낸 후, 원격 접근에 대한 사용자의 요청을 만족시키는 실질적인 데이터 전송이 반드시 일어나야만 한다.
- 이러한 전송 방법 중의 하나로서 `원격 서비스 기법`이 있다. 접근 요청이 서버에 전달되고, 서버가 그 요청을 처리한 후 결과를 사용자에게 돌려준다. RPC는 원격 서비스를 구현하는 가장 일반적인 방법 중 하나이다. 원격 서비스의 이용은 각각의 접근 요청에 대해 한 번의 디스크 접근을 행하는 것과 비슷하다.
- 원격 서비스 기법의 성능을 적당한 수준에서 보장하기 위해 캐싱을 사용할 수 있다. 전통적인 파일 시스템에서 캐싱의 이유는 디스크의 입출력 횟수를 줄임으로써 성능을 향상시키는 것이다. 반면, DFS에서는 네트워크 부하와 디스크 입출력 모두를 줄이는 것이다.

### 기본 캐싱 기법
- 캐싱의 개념은 간단하다. 특정 접근 요청의 대상 데이터가 로컬 메모리에 캐시되어 있지 않으면, 그 데이터의 복사본을 서버에서 클라이언트로 이동시키고, 접근은 캐시도니 복사본 상에서 지역적으로 행해진다. 이것은 캐시가 최근에 사용된 디스크 블록을 갖게하는 개념으로, 같은 정보에 대한 반복된 사용은 네트워크의 추가 전송없이 지역적으로 처리될 수 있따. 교체 기법이 캐시의 크기를 제한하기 위해 사용된다. 캐시를 사용함으로써, 파일의 사용이 항상 서버로의 네트워크 교통을 유발하는 것은 아니다. 파일은 여전히 서버가 가지고 있는 마스터 복사본으로서 식별되지만 파일의 복사본이 여러 캐시에 흩어져 있다. 캐시된 복사본이 변경되면, 변경된 내용은 마스터 복사본에 반영시켜 일관성을 유지해야 한다. 캐시된 복사본의 내용과 마스터 복사본 간의 일관성을 유지하는 문제를 캐시 일고나성 문제라 한다. DFS 캐싱은 네트워크 가상 저장장치라고 불릴 수 있는데, 실제 저장 장소가 로컬 디스크가 아니라 원격 서버라는 것을 제외하면 요구 페이지 가상 메모리와 비슷하게 동작한다. NFSv3는 스왑 공간이 원격으로 마운트될 수 있도록 해준다. 이러한 방법을 통하여 성능면에서의 불리함에도 네트워크를 통한 가상 메모리를 구현하는 것이다.
- 캐시 단위의 크기는 파일의 블록에서 전체 파일에 이르기까지 크기가 다양하다. 보통, 데이터는 한 번의 사용을 위해 필요한 양보다 더 많은 양을 캐시함으로써 여러 번의 요청이 캐시된 데이터에 의해 서비스도리 수 있다. 이것은 디스크 미리 읽기와 유사하다. AFS 시스템은 청크(64K) 단위로 파일을 캐시하고 다른 시스템들은 보통 클라이언트가 요청한 단위 블록들을 캐시한다. 캐싱 단위의 크기가 클수록 적중률은 증가하지만, 실제 데이터 전송 시간이 지연되고 일관성 문제가 심각해진다. 캐싱 단위를 결정하기 위해서는 네트워크의 전송 단위와 RPC 프로토콜의 서비스 단위를 고려해야 한다. 네트워크 전송 단위는 약 1.5K이므로, 캐싱 단위가 그것보다 크면 그 데이터 단위는 전송 시에 분리되고 수신시에 다시 재결합된다.
- 블록의 크기와 전체 캐시의 크기는 블록 캐싱 기법에서 중요한 요소이다. UNIX 시스템에서 일반적인 블록의 크기는 4/8KB이다. 캐시의 크기가 크면 큰 블록이 적당하다. 반면, 캐시의 크기가 작을 경우 캐시에 저장될 수 있는 블록의 개수가 줄고 따라서 적중률이 낮아지므로 블록의 크기를 크게 하는 것은 효율적이지 못하다.

### 캐시 위치
- 디스크 캐시는 메모리 캐시에 비해 더 안전하다는  장점을 가지고 있다. 데이터가 디스크에 캐시되었다면, 시스템 결함이 발생하더라도 디스크에 여전히 존재하므로 서버에서 다시 가져올 필요가 없다. 반면 메모리 캐시는 시스템이 디스크 없는 워크스테이션을 허용하고, 디스크 캐시보다 빠르다. 또한, 디스크의 입출력 속도 향상을 위한 서버 캐시는 사용자 캐시의 위치에 관계없이 항상 메모리에 있다. 클라이언트가 메모리 캐시를 사용하면, 서버와 클라이언트가 함께 사용할 수 있는 단일 캐싱 기법을 구축할 수 있다.
- NFSv3는 원격 서비스에 기반을 두고 성능 향상을 목적으로 클라이언트 및 서버 쪽에 메모리 캐시를 보강한다. NFSv3 프로토콜과 대부분의 구현은 디스크 캐싱을 제공하지 않는다. 최근의 NFS는 클라이언트 측 디스크 캐싱 옵션인 cachefs 파일 시스템을 포함하고 있다. 일단 NFS 클라이언트가 서버로부터 파일의 블록들을 읽으면 그것을 디스크는 물론 메모리에 캐시한다. 메모리 복사본이 플러시되거나 시스템이 재부트할 때도 디스크 캐시가 참조된다. 만일 필요한 블록이 메모리나 디스크 캐시인 cachefs에 없으면 서버에 RPC를 보내어 블록을 가져와서 클라이언트의 디스크 캐시와 메모리 캐시에 쓴다.

### 캐시 갱신 정책
- 가장 간단한 전략으로는 데이터가 어떤 캐시에서 수정되는 순간에 디스크에 기록하는 것이다. 이와 같은 바로 쓰기의 장점은 신뢰성이다.이 전략은 시스템 손상시 손실되는 정보는 거의 없지만, 데이터를 변경할 때마다 변경된 데이터가 서버에 보내질 때까지 기다려야 하므로 쓰기 성능이 떨어진다. 바로 쓰기 방식에서 캐싱은 쓰기 접근에 대해서는 원격 서비스와 동일하고, 일기 접근에 대해서만 캐싱의 이점을 누린다.
- 대안으로 지연 쓰기 전략이 있다. 이것은 마스터 복사본으로의 반영을 지연시키는 전략이다. 변경된 데이터는 캐시에 쓰이고 나중에 서버로 보내진다. 즉, 쓰기 접근 시 데이터가 서버로 보내질 때까지 기다리지 않는다. 쓰기가 캐시에서 실행되기 때문에 쓰기 접근이 훨씬 빠르다. 데이터는 이들이 마스터 복사본에 반영하지 않고 여러 번 변경될 수 있으므로, 오직 마지막 변경된 데이터만 서버로 보내진다. 하지만 지연 쓰기 기법은 신뢰성 문제를 초래할 수 있는데, 클라이언트 시스템이 손상되었을 때는 서버에 반영되지 않은 모든 데이터를 손실할 수 있기 때문이다.
- 여러 변현된 지연 쓰기 기법들이 있다. 한 가지 방법은 클라이언트의 캐시에서 쫓겨나는 블록을 서버로 보내 복사본에 반영시키는 것이다. 이 방식은 성능을 높일 수 있지만, 어떤 블록들은 서버에 반영되지 않은 채 너무 긴 시간동안 클라이언트 캐시에서 머무를 수 있다. 이 기법과 바로 쓰기의 절충안으로 정기적으로 캐시를 조사하여 최근 조사 이후의 갱신된 모든 블록을 서버에 반영시키는 방법이 있다. NFSv3 파일 데이터에 대해서 30초 간격으로 캐시의 변견된 데이터를 서버로 보낸다. 그러나 캐시 내용을 서버의 디스크에 반영하고 있는 동안에 요청된 쓰기는 서버에 바로 반영시킨다. NFSv3는 또한 메타데이터는 다르게 처리한다. 메타데이터의 변경은 서버와 동기화한다. 따라서 클라이언트나 서버 결함 시에 파일 손실과 디렉터리-구조 손상을 막을 수 있다.
- cachefs를 갖는 NFS의 경우 쓰기는 이들이 서버에 쓰일 때 아울러 로컬 디스크 캐시에도 쓰이며, 이는 모든 복사본의 일관성을 유지하게 한다. 따라서 cachefs를 갖는 NFS는 일반 NFSv3에 비해 cachefs에서 적중이 되는 읽기 요구는 성능이 좋지만 캐시 미스가 일어나는 읽기와 쓰기의 성능은 떨어진다.
- 지연 쓰기의 다른 변형 기법으로 파일이 닫힐 때 데이터 블록을 서버에 반영하는 방식이 있다. 이 닫을 때 쓰기 전략은 AFS에서 사용하고 있다. 짧은 시간 동안 열려 있는 파일이나 거의 변경되지 않는 파일에 대해서 이 전략은 네트워크의 교통량을 많이 줄이지 못한다. 더구나 닫을 때 쓰기 전략은 파일의 반영이 진행되는 동안에 그 프로세스의 닫기를 지연시키기 때문에 지연 쓰기의 장점을 감소시킬 수 있다. 그러나 오랜 동안 열려 있으면서 자주 갱신되는 파일에 대해서는 지연 쓰기에 비해 서버로의 반영이 드물게 일어나므로 성능을 높일 수 있다.

### 일관성
- 클라이언트 시스템은 로컬 캐시의 데이터가 마스터 복사본과 일치하는지를 결정해야 한다. 캐시된 데이터가 서버의 데이터와 일치하지 않으면, 클라이언트 시스템에 캐시된 데이터에 접근해서는 안된다. 즉, 캐시된 데이터가 가장 최신 데이터라는 것이 보장되어야 한다.
- 클라이언트 주도 방식: 클라이언트가 서버와의 접촉을 시도해서 로컬 데이터가 마스터 복사본과 일치하는 지를 검사한다. 유효성 검사의 빈도가 이 방식에서 가장 중요한 요소이며, 일관성의 강약을 결정한다. 유효성 검사는 많게는 매 접근 시에 일어날 수도 있고, 적게는 파일로의 첫 번째 접근 시에 일어날 수도 있다. 유효성 검사 중에 요청되는 모든 접근은 지연된다. 대안으로, 검사를 지정된 시간 구간마다 시작시킬 수도 있다. 검사 빈도가 잦을수록 유효성 검사가 네트워크와 서버 모두에게 더 많은 부담을 주게 된다.
- 서버 주도 방식: 서버는 각 클라이언트가 캐시한 파일에 대한 정보를 기록한다. 서버는 잠재적인 불일치를 감지했을 때 대응을 시작한다. 두 개의 다른 클라이언트가 한 개의 파일을 충돌모드로 캐시했을 때 불일치가 일어날 가능성이 있다. UNIX 시맨틱이 구현되었다면, 서버가 주체적인 역할을 하도록 함으로써 잠재적인 불일치를 해결할 수 있다. 파일이 열릴 때 마다 요청 모드가 서버에게 알려져야 한다. 그러한 정보가 서버에게 알려진다면, 서버는 요청 모드의 충돌 여부를 판단할 수 있고 충돌이 감지되면 그 파일의 캐싱을 무효화시킨다.

### 캐싱과 원격 서비스의 비교
- 많은 원격 접근은 캐싱이 사용될 때 로컬 캐시에 의해서 효율적으로 처리될 수 있다. 파일 접근 패턴에서의 높은 지역성은 캐싱을 더욱 효과적으로 만든다. 따라서 대부분의 원격 접근은 지역 접근만큼 빠르게 제공될 수 있다. 더구나 서버와의 통신도 빈번하지 않게 된다. 결과적으로 서버 부하와 네트워크의 통신량은 감소되며, 규모 가변성은 증가한다. 이와 대조적으로, 원격 서비스 방식이 사용되면 모든 원격 접근은 네트워크를 통해서 처리된다.
- 대량의 데이터를 한 번에 전송할 때의 네트워크 부담이 개개의 접근 요청에 대한 소량의 데이터를 여러 번 전송할 때의 네트워크 부담보다 적다. 더구나 요청되는 데이터 블록이 임의의 디스크 블록이 아니고 크고 연속적인 데이터 세그먼트라면, 서버의 디스크 접근 루틴이 훨씬 최적화될 수 있다.
- 캐시 일관성 문제는 캐싱의 가장 큰 단점이다. 쓰기 요청 빈도가 적을 때는 캐싱이 우수하지만, 쓰기의 빈도가 많은 때는 일관성 문제를 해결하기 위한 기법들이 성능과 네트워크 교통량, 서버 부하에 있어서 심각한 부담을 초래할 수 있다.
- 캐싱은 로컬 디스크 또는 큰 메모리 가진 시스템에 적합하다. 그렇지 않은 시스템은 원격 서비스 방식을 통해서 원격 접근을 실행해야 한다.
- 캐싱에서 데이터는 특정 파일 연산의 요청에 대한 응답 형태가 아니라 서버와 클라이언트 간에 집단으로 전달되기 때문에 하위수준의 기계간 인터페이스가 상위수준의 사용자 인터페이스와 다르다. 반면에 원격 서비스 패러다임은 네트워크 전체를 아우르는 로컬 파일 시스템 인터페이스의 확장이라 할 수 있다. 따라서 기계간 인터페이스는 사용자 인터페이스와 일치한다.

## 상태형 대 무상태형 서비스
- 상태형 서비스는 서버가 각 클라이언트가 사용하고 있는 파일들의 목록을 유지하는 것이다. 비상태형 서비스는 파일 사용에 대한 정보를 기록하지 않고 클라이언트가 요구하는 블록을 제공해 주는 것이다.
- 상태형 파일 서비스의 시나리오는 클라이언트가 파일에 접근하기 전에 파일을 여는 것으로 시작한다. 서버는 자신의 디스크로부터 파일에 대한 정보를 가져오고, 이것을 자신의 메모리에 저장한다. 그리고 클라이언트에게 클라이언트와 그 클라이언트가 연 파일에 대해 고유한 연결 식별자를 배정한다(UNIX에서는 서버는 inode를 가져와서 클라이언트에게 이 파일의 식별자를 보낸다. 이 파일의 식별자는 메모리 내의 inode 테이블에 대한 색인으로 사용된다). 이 식별자는 그 세션이 끝날 때까지 그 파일로의 접근을 위해 사용된다. 상태 정보를 가진 서비스는 한 세션 동안의 클라이언트와 서버간의 열결이라고 할 수 있다. 파일을 닫을 때 또는 가비지 컬렉션에 의해 서버는 활동하지 않는 클라이언트가 사용했던 메모리 공간을 되돌려 받아야 한다. 상태 정보를 가진 서비스 접근 방법에서 결함 허용을 고려할 때 중요한 점은 클라이언트에 대한 정보가 서버의 메인 메모리에 유지된다는 것이다.
- 무상태형 파일 서비스에서는 각 요청이 더 많은 정보를 제공하게 함으로써 서버쪽에서는 상태정보를 유지할 필요가 없다. 즉, 각 요청은 파일과 파일의 위치 모두를 가지고 있다. 효율성 때문에 열린 파일에 대한 테이블을 메모리에 유지하기는 하지만, 무상태형 파일서버에서는 열린 파일에 대한 테이블을 유지할 필요는 없다. 또한, 파일 열기와 닫기 동작에 의해 연결을 설정하거나 종료할 필요도 없다. 각 파일 연산은 하나의 독립적 연산으로 실행될 수 있으며, 세션의 일부로 간주되지는 않는다. 클라이언트 프로세스가 파일을 열 때, 이 연산은 어떤 원격 메시지도 발생시키지 않는다. 물론 읽기와 쓰기는 원격 메시지를 발생시킬 것이다. 하지만, 클라이언트에 의한 파일 닫기는 단지 지역적으로 실행될 것이다.
- 상태형 서비스가 무상태형 서비스에 비행 좋은 점은 성능이 우수한 점이다. 파일 정보가 주 메모리에 캐시되고 연결 식별자를 통해 쉽게 접근될 수 있어 디스크 접근을 줄인다. 또한, 상태형 서버는 파일이 순차 접근을 위해 열렸는지를 알 수 있으며 그 경우 다음 블록을 미리 읽어 올 수 있다. 무상태형 서버는 클라이언트의 요구에 대한 지식이 없어서 불가하다.
- 서비스가 제공되는 동안 시스템에 고장이 발생했을 때 상태형 서비스와 무상태형 서비스의 차이는 명백하다. 상태형 서버는 고장 시 메모리 상의 모든 상태 정보를 잃는다. 이러한 서버의 완전한 복구를 위해 보통은 클라이언트와의 통신에 기반을 둔 복구 프로토콜을 사용한다. 완전한 복구를 하지 않을 경우 적어도 고장이 발생할 때 진행 중이던 연산들은 취소되어야 한다. 클라이언트의 고장에 의해서도 문제가 발생한다. 서버는 고장난 클라이언트 프로세스 상태를 위한 메모리 공간을 재사용하기 위해서 그 고장을 알아야 한다. 이러한 현상을 고아 탐지 및 제거라고 한다.
- 무상태형 서버는 이러한 문제를 피할 수 있는데, 요청이 상태 정보를 갖고 있으므로 새로운 서버는 특별한 어려움 없이 그 요청에 대해 응답할 수가 있기 때문이다. 따라서 서버 고장과 복구에 대해 클라이언트는 거의 알아차리지 못한다. 즉, 클라이언트 입장에서는 서버의 속도가 느린 것인지 서버가 복구 중인지를 구별하지 못한다. 클라이언트는 응답을 받지 못했다면 자신의 요구를 계속 재전송한다.
- 무상태형 서비스의 단점은 요청 메시지가 길고, 또한 요청에 대한 처리가 느리다는 점이다. 이는 처리 속도를 증가시킬 수 있는 핵심적인 정보를 서버가 가지고 있지 않기 때문이다. 또한 무상태형 서비스는 분산 파일 시스템의 설계 시에 추가적인 제약을 가진다. 첫째, 각 요청이 대상 파일을 지정하기 때문에 동일한 범시스템의 저수준 지명 기법이 사용되어야 한다. 각 요구에 대해 원격 이름의 지역 이름으로의 변환은 요청에 대한 처리를 지연시킨다. 둘째, 클라이언트는 파일 연산에 대한 요청을 재전송할 수 있으므로, 파일 연산들이 멱등이어야 한다. 즉, 파일 연산이 연속적으로 여러 번 실행되더라도 같은 효과와 같은 결과를 반환해야 한다. 접근하는 블록의 위치를 절대 바이트로 표현하고 오프셋에 의존하지 않게 하면, 읽기와 쓰기 연산은 멱등이다. 그러나 파일 삭제와 같은 명령을 멱등으로 만들려면 구현시 주의를 해야 한다.

### NFSv4
- 버전 3과 버전 4의 중요한 차이는 프로토콜이 상태형으로 변했다는 것이다. 이는 서버가 원격 파일이 클라이언트에 의해여 열릴 때부터 닫힐 때까지 클라이언트 세션을 유지한다는 것이다. 버전 4는 원격 파일 시스템을 마운트하거나 원격 파일을 잠그기 위해서 단일화된 하나의 프로토콜을 제공한다. 특히, 마운트 포로토콜이 없어져 NFS가 네트워크 방화벽에서도 잘 동작하게 해준다. 추가적으로 지역 파일 정보를 클라이언트가 캐시하는 능력이 향상되엇다. 클라이언트가 원격 파일에 덜 접근할 수 있도록 함으로써 전체 분산 파일 시스템의 성능을 끌어올린다. 버전 4는 클라이언트가 서버로부터도 파일 잠금을 할 수 있게 한다. 만일 서버가 이러한 요청을 보증한다면, 클라이언트는 해당 요청이 무효화되거나 만료될 때까지 잠금 상태를 유지한다. 전통적으로 UNIX 기반의 시스템들은 윈도우 시스템이 제공하는 강제 잠금 이외에도 매우 다양한 종류의 파일 잠금 기법을 제공한다. 새로운 잠금과 캐싱 기법들은 권한 위임이라는 개념을 그 골자로 한다. 이는 서버가 파일에 대한 잠금 권한을 그 작업을 요청한 클라이언트에 넘김으로써 성립된다. 권한을 위임 받은 클라이언트는 그 권한을 포기하기 전까지 캐시에 현재 파일 버전을 유지하고, 그 기간 동안 다른 클라이언트들은 본 클라이언트에게 잠금이나 파일 액세스에 관한 작업을 요청할 수 있다.
- 그전 버전들의 UDP와 달리, 버전4는 TCP를 사용한다. 이는 네트워크 트래픽에 대해서 좀 더 융통성 있게 대처할 수 있게 해준다. 이러한 권한을 클라이언트에게 위임하는 방식으로 서버의 부하를 줄이고, 캐시의 일관성을 향상시킨다.

## 파일 중복
- 여러 기계에 파일을 중복시키는 것은 전체 시스템의 가용성을 증가시킨다. 이러한 중복은 성능 면에서도 이점이 있는데, 그것은 접근 요청에 대해 가장 가까운 복사본을 선택함으로써 서비스 시간을 더 줄일 수 있기 때문이다.
- 중복 기법은 같은 파일의 복사본들을 고장에 대해 서로 독립적인 여러 기계에 둔다. 즉, 복사본의 가용성은 나머지 복사본의 가용성에 의해 영향을 받지 않는다. 이것은 중복 관리가 근본적으로 위치에 무관하지 않음을 의미한다. 따라서 특정 기계에 복사본을 배치하는 것이 반드시 가능해야 한다.
- 사용자에게 중복에 대한 세부적인 내용을 숨기는 것은 바람직하다. 이를 위해서 중복된 파일의 이름을 특정 복사본으로 맵핑시키는 지명 기법이 필요하다. 복사본이 있다는 사실을 고수준에서는 알지 못하지만 저수준의 이름들에 의해서는 서로 구분되어야 한다. 또는, 고수준에서 중복을 제어하는 것을 허용할 수도 있다. 중복 제어는 중복의 수준을 결정하고 복사본의 위치를 결정하는 것이다. 어떤 환경에서는 사용자에게 중복의 세부사항을 보여주는 것이 바람직하다.
- 복사본과 관련되어 발생되는 가장 큰 문제점은 복사본을 갱신하는 것이다. 사용자의 관점에서 파일의 복사본은 논리적으로 동일해야 하므로, 임의 복사본에 대한 갱신은 모든 다른 복사본에게 반영되어야 한다. 본사본에 대한 접근이 복사본의 논리적인 파일에 대한 가상 접근이라는 관점을 고수한다면, 그에 합당하는 일관성이 보존되어야 한다. 일관성이 중요하지 않다면, 이는 가용성과 성능을 위해 희생될 수 있다. 많은 비용을 들여 일관성을 유지하는 방법과 프로세스의 계속적인 진행을 보장하기 위해 일관성을 희생시키는 방법이다. 전자는 프로세스의 무한정 대기 상황을 유발할 수 있고, 후자는 내용이 다른 복사본의 동시 접근에 의해 오류가 발생할 수 있다.
