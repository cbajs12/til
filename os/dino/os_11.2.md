# 파일 시스템 구현

## 할당 방법
- 디스크의 직접 접근 특성이 파일의 구현에 융통성을 허용한다. 거의 모든 경우에 많은 파일이 같은 디스크에 저장된다. 주요 문제는 파일들을 어떻게 디스크 공간에 배치해야 디스크 공간을 효율적으로 사용할 수 있고, 파일들에 빨리 접근할 수 있는가 하는 것이다. 
- 디스크 공간 할당 방법에는 연속, 연결 그리고 인덱스 기법이 널리 사용되며 각 방법마다 장/단점이 있다. 몇몇 시스템들은 세 가지 모두를 제공하지만, 한 가지 파일 시스템 유형 안에서는 한 가지 방법만을 제공한다.

### 연속 할당
- 연속 할당 방식은 각 파일이 디스크 내에서 반드시 연속적인 공간을 차지하도록 할당한다. 디스크 주소들은 디스크 상에서 선형 순서를 정의한다. 이러한 순서를 따를 경우, 오직 한 작업만이 디스크에 접근한다고 가정하고, 블록 b 다음에 블록 b+1에 접근한다면 통상 헤드 이동을 필요로 하지 않는다. 헤드의 이동이 필요할 경우 단지 한 트랙만 이동하면 된다. 따라서 연속 할당된 파일들에 접근하기 위해서 필요한 디스크 탐색의 횟수를 최소화시킬 수 있으며, 결국 탐색이 필요할 경우라도 탐색시간이 최소화된다.
- 한 파일의 연속 할당은 첫 번째 블록의 디스크 주소와 블록 단위의 길이로 정의된다. 각 파일을 위한 디렉터리 항목은 이 파일의 시작 블록 주소와 이 파일에 할당된 영역의 길이만 표시하면 된다.
- 연속적으로 할당된 파일에 접근하는 것은 쉽다. 순차적으로 접근하려면 파일 시스템은 마지막으로 참조된 주소를 기억하고 있다가 필요할 때 다음 블록을 읽어 들이면 된다. 그래서 연속 할당 기법은 순차 접근과 직접 접근, 두 가지 모두를 지원할 수 있다.
- 그러나 연속 할당 기법은 몇 가지 문제점을 가지고 있다. 연속 할당 기법에서 한 가지 여러운 점은 새로운 파일을 위한 가용 공간을 찾는 일이다. 선택된 가용 공간 관리 기법이 가용 공간을 찾는 방법을 결정한다.
- 연속 할당 문제는 `동적 공간 할당` 문제의 특정 응용으로 볼 수 있다. 일반적인 동적 공간 할당 문제는 가용 구멍의 리스트가 주어졌을 때, 크기 n인 할당 요청을 어떻게 만족시킬 것인가와 연관된다. 최초 적합과 최적 적합이 가용 구멍의 집합 중에서 할당할 공간을 선택하는 가장 일반적인 전략이다.
- 이들 알고리즘들은 모두 외부 단편화의 문제가 있다. 파일이 할당되고 반납됨에 따라 가용 디스크 공간이 조그만 조각으로 나누어진다. 외부 단편화는 가용 공간이 덩어리들로 나누어질 때마다 발생한다. 그러다가 제일 큰 연속된 덩어리가 요구된 크기보다 작을 때 문제가 된다. 이제 저장 공간이 여러 개의 구멍으로 나누어져 있고 이들 중 어떤 것도 크기가 작아 데이터를 저장하지 못한다. 디스크 공간의 전체 크기와 평균 파일 크기에 따라 외부 단편화가 작은 문제 또는 큰 문제가 된다.
- 외부 단편화로 인한 공간의 상당한 양의 공간 손실을 방지하는 하나의 정책은 전체 파일 시스템을 다른 디스크로 복사하는 것이다. 원래의 디스크는 완전히 자유화 되어 하나의 커다란 연속적인 가용공간이 된다. 그런 후에 이 공간으로부터 할당받으면서 파일들을 원래의 디스크로 다시 복사하게 된다. 이 기법은 효과적으로 모든 가용 공간을 하나의 연속공간으로 압축함으로써 단편화 문제를 해결한다. 그러나 이 압축의 비용은 장시간에 걸쳐 행해져야 한다는 것으로 연속 할당을 사용하는 대용량 HDD의 경우 압축은 몇 시간씩 걸릴 수 있으며, 또 이 작업을 주 단위로 해야 하기 때문에 심각한 오버헤드를 발생시킬 수 있다.
- 연속 할당의 또 다른 문제점은 파일을 위해서 얼마나 많은 할당해야 할지를 결정하는 것이다. 파일이 생성될 때 앞으로 필요하게 될 공간의 크기를 알아내어 할당해주어야만 한다.
- 만약에 너무 작은 공간을 예약했다면 파일이 커질 수 없다. 특히, 최적 적합 방법으로 공간을 할당했다면 양 끝에 인접한 공간이 모두 사용중이기 때문에 파일을 그 자리에서 확장시킬 수 없다는 것을 알 수 있다. 이에 대한 해결 방법으로는 두 가지 방법이 있는데, 첫째는 확장이 안 될 경우 사용자에게 오류 메시지를 출력하고 프로그램을 종료시키는 방법이다. 이때에는 사용자가 더 많은 공간을 할당받아 프로그램을 다시 실행시켜야 한다. 이러한 반복된 실행은 비용이 크며, 이를 방지하기 위해 사용자는 통상 필요한 공간을 지나치게 크게 추정하여 공간의 낭비를 낳게 될 것이다. 또 다른 방법은 보다 큰 조각을 찾아 그곳으로 파일을 복사하고 이전의 공간을 자유화하는 방법이다. 이러한 일련의 작업은 시간이 걸리긴 하지만 공간이 존재하는 한 반복될 수 있다. 따라서 사용자에게는 알리지 않지만 시스템이 점점 더 느려질 것이다. 한 파일이 필요로 하는 공간의 크기를 미리 알 수 있다 해도 선 할당은 비효율적이다. 
- 이런 단점들을 최소화하기 위해서 많은 OS는 변형된 연속 할당 기법을 사용한다. 이 기법은 어느 정도의 연속된 공간만 초기에 할당하고 그 양이 충분히 크기 않을 때, 추후 또 다른 연속된 공간을 익스텐트라고 부르는 단위로 할당한다. 파일 블록들의 위치는 위치와 블록 수, 그리고 다음 익스텐트의 첫 블록을 가리키는 포인터로 기록된다. 일부 시스템에서는 파일의 소유자가 익스텐트의 크기를 정할 수 있으나, 소유자가 틀렸을 경우 비효율을 초래한다. 익스텐트의 크기가 너무 크면 내부 단편화 문제는 여전히 남아 있고, 다양한 크기의 익스텐트가 할당 반환을 계속하게 되면 외부 단편화가 문제가 될 수 있다.

### 연결 할당
- 연결 할당은 연속 할당의 모든 문제를 해결한다. 연결 할당에서 파일은 디스크 블록의 연결 리스트이고 디스크 블록은 디스크의 어느 곳에도 산재할 수 있다. 디렉터리는 파일의 첫 번째와 마지막 블록을 가리키는 포인터를 가지고 있다. 각 블록이 다음 블록에 대한 포인터를 포함하고 있다. 이들 포인터는 사용자가 사용할 수 없다.
- 새 파일을 생성하려면 단순히 디렉터리 내에 새로운 항목을 만들면 된다. 연결 할당의 경우 각 디렉터리 항목은 파일의 첫 디스크 블록을 가리키는 포인터를 갖고 있다. 이 포인터는 처음에는 빈 파일을 표시하기 위해 nil값으로 초기화된다. 크기 필드 역시 0으로 설정된다. 파일 쓰기가 일어나면 가용 블록을 할당받아 쓰기를 실행한 후 파일의 끝에 연결한다. 파일을 읽기 위해서는 블록에서 블록으로 포인터를 따라가면서 읽으면 된다. 연결 할당의 경우 외부 단편화가 없고 가용 공간 리스트의 어떠한 가용 블록들이 할당되어도 무방하다. 파일 생성 시 생성할 파일의 크기가 미리 지정될 필요도 없다. 가용 블록이 존재하는 한 파일은 계속해서 커질 수 있으며 디스크 공간을 밀집화할 필요도 없다.
- 그러나 이 방법도 단점을 가지고 있다. 가장 중요한 단점은 순차 접근 파일에만 효과적이라는 것이다. 특정 블록을 찾으려면 그 파일의 처음부터 시작해서 특정 블록에 도달할 때까지 포인터를 따라가야 한다. 포인터를 접근할 때마다 한 번의 디스크 읽기와 여러 번의 디스크 탐색이 필요하다. 따라서 연결 할당 파일을 기반으로 직접 접근 가능하게 하는 것은 비효율적이다. 연결 할당의 또 다른 단점은 포인터들을 위한 공간이 필요하다는 것이다.
- 이 문제의 보통 해결 방법은 여러 블록들을 하나의 클러스터로 구성하여 클러스터 단위로 할당하는 것이다. 예를 들면, 파일 시스템이 4블록을 하나의 클러스터로 정의하고 디스크에 대한 작업은 클러스터 단위로만 한다. 이 경우 파일의 디스크 공간에서 포인터가 차지하는 비율이 훨씬 작아진다. 이 방법은 논리 블록에서 물리 블록으로의 맵핑을 여전히 단순하게 하면서 디스크 처리량을 향상시키고, 블록 할당과 가용 리스트 관리에 필요한 공간을 줄인다. 이 방법의 단점은 내부 단편화의 증가이다. 블록이 덜 채워졌을 때보다 클러스터가 덜 채워졌을 때 공간의 낭비가 더 크기 때문이다. 클러스터는 또한 여러 알고리즘에서 디스크 접근 시간을 향상시키기는 때문에 대부분의 파일 시스템들이 이를 사용한다.
- 또 다른 문제는 신뢰성 문제이다. 각 블록들이 전체 디스크에 흩어져 있는 포인터에 의해 연결되어 있다. 그러나 포인터가 없어지거나 망가지는 오류가 생긴다면, 포인터는 가용 공간 리스트 또는 다른 파일의 연결할 수 있다. 한 가지 부분적인 해결책은 이중 연결 리스트를 사용하는 것이고, 다른 하나는 각 블록마다 파일 이름과 상대 블록 번호를 저장하는 것이다. 이러한 기법들은 파일마다 더 많은 오버헤드를 필요로 한다.
- 연결 할당의 한 가지 중요한 변형은 파일 할당 테이블(FAT)을 사용하는 것이다. 단순하지만 효율적인 방법이다. 각 볼륨의 시작 부분의 일부가 FAT로 사용된다. 이 FAT 테이블은 각 디스크 블록마다 한 개의 항목을 가지고 있고 이 항목은 디스크 블록 번호를 인덱스로 삼아 찾는다. FAT는 연결 리스트와 마찬가지 방식으로 사용된다. 디렉터리의 항목은 각 파일의 첫 번째 블록 번호를 저장한다. 그 블록 번호가 인덱싱하는 FAT 테이블 항목은 파일의 다음 블록 번호를 가리킨다. 이러한 사슬은 마지막 블록까지 계속되며, 마지막 블록의 테이블 항은 파일의 끝을 나타내는 특수한 값을 갖고 있다. 미사용 블록은 0으로 표시한다. 파일에 새로운 블록을 할당하는 일은 단순히 값이 0인 첫 번째 테이블 항을 찾아 이전 파일의 끝 값을 이 새로운 블록의 주소로 대체하면 된다. 이어 0을 파일의 끝 값으로 대체한다.
- FAT 할당 기법은 FAT가 캐시되지 않으면 상당한 수의 디스크 헤드 탐색을 유발할 수 있다. FAT를 읽어 원하는 블록의 주소를 알아내기 위해서는 디스크 헤드를 볼륨의 시작 부분으로 이동시키야만 하고, 그런 후에는 블록을 읽기 위해 블록 위치로 이동시켜야 한다. 최악의 경우 각 블록을 찾을 때마다 두 번의 이동이 일어나야 한다. 장점은 무작위 접근 시간이 개선된다는 것이다. 왜냐면 디스트 헤드가 FAT의 정보를 읽어 임의의 블록의 위치를 알아낼 수 있기 때문이다.

### 색인 할당
- 연결 할당은 연속 할당의 외부 단편화 문제와 파일 크기 선언 문제를 해결했다. FAT가 없으면 연결 할당은 직접 접근을 효율적으로 지원할 수 없다. 블록을 가리키는 포인터가 블록들과 함께 디스크에 흩어져 있고, 순서대로 접근할 수밖에 없기 때문에 색인 할당은 모든 포인터들을 한 군데, 즉 색인 블록으로 모아 놓음으로써 이 문제를 해결한다.
- 각 파일들은 디스크 블록 주소를 모아놓은 배열인 색인 블록을 가진다. 색인 블록의 특정 항목은 파일의 특정 블록을 가리킨다. 디렉터리는 색인 블록의 주소를 가지고 있다. 특정 블록을 읽기 위해서는 색인 블록 항목에 있는 항목에서 포인터를 얻어서 그 블록을 읽는다. 이러한 기법은 페이징 기법과 유사하다.
- 파일이 생성될 때 색인 블록의 모든 포인터는 nil로 설정된다. 특정 블록이 처음 쓰이면, 가용 블록 관리자로부터 한 블록을 할당 받아 그 주소를 색인 블록의 특정 항에 기록한다.
- 색인 할당은 외부 단편화 없이 직접 접근을 제공한다. 디스크의 가용 블록 어느 것이라도 크기 확장 요청을 만족시킬 수 있기 때문이다. 그러나 색인 할당은 공간의 낭비가 문제이다. 색인 블록의 포인터 오버헤드는 연결 할당의 포인터 오버헤드보다 크다. 파일들이 대부분 하나 또는 두 개의 블록만으로 이루어진 보통의 경우, 연결 할당의 경우, 블록 당 하나의 포인터만큼 공간을 손해 본다. 색인 할당의 경우, 하나 또는 두 개의 포인터만이 nil이 아닌 값이 기록되더라도 전체 인덱스 블록이 할당되어야 한다.
- 여기서 색인 블록이 얼마나 커야 하는지가 문제가 된다. 각 파일들은 하나의 색인 블록을 가져야 하므로, 색인 블록의 크기는 가능한 한 작은 것이 좋다. 그러나 만약 색인 블록이 너무 작다면 큰 파일들에 대해서 충분한 포인터 공간을 가질 수가 없을 것이다. 이 문제를 해결하기 위한 기법들이 있다.
- 연결 기법: 하나의 색인 블록은 통상 한 디스크 블록이다. 따라서 단독으로 읽히거나 쓰일 수 있다. 파일의 크기가 크면 여러 개의 색인 블록들을 연결시킨다. 예를 들면, 한 색인 블록이 파일의 이름을 나타내는 헤더와 첫 100개의 디스크 블록 주소를 포함할 수 있다. 다음 주소는 작은 파일의 경우 nil, 큰 파일의 경우 다른 색인 블록에 대한 포인터가 된다.
- 다중 수준 색인: 연결 방식의 변형은 1차 단계 색인 블록이 2차 단계 색인 블록의 집합을 가리키고, 다시 2차 단계 색인 블록이 파일 블록을 가리키게 하는 방식이다. 블록을 접근하기 위해 OS는 1차 단계 색인을 이용하여 2차 단계 색인 블록을 찾고, 이 블록을 이용하여 원하는 데이터 블록을 찾는다. 이러한 방법은 파일 크기에 따라 서 번째 또는 네 번째 단계까지 계속된다.
- 결합 기법: 색인 블록의 첫 15개 포인터를 파일의 index에 유지시킨다. 이 포인터들의 처음 12개는 직접 블록을 가리킨다. 즉, 그것들은 파일의 데이터를 포함하는 블록의 주소를 가진다. 따라서 12블록을 넘지 않는 작인 파일의 데이터는 별도의 색인 블록이 필요치 않다. 그 다음 3개의 포인터는 간접 블록을 가리킨다. 이 포인터들의 첫 번째는 `단일 간접 블록`을 가리킨다. 단일 간접 블록은 데이터를 저장하고 있는 블록이 아니라 데이터를 저장하고 있는 블록의 주소를 저장하는 인덱스 블록이다. 두 번째 포인터는 `이중 간접 블록`을 가리킨다. 이중 간접 블록은 실제 데이터 블록을 가리키는 포인터를 저장하는 블록의 주소를 저장하는 블록의 주소를 가지고 있다. 마지막 포인터는 `삼중 간접 블록`의 주소를 저장한다. 
- 색인 할당 기법은 연결 할당이 가지는 동일한 성능 문제의 일부분을 가진다. 특히, 색인 블록은 메모리에 캐시될 수 있지만 데이터 블록은 볼륨 전체에 퍼져 있을 수 있다.

### 성능
- 할당 방법을 선택하기 전에 시스템이 어떻게 사용될 것인가를 결정할 필요가 있다. 어떠한 유형의 접근을 하든지 연속 할당은 디스크 블록을 얻어내는데, 오직 한 번의 접근을 필요로 한다. 파일의 시작 주소를 메모리에 유지하는 것은 쉽기 때문에, 특정 블록과 그 다음 블록의 디스크 주소를 바로 계산해서 직접 읽을 수 있다.
- 연결 할당의 경우, 다음 블록의 주소를 메모리에 유지하고 직접 읽을 수 있다. 이 방법은 순차 접근을 하기 위해서는 좋지만, 직접 접근을 하려면 i번째 블록을 접근하기 위해 i번의 디스크 읽기를 필요로 할 수 있다.
- 따라서 몇몇 시스템들은 연속 할당을 사용하여 직접 접근 파일을, 연결 할당을 사용하여 순차 접근 파일을 모두 지원한다. 이들 시스템들에서는 파일이 생성될 때 접근 형태가 먼저 선언되어야 한다. 순차 접근을 위해서 생성된 파일은 연결 할당되며, 직접 접근을 위해서는 사용될 수 없다. 직접 접근을 위해서 생성된 파일은 연속 할당되며, 직접 접근과 순차 접근 모두 지원한다. 그러나 반드시 파일의 최대 크기를 생성 시 선언해야한다. 이 경우 OS는 두 가지 방법들을 모두 지원할 수 있는 알고리즘과 자료구조를 가지고 있어야 한다. 파일이 한 유형에서 다른 유형으로 전환하기 위해서는 원하는 유형의 새 파일을 만들고, 옛 파일의 내용을 새 파일로 복사한 후, 옛 파일을 삭제하고 새 파일은 이름을 바꾼다.
- 색인 할당의 경우는 더 복잡하다. 색인 블록이 메모리 내에 존재한다면 직접 접근이 가능하다. 그러나 메모리 내에 색인 블록 전부 상주시키는 것은 많은 양의 메모리를 필요로 한다. 만약 이 메모리 공간이 가용하지 않다면 먼저 색인 블록을 읽은 후 원하는 데이터 블록을 읽어야 한다. 두 단계 인덱스인 경우, 2개의 인덱스 블록을 읽어야 할 수도 있다. 대단히 큰 파일의 경우 거의 마지막에 있는 블록을 읽으려면 모든 색인 블록을 읽어 들여야만 한다. 따라서 색인 할당의 방식의 성능은 인덱스 구조, 파일의 크기 및 원하는 블록의 위치등에 의해 크게 좌우된다.
- 일부 시스템은 연속 할당과 색인 할당을 결합하여 작은 파일은 연속 할당하고, 파일이 더 커지면 자동으로 색인 할당으로 전환한다.

## 가용 공간의 관리
- 디스크의 공간은 제한되어 있기 때문에 삭제된 파일들이 차지하던 공간을 새로운 파일들을 위하여 다시 재사용해야 한다. 시스템은 이러한 가용 공간을 추적하기 위하여 가용 공간 리스트를 유지한다. 가용 공간 리스트는 모든 가용 디스크 블록, 즉 어떤 파일이나 디렉터리에 할당되지 않은 블록을 기록한다. 새로운 파일을 만들려면 이 가용 공간 리스트에서 요청한 양만큼의 공간을 탐색하여 새로운 파일을 위해 할당받아야 한다. 그러면 이렇게 할당되는 공간은 가용 공간 리스트에서 삭제된다. 이 파일이 삭제되면, 그 파일이 쓰던 공간은 가용 공간 리스트에 추가된다.

### 비트 벡터
- 가용 공간 리스트는 흔히 `비트맵 또는 비트 벡터` 형태로 구현된다. 각 블록은 1비트로 표현된다. 만약에 블록이 가용하다면 그 비트는 1이 되고, 만약 블록이 할당되어 있다면 0이 된다.
- 이 방법의 큰 이점은 첫 번째 가용 블록 또는 n개의 연속된 가용 블록들을 찾는 일이 간단하고 효율적이라는 점이다. 디스크 공간을 할당하기 위하여 비트 벡터를 사용하는 시스템에서 첫 번째 가용 블록을 찾는 한 가지 방법은 비트맵의 각 워드를 순차적으로 검사하여 워드의 값이 0인지 아닌지를 확인하는 것이다. 값이 0인 워드는 오직 0 비트들로 구성되어 있고, 이는 바로 할당된 블록임을 의미하기 때문이다. 첫 0이 아닌 워드를 만나게 되면 첫 번째 1인 비트를 찾는 데, 이 비트가 바로 첫 번째 가용공간의 위치를 나타낸다. 블록 번호는 `워드 비트 수 * 값이 0인 워드의 수 + 첫 번째 1비트의 변우`로 계산된다.
- 비트 벡터는 전체 벡터가 주 메모리에 유지되고 복구를 위하여 때때로 디스크에 쓰이지 않으면 비효율적이다. 비트 벡터를 메인 메모리에 유지하는 것은 작은 디스크의 경우 가능하지만, 큰 디스크의 경우에는 그렇지 않다.

### 연결 리스트
- 가용 공간을 관리하는 다른 방법은 모든 가용 디스크 블록을 함께 연결하는 것이다. 이때 첫 번째 가용 블록을 가리키는 포인터는 디스크의 특별한 위치에 저장하고 메모리에 캐싱한다. 첫 번째 가용 블록은 다음 가용 블록을 가리키는 포인터를 가진다. 두 번째 자유 블록은 다음 자유 블록의 포인터를 갖고 있고 계속 이어져 간다.
- 이 기법에서 리스트를 순회하려면 각 블록을 읽어야 하고, 이는 상당한 입출력 시간을 필요로 하기 때문에 효율적이지 못하다. 그러나 다행히도 가용 리스트 순회는 빈번하게 일어나는 일이 아니다. 통상 OS는 단순히 파일에 할당할 하나의 가용 블록이 필요하므로 가용 리스트의 첫 블록을 사용한다. FAT 기법은 가용 블록 회계와 할당 자료구조를 결합하여 사용한다.

### 그룹핑
- 가용 리스트 방식의 변형으로 첫 번째 가용 블록 내에 n개의 블록 주소를 저장하는 방법이 있다. 이중 처음 n-1개는 실제로 비어있는 블록의 주소이다. 그러나 마지막 1개는 자신과 마찬가지로 n-1개의 빈 블록 주소를 가지고 있는 가용 블록을 가리킨다. 이 방법은 연결 리스트 방법과 달리 많은 수의 가용 블록 주소들을 쉽게 찾을 수 있다.

### 계수
- 일반적을 여러 개의 연속적인 블록이 동시에 할당되고 반환된다는 이점을 이용하는 것으로 특히 연속 할당 알고리즘이나 클러스터링을 통해 공간을 할당할 경우 유용하다. 그러한 경우 모든 블록을 일일이 추적할 필요가 없이 연속된 가용 블록의 첫 번째 블록의 주소와 연속된 블록의 개수만 유지하면 보다 효율적이다.
- 각 항은 주소만 저장하는 경우에 비해 더 많은 공간을 필요로 하지만, 통상 계수가 1보다 크기 때문에 전체 길이는 더 짧아지게 된다. 가용 공간을 추적하는 이 방법은 블록 할당의 범위 방법과 유사하다. 이 항들은 효율적인 검색, 삽입, 삭제를 위하여 연결 리스트가 아닌 B-트리 형태로 저장될 수 있다.

### 공간 맵
- 공간 맵은 할당과 반환의 모든 블록 활동을 계수 형식으로 순서로 기록한다. 공간맵을 변위에 따라 색인된 균형-트리 형태로 메모리에 적재한다.

## 효율과 성능
- 디스크는 주요 컴퓨터 요소 중에서 가능 속도가 느리기 때문에 시스템의 성능면에서 병목의 주원인이 된다.

### 효율
- 디스크 공간의 효율적인 사용은 사용 중인 디스크 할당 및 디렉터리 알고리즘에 의해 좌우된다. 예를 들면, 한 볼륨에서 UNIX inode들은 미리 할당된다. 비어 있는 디스크라 해도 그 공간의 일부가 inode에 할당되어 있다. 그렇지만 inode를 미리 할당하고 또한 이들을 볼륨 전체에 분산 할당함으로써, 파일 시스템의 성능을 향상시킬 수 있다. 이러한 성능 개선은 inode들을 가급적 데이터 블록 부근에 위치하도록 함으로써 디스크의 탐색시간을 줄인 것이다.
- 클러스터링 기법은 내부 단편화를 허용하는 대신 파일 탐색과 파일 전송 성능을 향상시킨다. 내부 단편화를 줄이기 위해서 BSD UNIX에서는 파일의 크기가 증가함에 따라 클러스터의 크기도 변화시킬 수 있다. 전부 채울 수 있는 경우에는 큰 클러스터를 사용하고, 작은 클러스터는 작은 파일들과 파일의 마지막 클러스터를 위해 이용된다.
- 또한, 고려해야 할 사항으로 파일의 디렉터리(또는 inode) 항목 내에 저장되어야 할 정보의 유형이 많다. 많은 시스템들은 파일의 마지막 쓰기 시각을 기록하여 사용자에게 그 정보를 제공하고, 또한 그 파일을 백업할지를 결정하는 데 사용한다. 어떤 시스템은 마지막 접근 시간을 저장하여 사용자가 마지막으로 파일을 읽었던 시간을 알 수 있게 한다. 이 정보를 유지하게 되면 파일이 읽힐 때마다 디렉터리 구조의 필드가 갱신되어야 한다. 블록이 읽혀져 메모리로 들어오고, 해당 영역이 변경되고, 다시 디스크에 쓰여져야 한다는 것을 의미한다. 이런 일들은 모두 디스크의 연산이 블록 단위로 이루어지기 때문이다. 따라서 파일이 읽히기 위해서 열릴 때마다 디렉터리 항목을 읽고 쓰고 해야 한다. 이러한 요구 조건은 자주 접근되는 파일의 경우 비효율적이기 때문에 파일 시스템을 설계할 때 성능비용과 이득을 따져 봐야 한다.
- 포인터 크기는 파일의 크기를 제한한다. 또한 포인터 크기를 선택하거나 실제로 OS에서 고정된 할당 크기를 선택할 때 어려운 점 중 하나는 변화하는 기술에 대한 대비이다.

### 성능
- 기본적인 파일 시스템 알고리즘이 결정된 후라도, 여전히 시스템 성능을 향상시킬 수 있는 방법이 있다. 디스크 컨트롤러들은 한 트랙의 내용을 전부 저장할 수 있을 만큼 충분한 크기의 온보드 캐시를 가지고 있다. 일단 탐색이 디스크 헤드를 원하는 트랙으로 가져가면 지연시간을 줄이기 위하여 디스크는 요청된 섹터부터 그 트랙 전체를 디스크 캐시로 읽어 들인다. 디스트 컨트롤러는 요청된 섹터를 OS에게 전달한다. 일단 블록들이 디스크 제어기로부터 주 메모리로 옮겨지면, OS는 이들을 주 메모리에 캐시할 수 있다.
- 어떤 시스템은 주 메모리 내에서 별도의 구역을 버퍼 캐시용으로 유지한다. 블록은 그것들이 곧 사용되리라는 가정 하에 버퍼 캐시에 유지된다. 다른 시스템은 파일 데이터를 페이지 캐시를 사용하여 캐시한다. `페이지 캐시`는 가상 메모리 기법을 사용하여 파일 데이터를 파일 시스템 지향을 블록으로써가 아니라 페이지로써 캐시한다. 파일 데이터를 가상 주소로 캐시하는 것은 물리 디스크 블록을 통하여 캐시하는 것보다 훨씬 효율적이다. 다수의 시스템이 페이지 캐싱을 사용하여 프로세스 페이지와 파일 데이터 모두를 캐시한다. 이 기법은 `통합 가상 메모리`로 알려져 있다.
- UNIX와 LINUX의 몇몇 버전들은 `통합 버퍼 캐시`를 제공한다. 통합 버퍼 캐시가 없으면 시스템 호출은 버퍼 캐시를 통과한다. 또한, 메모리 맵핑 호출은 페이지 캐시와 버퍼 캐시의 두가지 캐시를 사용해야만 한다. 메모리 맵핑은 파일 시스템으로부터 디스크 블록을 읽고, 버퍼 캐시에 저장함으로써 진행된다. 가상 메모리 시스템은 버퍼 캐시와 인터페이스할 수 없기 때문에 버퍼 캐시에 있는 파일의 내용이 페이지 캐시로 복사되어야만 한다. 이런 상황을 `이중 캐싱`이라 한다. 파일 시스템 데이터를 두 번 캐싱해야 한다. 이것은 메모리 낭비이고, 시스템 메모리 내에서 추가의 데이터 이동으로 인해 상당한 CPU와 I/O 사이클을 낭비하게 된다. 또한 두 캐시간의 비일관성은 변질된 파일이 생기게 할 수 있다.
- 대조적으로 통합 버퍼 캐시를 제공함으로써 메모리 맵핑과 시스템 호출은 같은 페이지 캐시를 사용하게 된다. 이는 이중 캐싱을 피하게 하고, 가상 메모리 시스템이 파일 시스템 데이터를 관리할 수 있도록 한다.
- 입출력의 성능에 영향을 미칠 수 있는 또 다른 문제는 파일 시스템에 쓰기 연산이 동기적으로 혹은 비동기적으로 실행되는냐 하는 것이다. 동기식 쓰기는 디스크 서브시스템이 요청을 받은 순서대로 이루어지며, 쓰기 버퍼에 저장되지 않는다. 따라서 호출 루틴은 데이터가 디스크 드라이브에 쓰인 후에야 실행을 계속할 수 있다.
- 비동기식 쓰기의 경우 데이터를 캐시에 저장하고 호출자에게 제어를 돌려준다. 거의 대부분의 시간이 비동기식 쓰기에 사용된다. 그러나 메터데이터 쓰기 작업은 통상 동기식으로 실행된다. OS는 흔히 open() 시스템 호출에 쓰기 작업을 동기식으로 실행할 것을 요청하는 플래그를 포함한다.
- 일부 시스템에서는 파일의 접근 타입에 따라 다른 교체 알고리즘을 사용함으로써 페이지 캐시를 최적화한다. 순차적으로 읽히거나 쓰이는 파일은 LRU 순서에 따라 교체 되어서는 안된다. 대신에 순차 접근은 `바로-제거` 그리고 `미리-읽기`로 알려진 기술로 최적화된다. 바로-제거는 다음 페이지가 요청되자마자 바로 버퍼에서 사용이 끝난 현재 페이지를 제거하는 것을 말하며, 미리-읽기는 요구된 페이지와 몇 개의 뒤이은 페이지를 읽어 캐싱하는 것을 의미한다. 이러한 페이지들은 현재 페이지가 처리된 후에 요청될 가능성이 크다. 이들 페이지를 한 번의 전송으로 디스크에서 가져와 캐싱함으로써 상당한 시간을 단축할 수 있다. 다중 프로그래밍 시스템에서는 제어기 상의 트랙 캐시가 있으므로 미리-읽기를 할 이유가 없다고 생각할수 있지만, 트랙 캐시에서 메인 메모리로 적은 크기의 전송을 많이 할 경우 수반되는 높은 지연시간과 오버헤드를 생각하면 미리-읽기는 충분한 이득을 준다.
- 데이터가 디스크 파일에 쓰일 때 페이지는 캐시에 버퍼되고, 디스크 드라이버는 자신의 출력 큐를 디스크 주소에 따라 정렬한다. 이러한 두 가지 행동은 디스크 드라이버에게 디스크 헤드 탐색을 최소화하고, 디스크 회전에 최적화된 시간에 데이터 쓰기를 허용한다. 동기식 쓰기가 필요하지 않다면 디스크에 쓰기를 하는 프로세스는 단순히 캐시에 쓰고, 시스템은 편리할 때 비동기식으로 디스크에 데이터를 쓸 수 있다. 사용자 프로세스는 매우 빠르게 쓰기 작업을 할 수 있다. 
- 디스크 파일로부터 데이터가 읽힐 때 블록 입출력 시스템은 약간의 미리읽기 작업을 실행한다. 그러나 쓰기 작업은 읽기 작업보다 훨씬 비동기식에 적합한 작업이다. 따라서 파일 시스템을 통한 대규모 전송의 경우 직관가는 다르게 디스크 출력이 입력보다 빠른 경우가 많다.
