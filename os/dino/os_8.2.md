# 메모리 관리 전략

## 페이지 테이블의 구조

### 계층적 페이징
- 현대 컴퓨터는 큰 논리 주소 공간을 지원하기 때문에, 페이지 테이블 자체가 상당히 커진다. 32비트 논리 주소공간(2^32)를 가진 시스템이라면 각 프로세스 페이지 테이블 하나만을 저장하기 위해 4MB의 물리 공간이 필요하다. 이 테이블을 연속적인 메모리에 할당할 수 없기 때문에 페이지 테이블을 여러개의 작은 조각으로 나누어 저장할 수 있다.
- 2단계 페이징 기법: 페이지 테이블 자체가 다시 페이징되는 것이다. 페이지 크기가 4KB인 32비트 논리 주소 공간을 가지는 컴퓨터를 예로 들때, 논리 주소는 20비트짜리 페이지 번호와 12비트짜리 페이지 오프셋으로 이루어진다. 이 페이지 테이블도 페이지로 나누어지기 때문에 이 페이지 번호는 다시 10비트짜리 페이지 번호와 10비트짜리 페이지 오프셋으로 나뉜다. 10비트 페이지 번호는 바깥 페이지 테이블의 인덱스이고, 10비트 페이지 오프셋은 바깥 페이지 테이블이 가리키고 있는 페이지 내의 오프셋이다. 이 방식에서는 주소 변환이 바깥 페이지 테이블에서 시작하여 안쪽으로 들어오므로, 이 방식을 `전방 매핑` 페이지 테이블이라고도 부른다.
- VAX 구조가 전방 매핑 페이지 테이블을 지원한다. VAX는 페이지 크기가 512B이고 32비트 기계이다. 프로세스의 논리 주소 공간은 4개의 동일한 영역으로 나누어지는데 각각 2^30바이트로 구성된다. 각 영역은 프로세스의 논리 주소 공간의 다른 부분을 나타낸다. 논리 주소의 최상위 2개 비트는 적합한 영역을 지칭한다. 다음의 21비트는 그 영역에서의 페이지 번호를 나타내며 마지막 9비트는 선택된 페이지 내에서의 오프셋을 나타낸다. VAX에서 하나의 영역을 사용하는 프로세스의 1단계 페이지 테이블의 크기는 8MB이다. 주 메모리 사용을 더 줄이기 위해 VAX는 사용자 페이지도 페이징시킨다.
- 64비트 논리 주소 공간을 가진 시스템에서는 2단계 페이징 기법도 적당하지 못하다. 페이징을 하더라도 바깥 페이지 테이블의 크기가 너무 크기 때문이다.

### 해시된 페이지 테이블
- 주소 공간이 32비트보다 커지만 가상 주소를 해시값으로 사용하는 해시 페이지 테이블을 많이 사용한다.
- 해시 페이지 테이블의 각 항목은 연결 리스트를 가지고 있다. 이 리스트에는 충돌을 일으켜서 모두 한 곳으로 해시되는 원소들이 연결된다. 
- 각 원소는 세 개의 필드를 가진다. 가상 페이지 번호, 매핑되는 페이지 프레임 번호 그리고 연결 리스트 상의 다음 원소를 가리키는 포인터이다.
- 알고리즘은 가상 주소의 가상 페이지 번호를 해싱하는 것 부터 시작한다. 해당 해시값의 연결 리스트의 첫 번째 원소와 가상 페이지 번호를 비교한다. 일치하면 그에 대응하는 페이지 프레임 번호를 사용하여 물리 주소를 얻는다. 일치하지 않으면 연결 리스트의 그 다음 원소들을 탐색해 가며 일치하는 가상 페이지 번호를 찾는다.

### 역 페이지 테이블
- 보통 프로세스는 각자 하나씩 페이지 테이블을 가진다. 페이지 테이블은 프로세스가 사용 중인 각 페이지마다 하나의 항목을 가진다. 프로세스는 페이지의 가상 주소를 통하여 페이지를 참조하기 때문에 이러한 구조는 자연스럽다. 그러나 이러한 기법의 단점은 페이지 테이블의 크기이다. 이 문제를 해결하는 한 방법은 역 페이지 테이블이다. 
- 역 페이지 테이블에서는 물리 메모리 프레임마다 한 항목씩 할당한다. 각 항목은 그 프레임에 올라와 있는 페이지의 가상주소, 그리고 그 페이지를 소유하고 있는 프로세스의 ID로 구성된다. 이렇게 하면 시스템에는 단 하나의 페이지 테이블만 존재하게 되고, 테이블내 각 항목은 메모리 한 프레임씩을 가리키게 된다. 
- 역 페이지 테이블은 종종 각각의 페이지 테이블 항목에 저장되는 주소 공간 ID를 필요로 한다. 왜냐하면 테이블은 보통 물리 공간을 사상하는 서로 다른 주소 공간이 혼재하고 있기 때문이다.
- 역 페이지 테이블은 주소 변환 시간이 더 오래 걸릴 수 있다. 탐색은 가상 주소를 기준으로 하기 때문에 테이블 전체를 탐색해야 할 수도 있다. 이 탐색은 매우 오래 걸린다.
- 역 페이지 테이블을 사용하는 시스템에서 메모리의 공유는 어렵다. 메모리의 공유는 보통 하나의 물리 영역에 매핑되는 여러 개의 가상주소를 통해 구현된다. 이러한 방법은 모든 물리 페이지에 대해 단 하나의 가상 주소를 갖는 역 페이지 테이블에서는 사용할 수 없다.

## 세그먼테이션
- 사용자는 메모리를 다양한 크기를 갖는 세그먼트의 집합으로 그리고 세그먼트 사이의 순서는 중요하지 않은 형태로 생각하는 것을 선호한다.
- 세그먼테이션은 메모리를 바라보는 사용자 관점을 그대로 지원한느 메모리 관리 기법이다. 논리 구조 공간을 세그먼트들의 집합으로 정의한다. 각 세그먼트는 각각의 이름과 길이를 가진다. 논리 주소는 세그먼트 이름과 세그먼트 내에서의 오프셋을 표시한다.
- 사용자는 주소를 2개의 값으로 지정한다. 그것은 세그먼트의 이름과 오프셋이다. 구현을 쉽게 하기 위해서 세그먼트 이름 대신에 세그먼트 번호가 시스템(loader)에 의해 매겨지고, 시스템 내부에서 그먼트는 번호로 참조된다. 따라서 논리 주소는 `<segmentNumber, offset>`으로 구성된다.
- 보통 사용자 프로그램이 컴파일 되면, 컴파일러는 입력 프로그램을 반영하여 자동적으로 세그먼트들을 구축한다.
- 세그먼테이션은 내부 단편화를 가진다.

### 하드웨어
- 사용자는 2차원 주소로 객체를 지정할 수 있지만, 실제 물리 메모리는 바이트들의 1차원 배열이다. 그래서 사용자가 정의한 2차원 주소는 1차원의 물리 주소로 매핑되어야 한다.
- 이 매핑은 세그먼트 테이블에 의해서 이루어진다. 세그먼트 테이블의 각 항목은 세그먼트의 기준과 세그먼트 한계를 가지고 있다. 세그먼트 기준은 세그먼트의 시작 물리 주소를 지정하며, 세그먼트 한계는 세그먼트의 길이를 명시한다.
- 논리 주소는 두 부분으로 구성된다. 세그먼트 번호 s와 그 세그먼트 내에서의 오프셋 d로 구성된다. 세그먼트 번호 s는 세그먼트 테이블에 대한 색인으로 사용된다. 오프셋 d는 0과 세그먼트 한계 사이의 값이어야 한다. 그렇지 않을 경우 OS에 트랩을 발생시킨다. 이 오프셋이 범위 안에 있으면 세그먼트 기준과 오프셋이 더해져서 원하는 바이트의 물리 주소가 얻어진다.

## 사례: Intel Pentium
- 페이징과 세그멘테이션은 모두 장단점을 가지고 있으며, 어떤 구조에서는 둘 다 지원한다.
- 펜티엄 시스템에서 CPU는 세그먼테이션 유닛에게 보내질 논리 주소를 만들어 낸다. 세그먼테이션 유닛은 각각의 논리 주소를 선형 주소로 변환한다. 선형 주소는 이어서 주 메모리의 물리 주소를 생성하는 페이지 유닛으로 보내지게 된다. 생성된 물리 주소로 물리 메모리에 저장한다.

### Pentium 세그먼테이션
- 펜티엄 구조는 하나의 세그먼트가 최대 4GB의 크기를 가질 수 있으며, 프로세스당 최대 16K개의 세그먼트를 가질 수 있다. 각 프로세스의 논리 주소 공간은 두 개의 분할로 나누어진다.
- 첫 번째 분할은 그 프로세스가 독점적으로 사용하는 8K개의 세그먼트로 구성된다. 두 번째 분할은 모든 프로세스 사이에서 공유가 가능한 8K개의 세그먼트로 구성된다. 첫 번째 분할에 대한 정보는 지역 설명자 테이블(LDT)에 유지되며, 두 번째 분할에 대한 정보는 전역 설명자 테이블(GDT)에 저장된다. LDT와 GDT의 각 항목은 8B로 구성되며, 각 항목은 세그먼트 기준과 한계를 포함하는 세그먼트의 자세한 정보를 유지한다.
- 논리 주소는 (selector, offset)의 쌍으로 구성되며 selector는 16비트로 되어 있으며 s(13B)는 세그먼트 번호, g(1B)는 세그먼트가 LDT 혹은 GDT에 있는지를 나타내고 p(2B)는 보호와 관련된 정보를 나타내는 구성으로 이루어져 있다.
- 펜티엄은 6개의 세그먼트용 레지스터를 가지고 있어서 한 프로세스는 한 순간에 6개의 세그먼트를 가리킬 수 있다. 또한 LDT 또는 GDT의 해당 설명자를 저장할 수 있는 6개의 8B 마이크로프로그램 레지스터를 가지고 있다. 펜티엄은 이 캐쉬를 사용하여 메모리를 참조할 때마다 메모리로부터 설명자를 매번 읽어 오는 것을 피할 수 있다.
- 펜티엄에서 선형 주소의 길이는 32비트이다. 또한 다음과 같이 생성된다. 세그먼트 레지스터가 LDT나 GDT의 적절한 항목을 가리킨다. 일단 찾고자 생성하는 세그먼트에 대한 기준과 상한 정보를 가지고 와서 선형 주소를 만들어내는 데 사용한다. 우선 상한 정보를 이용하여 주소의 유효성을 검사한다. 주소가 한계치를 넘어가면 메모리 오류를 발생시킨다. 주소가 유효하면 변위값이 기준값에 더해져서 32비트 선형주소를 생성해낸다.

### Pentium 페이징
- 펜티엄 구조에서 페이지는 4KB 또는 4MB이다. 펜티엄은 4KB 크기의 페이지를 사용할 때 2단계 페이징 기법을 사용한다. 32비트 선형주소의 상위 10비트는 페이지 디렉터리라고 부르는 상위 페이지 테이블의 항목을 가리킨다. 페이지 디렉터리 항목은 다음 10개 비트에 의해 인덱스되는 하위 페이지 테이블을 가리킨다. 마지막 하위 12비트는 페이지 테이블이 가리키고 있는 4KB 페이지 내의 오프셋을 나타낸다.
- 페이지 디렉터리의 항목 Page size 플래그가 있는데 만약 값이 설정되면 페이지 프레임이 일반적으로 사용되는 4KB가 아니라 4MB라는 것을 의미한다. 만약 이 플레그가 설정되면 페이지 디렉터리는 하위 페이지 테이블을 가리키는 것이 아니라 직접적으로 4MB 페이지 프레임을 가리키게 된다. 그리고 선형 주소의 하위 22비트는 4MB 페이지 프레임에서의 오프셋을 나타낸다.
- 물리 메모리의 효율성을 높이기 위해 펜티엄 페이지 테이블은 디스크로 스왑될수 있다. 이런 경우 페이지 디렉터리 항목이 가리키고 있는 페이지 테이블이 메모리 또는 디스크에 있는지의 여부를 확인하기 위해서 invalid 비트를 사용한다. 만약 페이지 테이블이 디스크에 있다면 OS는 invalid 비트를 제외한 31비트를 디스크에 있는 테이블의 위치를 저장하는데 사용할 수 있다.

### Pentium 시스템 기반의 Linux
- 리눅스는 다양한 프로세서에서 동작하도록 설계되었기 때문에 세그먼테이션 기법에 의존하지 않고, 최소한의 범위 내에서 사용한다.
- 펜티엄에서 리눅스는 오직 커널 코드를 위한 세그먼트, 커널 데이터를 위한 세그먼트, 사용자 코드를 위한 세그먼트, 사용자 데이터를 위한 세그먼트, 태스크 상태 세그먼트(TSS), 디폴트 지역 설명자 테이블(LDT) 세그먼트의 총 6개의 세그먼트만을 사용한다.
- 사용자 코드와 데이터를 위한 세그먼트들은 사용자 모드에서 동작하는 모든 프로세스들에 의해 공유된다. 이것은 모든 프로세스들이 같은 논리 주소 공간을 사용하고 모든 세그먼트 설명자들이 GDT에 저장되기 때문에 가능하다. 게다가 각 프로세스는 각자의 TSS를 갖고 이 세그먼트를 가리키는 설명자를 GDT에 저장한다. TSS는 문맥 교환시 각 프로세스의 하드웨어 문맥을 저장하는데 사용된다. 디폴트 LDT는 모든 프로세스에게 공유되지만 일반적으로 사용하지 않는다. 그러나 만약 프로세스가 자신을 위한 LDT를 요청할 경우, 이를 생성하고 디폴트 LDT 대신에 사용할 수 있다.
- 각 세그먼트 selector는 보호를 위해 2비트를 사용한다. 따라서 펜티엄은 4개의 보호 수준을 사용할 수 있다. 리눅스는 4개의 보호중 사용자 모드와 커널 모드만을 사용한다.
- 펜티엄이 2단계 페이지 모델을 사용하지만 리눅스는 32비트, 64비트 모두를 위하여 3단계 페이지 모델을 사용한다.
