# 교착상태

## 교착상태 예방
- 교착상태 조건 중에서 최소한 하나가 성립하지 않도록 보장함으로써 교착상태의 발생을 예방할 수 있다.

### 상호 배제
- 상호 배제 조건은 공유가 불가능한 자원에 대해서는 반드시 성립해야한다. 그러나 공유 가능한 자원들은 배타적인 접근을 요구하지 않으며, 교착상태에 관련 될 수 없다.
- 일반적으로 상호 배제 조건을 인정하지 않음으로써 교착상태를 예방하는 것은 불가능 하다. 어떤 자원들은 근본적으로 공유가 불가능하기 때문이다.

### 점유하며 대기
- 점유하며 대기 조건이 시스템에서 발생하지 않는다는 것을 보장하려면 프로세스가 자원을 요청할 때는 다른 자원들을 가지고 있지 않다는 것을 보장해야 한다.
- 한가지 프로토콜은 각 프로세스가 실행되기 전에 반드시 자신의 모든 자원을 요청하여 할당받게 하는 것이다.
- 또다른 프로토콜은 프로세스가 자원을 전혀 갖고 있지 않을 때만 자원을 요청할 수 있도록 허용한다. 자원을 요청하려면 자신의 모든 자원을 방출해야 한다.
- 이들 프로토콜에는 단점이 있다. 첫째는 많은 자원들이 할당된 후 오랫 동안 사용되지 않기 때문에 자원의 이용률이 낮을 수 있다. 두번째는 기아 상태가 가능하다. 여러개의 인기자원들을 여러개 필요로 하는 프로세스의 경우에는 다른 점유되어 있는 자원을 무한정 기다릴 수 있다.

### 비선점
- 비선점의 필요조건은 이미 할당된 자원이 선점되지 않아야 한다는 것이다. 이 조건이 성립되지 않는다는 것을 보장하기 위해 자원을 점유하고 있는 프로세스가 즉시 할당할 수 없는 다른 자원을 요청하면, 현재 프로세스가 점유하고 있는 모든 자원들이 선점된다. 즉, 이들 자원들이 묵시적으로 방출된다.  선점된 자원들은 그 프로세스가 기다리고 있는 자원들의 리스트에 추가된다.
- 또 다른 방법으로 한 프로세스가 어떤 자원을 요청하면, 이들이 사용 가능한지를 검사한다. 사용 가능하다면, 이들을 할당한다.  이들이 사용 불가능하면, 그 자원들이 추가 자원을 기다리고 있는 다른 프로세스에게 할당되어 있는지를 검사한다. 만약 그렇다면 대기 중인 프로세스로부터 필요로 하는 자원을 선점해 요청 프로세스에게 할당한다. 만일 자원이 가용하지 않거나 다른 대기 프로세스에게 점유되어 있지 않다면, 요청 프로세스는 반드시 대기해야 한다. 프로세스가 대기하는 동안, 그 프로세스의 자원들 중 일부는 다른 프로세스가 요청하는 경우에만 선점될 수 있다. 이 프로토콜은 CPU 레지스터나 메모리 공간처럼 상태가 쉽게 저장되고 후에 복윈 될 수 있는 자원에 종종 적용된다.

### 순환 대기
- 순환대기가 성립되지 않도록 하는 한가지 방법은 모든 자원 타입들에게 전체적인 순서를 부여하여 각 프로세스가 열거된 순서대로 오름차순으로 자원을 요청하도록 요구하는 것이다.
- 각 프로세스는 초기에 자원의 인스턴스를 몇개 든지 요청할 수 있다. 그 후에는 그 프로세스는 초기 받은 자원의 순서보다 낮은 자원만 요청 가능하다.
- 또 다른 방법으로는 프로세스가 뒷 순번의 자원을 요청할 때 그전에 받은 자원들을 방출하도록 요구하는 방법이 있다.
- 두 가지 프로토콜을 사용하면 순환 대기 조건이 발생하지 않는다. 즉, 자원 종류 순서대로 요청하면 환영 대기는 없다.
- 순서나 또는 계층 구조를 정하는 것 자체만으로는 교착상태를 예방할 수 없다. 순서를 지키는 프로그램을 작성하는 것은 프로그래머에 달려있다.

## 교착상태 회피
- 교착상태를 예방할 때 나올수 있는 문제는 장치의 이용률이 저하되고 시스템 처리율이 감소된다는 것이다.
- 교착상태를 회피하는 다른 대안은 자원이 어떻게 요청될지에 대한 추가 정보를 제공하도록 요구하는 것이다.
- 각 프로세스의 요청과 방출에 대한 완전한 순서를 파악하고 있다면, 각 요청에 대해서 미래의 가능한 교착상태를 피하기 위해서 프로세스의 대기 여부를 결정할 수 있다.
- 가장 단순하고 유용한 모델은 각 프로세스가 자신이 필요로 하는 각 타입의 자원마다 최대 개수를 선언하도록 요구하는 것이다. 각 프로세스가 요청할 각 타입의 자원의 최대 개수 정보를 미리 파악할 수 있다면, 시스템이 교착상태에 들어가지 않는 것을 보장하는 알고리즘을 만들 수 있다.
- 교착상태 회피 알고리즘은 시스템에 순환 대기 상황이 발생하지 않도록 동적으로 자원 할당 상태를 검사한다. 자원 할당 상태는 가용 자원의 수, 할당된 자원의 수 그리고 프로세스들의 최대 요구 개수에 의해 정의된다.

### 안전 상태
- 시스템 상태가 안전하다는 말은 시스템이 어떤 순서로든 프로세스들이 요청하는 모든 자원을 교착상태를 야기시키지 않고 차례로 모두 할당해 줄 수 있다는 것을 뜻한다. 즉, 시스템이 안전 순서를 찾을 수 있다면 시스템은 안전하다고 말한다.
- 프로세스 순서가 안전하다는 말은 어떤 프로세스가 요청하는 자원을 시스템에 현재 남아 있는 자원과 앞에서 실행을 마칠 모든 프로세스들이 반납하는 자원들로 만족시켜줄수 있음을 뜻한다.
- 시스템의 상태가 안전하다면 교착상태가 아니다 그러나 교착상태에 있는 시스템은 불안전한 상태에 있다. 그렇지만 시스템 상태가 불안전하다고 해서 반드시 교착상태로 간다는 것을 뜻하지는 않는다.
- 회피 알고리즘의 기본 원칙은 시스템의 상태가 항상 안전 상태를 떠나지 않도록 하는 것이다.

### 자원 할당 그래프 알고리즘
- 각 자원 타입마다 단지 하나의 인스턴스를 갖는 자원 할당 시스템을 갖고 있다면, 교착상태 회피를 위해 자원 할당 그래프의 변형을 사용할 수 있다. 
- 요청, 할당 간선에 예약 간선을 도입한다. 
- 시스템에서 자원이 반드시 미리 예약되어야 함에 유의해야 한다. 즉 프로세스가 실행되기 전에 프로세스의 모든 예약 간선들이 자원 할당 그래프에 표시되어야 한다.
- 예약 간선중에서 자원할당 그래프를 봤을 때, 사이클을 형성하지 않을때만 요청을 허용할 수 있다. 이럴때 사이클 탐지 알고리즘을 이용해 안전성을 검사한다.
- 사이클이 없다면 자원을 할당해도 시스템은 안전 상태가 된다. 사이클이 발견되면, 할당은 시스템을 불안전 상태로 만들것이다.

### 은행원 알고리즘
- 자원 할당 그래프 알고리즘은 종류마다 자원이 여러개 있게 되면 사용할 수 없다. 그래서 은행원 알고리즘을 사용하지만 효율성은 다소 떨어진다.
- 시스템에서는 프로세스가 시작할 때 프로세스가 가지고 있어야 할 자원의 최대 개수를 자원 종류마다 미리 신고해야 한다. 물론 이 숫자가 자원의 총 보유수를 넘어서는 안된다.
- 프로세스가 자원들을 요청하면 시스템은 그것을 들어주었을 때 시스템이 계속 안전 상태에 머무르게 되는지의 여부를 판단해야 한다. 계속 안전하다면 요청을 들어준다. 그렇지 않다면, 요청은 허락되지 않고 다른 프로세스가 끝날 때까지 기다리게 된다.

#### 자료구조
- available: 각 종류별로 가용한 자원의 개수를 나타내는 벡터
- Max: 각 프로세스가 최대로 필요로 하는 자원의 개수를 나태는 행렬
- Allocation: 각 프로세스에게 현재 할당된 자원의 개수를 나타내는 행렬
- Need: 각 프로세스가 향후 요청할 수 있는 자원의 개수를 나타내는 행렬, `need = max - allocation`

#### 안전성 알고리즘
- work와 finish는 크기가 m과 n인 벡터이다. work = available로 초기값을 준다. finish의 각 값은 false로 초기화한다.
- `finish[i] == false`, `need(i) <= work` 조건을 만족시키는 i를 찾는다. 이러한 i가 없다면 4번째로 이동한다.
- `work = work + allocation(i)`, `finish[i] = true`를 하고 2번째로 이동한다.
- 모든 i 값에 대해 `finish[i] == true`이면, 시스템은 안전상태에 있다.
- 이 알고리즘은 `m * n^2`의 연산이 필요하다.

#### 자원 요청 알고리즘
- `request(i)`는 프로스세 P(i)의 요청벡터이다.
- `request(i)[j] == k`라면, P(i)가 자원 R(j)를 k개 까지 요청하고 있음을 뜻한다. P(i)가 자원을 요청하게 되면 아래와 같은 조치가 취해진다.
- 만일 `request(i) <= need(i)`이면, 두번째로 간다, 아니면 시스템에 있는 개수보다 더 많이 요청했으므로 오류 처리한다.
- 만일 `request(i) <= available`이면, 세번째로 간다, 아니면 요청한 자원이 당장은 없으므로, P(i)는 기다려야 한다.
- `available = available - request(i)`, `allocation(i) = allocation(i) + request(i)`, `need(i) = need(i) - request(i)`을 계산하여 보고, 계산이 안전하다면, P(i)는 반영된 정보대로 자원을 할당한다. 그러나 계산이 불안전 하다면, 이 요청은 무시되고 P(i)는 request(i)가 만족되기까지 기다린다.

## 교착상태 탐지
- 시스템이 교착상태 예방이나 교착상태 방지 알고리즘을 사용하지 않는다면, 교착상태가 발생할 수 있다. 이러한 환경에서는 시스템은 교착상태가 발생했는지 시스템의 상태를 검사하는 알고리즘, 교착상태로부터 회복하는 알고리즘이 필요하다.
- 탐지와 회복방법이 필요한 정보를 유지하고 탐지 알고리즘을 실행시키기 위한 실행시간 비용뿐만 아니라 교착상태로부터 회복할 때 내재하는 가능한 손실이 포함된 오버헤드를 필요로 한다는 것에 주의해야 한다.

### 각 자원 타입이 한 개씩 있는 경우
- 모든 자원들이 한 개의 인스턴스만 있다면, 대기 그래프라고 하는 자원 할당 그래프의 변형을 사용해 교착상태 탐지 알고리즘을 정의할 수 있다.
- 대기 그래프가 사이클을 포함하는 경우에만 시스템에 교착상태가 존재한다.
- 교착상태를 탐지하기 위해 시스템은 대기 그래프를 유지할 필요가 있고, 주기적으로 그래프에서 사이클을 탐지하는 알고리즘을 호출한다.

### 각 타입의 자원을 여러개 가진 경우
- 이 알고리즘은 은행원 알고리즘과 마찬가지로 시시각각 내용이 달라지는 자료구조를 사용한다.

#### 자료구조
- available: 각 종류의 자원이 현재 몇개가 가용한지를 나타내는 벡터
- allocation: 각 프로세스에게 현재 할당되어 있는 자원의 개수를 나타내는 행렬
- request: 각 프로세스가 현재 요청 중인 자원의 개수를 나타내는 행렬

#### 알고리즘
- work와 finish는 크기가 m과 n인 벡터이다. `work = available`로 초기값을 준다. `allocation(i) != 0 이면, finish[i] = false`이다. 그렇지 않으면 `finish[i] = true`다
- `finish[i] == false`, `request(i) <= work` 조건을 만족시키는 i 값을 찾는다. 찾을 수 없다면 네번째로 간다.
- `work = work + allcation(i)`, `finish[i] = true`를 하고 두번째로 간다.
- 어떤 i값에 대해 `finish[i] == false`이면, 시스템은 교착상태에 빠져 있는 것이다. 그리고 P(i)도 교착상태에 빠져있다.
- 이 탐지 알고리즘은 `m*n^2`개의 연산이 필요하다.
- `request(i) <= work`를 보자마자 프로세스 P(i)의 자원을 회수하는 이유는 프로세스가 작업을 마치기까지 더 이상의 추가적인 자원을 필요로 하지 않는다는 가정을 하기 때문이다. 만일 이 가정이 틀린다면 교착상태가 추후에 발생할 수 있다.

### 탐지 알고리즘 사용
- 교착상태가 자주 일어나는 지와 교착상태가 일어나면 통상 몇 개의 프로세스가 연루되는지에 따라 탐지 알고리즘의 실행 빈도를 알수 있다.
- 교착상태가 일어나는 시점은 어떤 프로세스가 자원을 요청했는데 그것이 즉시 만족되지 못하는 시점이다.
- 탐지 알고리즘은 일정 시간마다 혹은 일정 기준마다 실행시키는 것이 오버헤드를 줄이는 일이 될 것이다.

## 교착상태로부터 회복
- 교착 상태로부터 회복되는 한가지 방법은 교착상태가 발생한 것을 운영자에게 통지하여 운영자가 수작업으로 처리하게 하는 것이다.
- 다른 방법으로는 시스템이 자동적으로 교착상태로부터 회복하게 하는 것이다.
- 교착상태를 깨뜨리는 데는 두가지 방법이 있다. 하나는 순환 대기를 깨뜨리기 위하여 한 개 이상의 프로세스를 중지시키는 것이고 두 번째 방법은 교착상태에 있는 하나 이상의 프로세스들로부터 자원을 선점하는 것이다.

### 프로세스 종료
- 교착상태 프로세스를 모두 중지: 확실하게 교착상태를 제거하지만 비용이 크다. 프로세스들이 오랫동안 연산을 했을 가능성이 있으며, 이 연산을 폐기해야 하기 때문이다.
- 교착상태가 제거될때 까지 한 프로세스 씩 중지: 각 프로세스가 중지될때마다 교착상태 탐지 알고리즘을 호출해 교착상태를 파악해야 하므로 상당한 오버헤드를 유발한다.
- 어느 것을 선택할지는 많은 요인들을 고려해야한다.

### 자원 선점
- 교착상태가 깨어질 때까지 프로세스로부터 자원을 계속적으로 선점해 이들을 다른 프로세스에게 주어야 한다.

#### 고려사항
- 희생자 선택: 비용을 최소화하기 위해 선점 순서를 결정해야 한다. 교착 상태 프로세스가 점유하고 있는 자원의 수, 교착상태 프로세스의 지금까지 실행 소요시간등이 고려 대상이다.
- 롤백: 프로세스로부터 자원을 선점하면, 이 프로세스는 계속 정상적으로 실행할 수 없다. 그렇기 때문에 이 프로세스를 안전한 상태로 롤백시키고, 그 상태로부터 다시 시작해야한다. 단지 교착상태를 깨뜨릴 수 있을 정도로 롤백시킬 수 있는 것이 효과적이다.
- 기아상태: 희상자의 선택이 주로 비용 요인에 근거한다면 동일한 프로세스가 항상 희생자로 선택될 수 있다. 그것으로 기아상태가 발생될 수 있다. 프로세스가 한정된 시간 동안만 희생자로 선정된다는 것을 보장해야 한다.
