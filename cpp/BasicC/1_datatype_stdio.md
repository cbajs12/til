## 1. Baisc of C language

### 전처리기
- '#' 기호는 전처리기를 나타내는 기호이다.
- 전처리는 C 언어로 작성된 소스코드를 기계어로 번역하기 전을 의미한다.

## 2. Data Type

### 2의 보수
- 보수는 반대로 세는 수이다. 예를 들어, 7은 10을 기준으로 앞에서 7번째이지만, 뒤에서 세면 4번째이고 여기서 1을 빼면 3이된다. 즉, 10에 대한 7의 보수는 7에 얼마를 더하면 10이 되는가로 이해하면 된다.
- 1의 보수의 1을 더하는 방법이다.

### C의 자료형 기본
- 1byte는 8비트이다.
- char, unsigned char는 8비트이다.
- short, unsigned short는 16비트이다.
- int, unsigned int, long, unsinged long, float은 32비트이다.
- double, long long int는 64비트이다.
- long double은 128비트이다.
- 자료형에 unsinged가 포함되면 상수 끝에 U가 붙고, long이 붙으면 L이 붙는다. long의 경우 long이 붙은 만큼 L을 붙여준다.

#### C의 실수 자료형
- float은 소수점 이하 6번째까지는 정확하며, 그 이하로는 부정확하다. 이것을 사용할 때에는 F를 붙여야 한다. 그렇지 않으면, double형 처리를 한다.
- double은 소수점 이하 15번째까지는 정확하며, 그 이하로는 부정확하다.

### 문자, 문자열
- 문자열은 문자의 배열이다. 문자열에서 할당이 이루어지지 않는다면, 0으로 초기화된다.
- 문자열의 끝은 NULL('\0')로 끝이난다.

## 3. stdio

### getchar, putchar
- 문자 하나에 대한 입력, 출력을 하는 함수들
- putchar는 직접 문자를 매개변수로 넣어서는 안되고 int형으로 문자를 선언 후에 매개변수로 넣어야 한다.

### _getch, _getche
- 어떤 문자가 입력된 것을 확인하려는 것보다는 아무 키나 눌려서 사용자 입력이 발생했음을 감지하려는 목적으로 사용되는 함수들이다.
- Non-buffered I/O로써, 사용자가 입력한 정보가 버퍼를 거치지 않고 즉시 전달된다. 그렇기에 입력의 완료를 위해 엔터키와 같은 키를 누를 필요가 없다.

### gets, puts
- 문자열에 대한 입력, 출력을 하는 함수들
- gets 함수는 버퍼 오버플로우에 의한 버퍼 오버런 공격에 취약하다. 이것을 대체하기 위한 함수로 window에서는 gets_s가 존재한다.
- putchar와 puts 함수는 int 자료형을 출력할 수 없다.

### 형식문자
- char형과 int형은 다르지만, '부호가 있는 정수형'이라는 점에서 해석방법은 같아서 %c와 %d 모두 int형으로 다루는 것을 원칙으로 한다.
- %lld는 몇 비트 응용프로그램인가에 상관없이 64비트 정수 출력을 지원한다.
- '-' 기호는 왼쪽 정렬을 의미한다.
- 실수를 표현할 때, `%.3f`로 표시하게되면 소수점 4번째에서 반올림하고, 3자리까지 출력한다.
- 실수를 표현할 때는 반올림에 의한 오차가 발생할 수 있기 때문에 정확한 비교가 필요하면 정수를 기반으로 해야 한다.

### scanf
- scanf도 보안 문제가 존재하여, 윈도우에서는 scanf_s를 권장한다.
- scanf의 매개변수는 형식문자를 제외하고 모두 포인터이다.
- scanf 형식 문자열에 '\n'을 쓰면 안된다. 개행 문자를 제대로 구별할 수 없기 때문이다.
- 또한, `scanf("input : %d", &in)`로 작성하였을 때, 입력 시 형식 문자열을 그래도 적어서 입력해야 제대로 작동한다.
- 같은 형식문자가 붙어서 쓰면 입력시에, 빈칸이나 엔터등으로 구별을 하여야 제대로 입력된다. 그러나 다른 형식문자가 섞어 쓰면 입력의 구분 없이도 제대로 입력이 된다.
- %s만으로는 공백문자를 포함한 문자열을 입력받을 수 없고, 빈칸만큼의 %s가 존재해야 한다.
- scanf후, gets를 사용할 경우에 gets가 작동하지 않는 현상이 있는데 이것은 scanf시 입력된 엔터가 버퍼에 남아있어서 gets가 그것을 입력받기 때문이다. 이를 예방하기 위해서는 fpurge나 fflush로 입력버퍼를 비우고 사용하면 된다. `(* fflush는 원래는 출력버퍼를 비우는 역할이나, 윈도우에서는 그 표준을 준수하지 않아 사용이 가능하다 그러나 리눅스에서는 사용이 불가하다 리눅스에서는 fpurge를 사용한다. 역으로 fpurge는 윈도우에서는 사용이 안된다.)`, 둘다 동시에 해결할 수 있는 방식은 `%*c`라는 방식인데 문자 하나를 입력 버퍼에서 읽어온 후 그냥 버린다(*)는 의미이다. `scanf("%d%*c", %in)`을 쓰게 될 경우, 정수와 함께 개행문자를 버퍼에서 꺼내어 버리게된다.