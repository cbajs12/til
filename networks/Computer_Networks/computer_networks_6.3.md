# 혼잡 제어와 자원 할당

## TCP 혼잡 제어
- TCP의 기본적인 전략은 데이터 전달을 위한 어떤 종류의 예약없이 네트워크에 무조건 패킷을 보낸 후 발생하는 관찰 가능한 이벤트에 따라서 반응을 보인다는 것이다.
- TCP는 네트워크의 라우터에서 FIFO 큐잉뿐만 아니라 FQ를 가진다고 가정한다.
- TCP 혼잡 제어의 개념은 각 발신지가 스스로 네트워크에서 사용 가능한 용량을 결정하여 얼마나 많은 패킷을 안전하게 전송할 수 있는지 결정하도록 하는 것이다. 일반 한 발신지가 일정 양의 패킷을 전송하고 나면, 발신지는 전송한 패킷 중 하나가 네트워크를 통과해 나갔다는 신호로 보내는 ACK를 받게 되는데, 이를 통해서 하나의 패킷이 안전하게 전송되었다고 판단하게 되며 다시 네트워크로 하나의 새로운 패킷을 전송하게 된다. 이때 혼잡 제어 기능은 실행되지 않는다.
- 패킷 전송 속도를 조절하기 위해 ACK를 사용하기 때문에 TCP는 `셀프 클럭킹`이라고 한다. 물론 데이터 전송의 발신지에서 가능한 용량을 결정한다는 것은 쉬운일이 아니다. 더욱 어려운점은 다른 연결이 발생/소멸됨에 따라 가용한 대역폭이 시간에 따라 변화하게 된다는 점이다. 이는 발신지가 전송되는 패킷의 양을 조절할 수 있어야만 한다는 것을 의미한다.

### 산술적 증가/배수적 감소
- TCP는 각각의 연결에 대해 새로운 상태 변수를 유지하는데 이를 `Congestion Window`라고 한다. 이 Congestion Window는 발신지에서 사용하는 데, 주어진 시간 동안 얼마나 많은 양의 데이터가 전송될 것인지를 제한하게 된다. Congestion Window는 흐름제어에서 사용되는 AdvertisedWindow와 유사한 혼잡 제어를 위한 윈도우라고 할 수 있다. TCP는 최소크기의 Congestion Window와 AdvertisedWindow를 ACK 받지 않은 데이터의 최대 바이트 수가 되도록 변경하였다.
- 따라서 TCP의 Effective Window는 변경이 된다. `MaxWindow = MIN(Congestion Window, AdvertisedWindow)`, `EffectiveWindow = MaxWindow - (LastByteSent - LastByteAcked)`
- Effective Window의 계산에서 MaxWindow는 AdvertisedWindow를 대치한다. 따라서 TCP 발신지는 네트워크이든 목적지 호스트이든 가장 느린 구성 요소가 수용할 수 있는 속도보다 더 빨리 데이터를 전달할 수는 없다.
- 여기서 문제는 TCP가 어떻게 Congestion Window를 위한 적당한 값을 얻을 것인가 이다. 수신자 쪽에서 보내는 AdvertisedWindow와는 달리 아무도 TCP의 송신자에게 적당한 크기의 Congestion Window를 보내지 않는다. 현재 해결책은 TCP 발신지가 네트워크 상에 존재하리라 예층하는 혼잡 제어 단계에 기반한 Congestion Window를 세팅하게 된다. 이 방법은 혼잡 제어 단계가 높아짐에 따라서 Congestion Window를 감소시키고, 혼잡 제어 단계가 낮아짐에 따라서 Congestion Window를 증가시킨다. 이러한 기법을 `산술적 증가/배수적 감소`라 한다.
- 이때 핵심이 되는 문제는 발신지가 어떻게 네트워크가 혼잡 상태인지를 결정하여 Congestion Window가 감소해야 하는지를 알아내는가이다. 이에 대한 해결책은 주요 핵심 패킷이 전달되지 않아 타임아웃이 발생하고, 따라서 패킷이 혼잡 상태 때문에 폐기되고 있음을 관찰할 수 있다는 사실을 이용하는 것이다. 패킷이 전송 중 오류 때문에 손실되는 경우는 드물기 때문에 TCP는 타임아웃의 발생을 혼잡 상태가 생긴 것으로 판단하여 전송속도를 줄인다. 특히, 타임아웃이 일어날 때다 발신지는 Congestion Window를 그 이전 값의 절반으로 줄이게 된다. 이렇게 각 타임아웃이 발생할 때마다 Congestion Window를 반으로 줄이는 것은 배수적 감소에 해당된다.
- Congestion Window는 하나의 패킷 이하로는 떨어지지 않는데 이것은 최대 세그먼트 크기(MSS)라고 한다.
- 네트워크 상에서 새로운 가용 용량을 이용하기 위해 Congestion Window를 증가시킬 필요도 있다. 이것을 산술적 증가에 해당한다. 이것은 발신지가 Congestion Window에 해당하는 패킷을 성공적으로 보낼 때마다, 즉 마지막 RTT가 ACK를 받게 되면 하나의 패킷이 전송되는데 이때마다 Congestion Window에 하나의 패킷을 더 증가시킨다. 실제로 TCP는 Congestion Window에 하나의 패킷을 증가시키기 위해서 윈도우 크기만큼의 ACK를 기다리지는 않는다. 대신 하나의 ACK를 받을 때마다 Congestion Window에 패킷을 하나씩 증가시킨다. 특히 Congestion Window는 ACK가 도착할 때마다, `Increment = MSS * (MSS/Congestion Window)`와 `Congestion Window += Increment`를 실행한다.
- 즉 각 RTT마다 한 MSS 크기만큼씩 Congestion Window를 증가시키기보다는 ACK를 받을 때마다 MSS의 일부분씩 증가시키게 된다. 각 ACK가 MSS만큼의 총 바이트를 알려 준다고 할때, 증가되는 양은 MSS/Congestion Window이다.
- 이처럼 연결이 지속되는 동안, Congestion Window는 연속적인 증감이 이루어지게 된다. 산술적 증가/배수적 감소의 중요한 점은 발신지가 Congestion Window를 증가시킬 때보다 훨씬 빠른 비율로 Congestion Window를 감소시킨다는 것이다. 이것은 윈도우가 ACK가 도착했을 때 패킷이 하나 증가시키고, 타임아웃이 일어났을 때 하나 감소시키게 되는 산술적 증가/산술적 감소와는 대조적인 것이다.
- 산술적 증가/배수적 감소는 혼잡 제어 기법이 안정한 상태를 유지하기 위한 필요 조건이다. 적극적으로 윈도우를 줄이고, 보수적으로 윈도우를 증가시키는 이유는 윈도우가 너무 크면 작은 것에 비해서 더 나쁠 수도 있다는 영향 때문이다.
- 결국 타임아웃은 혼잡 상태의 발생으로 배수적 감소를 일으키게 되므로 TCP는 가능한 정확한 타임아웃 기법을 필요로 한다. 두가지 중요한 점중 첫째는 타임아웃은 평균 RTT와 표준편차의 함수로 정해지며, 둘째는 정확한 클럭으로 각 전송을 측정하는 비용 때문에, TCP는 단지 coarse-grained 클럭을 사용하여 패킷마다 측정하기보다는 하나의 RTT마다 한 번만 왕복지연시간을 측정하게 된다.

### 슬로 스타트
- 산술적 증가 기법은 발신지가 네트워크의 가용한 용량에 비슷한 용량으로 동작할 때 사용할 수 있는 방법이다. 그러나 처음 연결 설정시 정상적인 동작상태가 되기 위해서는 너무 많은 시간이 필요하다. 따라서 TCP는 `슬로 스타트`라고하는 두 번째 방법을 제공하는데, 이는 콜드 스타트로부터 신속히 Congestion Window를 증가시키는데 사용된다. 슬로 스타트는 효과적으로 Congestion Window를 지수적으로 증가시킨다.
- 발신지는 Congestion Window를 하나의 패킷 크기로 놓고 시작한다. 이 패킷에 대한 ACK 신호가 도착했을 때 TCP는 Congestion Window에 하나의 패킷을 더 추가하고 두 개의 패킷을 보낸다. 보낸 두 패킷에 대한 두 개의 ACK를 받은 후 TCP는 Congestion Window를 2만큼(각 ACK당 1씩) 증가시키고 다음에 4개의 패킷을 보낸다. 결과적으로 TCP는 매 RTT 전송시마다 보낼 패킷 개수를 두배로 한다.
- 슬로우 스타트라 불리는 이유는 TCP의 고유 동작과 비교할 수 있다. 발신지가 알려진 윈도우가 허락하는 만큼의 패킷을 전송한다면(슬로 스타트 이전의 방식) 네트워크 내에 충분한 가용 대역폭이 존재해도 라우터는 이 버스트 패킷을 다 보내지 못할 수도 있다. 그것은 라우터의 버퍼가 얼마나 큰가에 의존한다. 따라서 슬로 스타트는 이런 패킷에 대한 공간을 마련하여 버스트 현상이 일어나지 않도록 한다. 즉, 지수 증가가 선형 증가보다 빠르지만 슬로 스타트는 전체 모든 데이터를 한꺼번에 보내는 것보다는 느리다.
- 발신지가 전송 순간에 얼마나 많은 패킷을 가질 것인지 알 수 없는 접속을 시도하는 바로 그 순간에 상황이 발생한다. 이런 경우에, 슬로 스타트는 각 RTT에 손실이 없을 때까지 Congestion Window를 두 배로 늘린다. 손실이 발생할 때에는 타임아웃이 발생하므로 Congestion Window를 반으로 줄인다.
- 두 번째 상황은 타임아웃이 끝나기를 기다리는 동안 전송이 정지되어 있을 때 발생한다. 패킷이 손실되었을 때 발신지는 AdvertisedWindow가 허용하는 만큼의 패킷을 보낸 상태이고, 따라서 ACK가 돌아올 때까지 기다리게 된다. 결과적으로 타임아웃이 발생하고 이때까지는 더 이상 전송되는 패킷이 없게 된다. 이것은 발신지가 다음 패킷을 전송하게 되는 ACK를 받지 못하게 된다는 것을 의미한다. 대신에 발신지는 AdvertisedWindow만큼 다시 보내도록 요청하는 하나의 대표 ACK를 받게 된다. 그후 발신지는 네트워크에 데이터 흐름을 다시 개시하기 위해서 슬로 스타트를 사용한다.
- 이 경우 비록 발신지는 다시 슬로 스타트를 사용하지만 처음 접속 시도했을 때보다 많은 정보를 알고 있다. 특히 발신지는 손실의 결과에 따라 크기가 반으로 줄어버린 Congestion Window의 값을 알고 있다. 슬로 스타트는 전달하는 크기를 급속히 이 크기까지 증가시키고 이 값을 초과하면 산술적으로 증가시킨다. 여기서 문제는 슬로 스타트를 처음부터 적용하면 현재의 Congestion Window의 값을 일어버리기 때문에 현재의 Congestion Window값을 목표치로 기억해 두어야 한다. 이런 문제를 해결하기 위해 TCP는 `CongestionThreshold`라고 하는 임시 변수를 도입한다. 이것은 배수적인 감소의 결과인 Congestion Window의 크기와 같다. 다음에 Congestion Window는 다시 한 개의 패킷으로 초기화 되고 CongestionThreshold에 이를 때까지 ACK를 받을 때마다 1씩 증가된다.
- 슬로 스타트에 초기에는 많은 패킷들이 손실이 된다. TCP가 알려고 하는 것은 네트워크 대역폭이 얼마인가이다. 발신지가 이 문제에 대하여 신경쓰지 않으면, 네트워크 대역폭이 얼마나 가능한지를 아는데 너무 많은 시간이 걸리게 된다. 이것은 접속시에 얻을 수 있는 성능에 큰 영향을 미치게 된다. 다시 말해 TCP가 지수적으로 증가하는 동안 발신지가 이 문제를 해결하지 않으면, 발신지는 윈도우의 크기를 반으로 줄이게 될 위험이 있다.
- 퀵 스타트 매커니즘은 발신지가 정교한 방법을 동원하여 가능한 대역폭을 추정할 수 있도록 노력하도록 한다. 기본적인 아이디어는 TCP 송신자가 슬로 스타트에서 허용하는 IP 옵션으로서의 SYN 패킷에서 요구된 비율보다 더 큰 초기 전송률을 요구할 수 있다는 것이다. 라우터는 옵션을 검사할 수 있고, 발신한 링크에서 흐름의 밀집도의 현재 수준을 평가하며, 그 비율이 적당한지, 낮은 비율이 받아들이기 적당한지, 혹은 표준 슬로 스타트가 사용되어야 하는지를 결정한다. SYN이 수순자에게 전달될 때에는 경로에서 모든 라우터에 적합한 비율이나, 하나 또는 그 이상의 라우터가 퀵 스타트의 요구를 수행할 수 없다는 표시 중 하나를 가진다. 전자의 경우 TCP 송신자는 전송을 시작하기 위해 그 비율을 사용한다. 후자의 경우에는 표준 슬로 스타트로 돌아간다. 만약 TCP가 높은 비율의 송신 개시를 허가하면, 세션은 여러 번의 왕복 시간을 소요하기보다는 급격히 파이프의 포화점에 도달한다.
- 향상된 종류의 TCP의 도전 중 하나는 표준 TCP보다 더 많은 라우터들로부터의 협력이 필요하다는 것이다. 만약 경로에 있는 한 개의 라우터가 퀵 스타트를 지원하지 않는다면, 시스템은 표준 슬로 스타트로 되돌아간다.

### 빠른 재전송과 빠른 복구
- 조잡한 클럭을 사용하여 TCP를 구현한 경우 재전송을 위해 타이머가 끝나기를 기다리는 시간이 너무 오래 걸리게 된다. 이런 문제 때문에 `빠른 재전송`이라는 새로운 방법을 TCP에 추가하였다. 빠른 재전송 방법은 기존의 타임아웃 방법보다 분실된 패킷을 빨리 전송할 수 있는 방법이다. 빠른 재전송 방법은 기존의 타임아웃 방법을 완전히 대치하는 것은 아니다. 단지 그 기능을 확장시켜준다.
- 빠른 재전송 방법은 간단하다. 수신자에게 데이터 패킷이 도착할 때마다 수신자는 이 순서번호에 대해 ACK로 응답을 보낸 경우에도 다시 응답한다. 따라서 패킷이 순서대로 오지 않으면 아직 이전의 데이터를 받지 못하였으므로 다음 데이터를 보낼 수 없다. 이때 TCP는 앞서 보낸 ACK를 반복해서 보낸다. 이와 같이 ACK를 반복하여 보낸 것을 `중복 ACK`라 한다. 송신자가 중복 ACK를 받게 되면, 수신자는 순서대로 패킷을 받지 못했음을 알게 된다. 이 경우 이전의 패킷이 손실되었다기보다는 단지 늦어졌을수도 있기 때문에 송신자는 다시 중복 ACK를 기다리는데 세 번째 중복 ACK를 받으면 이전의 패킷이 손실된 것으로 간주하고 손실된 패킷을 재전송한다.
- 빠른 재전송 방법을 사용하면 Congestion Window가 일정하게 유지되고 아무런 패킷도 보내지 않은 긴 시간이 거의 없게 된다. 이 기술은 전형적은 TCP에서의 타임아웃의 절반 정도를 제거함으로써 전체 처리량의 20%가 개선되었다. 그러나 빠른 재전송 방법이 모든 타임아웃을 제거하지는 못했다. 이것은 윈도우 크기가 작기 때문에 충분한 중복 ACK가 전송될 만한 패킷이 없기 때문이다.
- 빠른 재전송 방법은 혼잡 상태를 알릴 때 Congestion Window의 크기를 한 패킷으로 줄이고, 슬로 스타트를 하기보다는 전송 패킷을 동기화하기 위해 파이프에 있는 ACK를 사용할 수 있다. 이것을 `빠른 복구`라 한다. 이 방법은 빠른 재전송의 경우 패킷 분실을 발견하고 산술적 증가가 시작될 때까지의 사이에 발생하는 슬로 스타트를 없앨 수 있다. 예를 들어 빠른 복구는 슬로 스타트 기간을 없애고, 대신 단순하게 Congestion Window의 크기를 반으로 줄인다. 그런 다음 산술적 증가를 시작한다. 다시 말해서, 슬로 스타트는 접속 초기와 타임아웃이 발생할 때만 쓰인다. 이 외의 시간에 Congestion Window는 산술적 증가/배수적 감소 형태의 동작을 한다.
