# 인터네트워킹
- 네트워크와 다른 네트워크를 연결하기 위해서는 `이질성`과 `확장성`이 중요하다.
- 이질성: 한 유형의 네트워크 사용자가 다른 유형의 네트워크 사용자들과 통신할 수 있어야 한다는 것이다, 이더넷, 토큰링등의 다양한 네트워크간에 독자적인 주소체계와 매체 접근 프로토콜, 서비스 모델들간의 서비스 연결을 지원해야 한다.
- 확장성: 모든 노드에게 적합한 식별자를 부여하는 주소지정 문제와 라우팅 구현의 문제를 가지고 있다.

## 간단한 인터네트워킹
- 브리지와 LAN 스위치를 이용하여 거대한 LAN을 구성하는 것이 가능하지만 이질성과 확장성의 관점에서 한계를 가지고 있다.
- 라우팅 기능을 포함한 여러 개의 이질적인 네트워크를 서로 연결시켜 하나의 거대한 네트워크로 구축하는 것을 인터네트워크(인터넷)라 한다.
- 직접 연결 네트워크와 교환 네트워크에 대해서는 `네트워크`라 하고 802.5, 이더넷, ATM과 같은 기술을 사용한다.
- 인터네트워크는 이러한 네트워크가 서로 연결된 형태를 의미한다. 서로 연결된 하부의 네트워크를 `물리적` 네트워크라 하고, 인터넷은 물리적 네트워크의 모임으로 구성된 `논리적` 네트워크라 하기도 한다.
- 브리지나 스위치에 연결된 이더넷의 집합을 `단일 네트워크`라 한다.
- 네트워크들을 서로 연결하는 노드를 라우터 또는 게이트웨이라고 한다.
- 인터넷 프로토콜(IP)은 확장이 가능하며 이질적인 인터네트워크를 구축하기 위해서 사용하는 주요한 도구에 해당한다.
- IP가 네트워크들의 집합을 구성하는 모든 노드에서 수행되면서 이들 노드들과 네트워크들이 하나의 논리적인 인터네트워크처럼 동작하도록 하는 하부구조를 정의한다.
- TCP와 UDP 같은 상위 단계 프로토콜은 호스트의 IP 위에서 수행된다.

### 서비스 모델
- 인터네트워크를 구축할 때 우선 호스트와 호스트 사이에서 제공하고자 하는 서비스(`서비스 모델`)을 정의해야 한다.
- 서비스 모델의 주요 관점은 호스트와 호스트 사이에서의 서비스는 각 하부의 물리적 네트워크에서 어떤 방식으로든 요구된 서비스를 제공할 수 있을 경우에만 가능하다는 점이다.
- IP 서비스 모델의 기본 철학: 서비스 모델의 요구를 최소화하여 어떤 네트워크 기술과 연동하더라도 필요한 서비스를 제공할 수 있도록 하는 것이다.
- IP 서비스 모델은 인터네트워크 내에 있는 모든 호스트를 식별할 수 있는 방법을 제공하는 주소 체계와 데이터 전송에서의 데이터그램 모델의 두 부분으로 구성된다.
- IP 서비스 모델은 데이터 그램 전송을 위해서 최대한 노력을 하지만 확실하게 전송되었는지에 대해서는 보증할 수 없기 때문에 `최대 노력 서비스`라고도 한다.

#### 데이터그램 전송
- IP 데이터 그램은 IP에 대한 기본적인 사항으로 네트워크가 정확한 목적지로 패킷을 전송하기에 충분한 부가 정보를 운반하게 된다. 패킷이 도착했을 때 네트워크가 취할 행동을 지시하기 위한 연결 설정 기법을 필요로 하지 않는다.
- 최대 노력이란 네트워크 내의 어떤 오류에 의해서 패킷이 손실되거나 변형되는 경우, 또는 원하는 목적지에 도착되지 않은 경우에 네트워크는 아무런 행동도 취하지 않음을 의미한다. 이러한 서비스를 `비신뢰성` 서비스라 한다.
- IP의 가장 중요한 특징은 어떤 네트워크 위에서도 수행될 수 있는 프로토콜이다.
- 최대 노력 전송은 패킷 손실뿐만아니라 순서 변경, 중복등이 있으며, 상위 프로토콜에서 이점들에 대해 유의해야 한다.

#### 패킷 형식
- 인터네트워킹 계층과 그 이상의 계층에서는 소프트웨어로 패킷을 처리하는 작업을 단순화하기 위해서 32비트 단위로 설계되었기 때문에 다른 방식들의 패킷 표현과 다른 방식을 가진다.
- 이러한 패킷을 표현하는 일반적인 방법은 32비트 워드의 연속으로 표현하는 것이다. 최상위 워드가 가장 먼저 전송되고 각 워드의 가장 왼쪽 바이트가 먼저 발송되는 방식을 취한다. 이런 표현 방식에서는 각 필드가 8비트 단위의 배수로 구성됨을 쉽게 알수 있다. 필드가 8비트 단위의 배수로 구성되지 않은 경우에는 패킷의 상단에 표시된 비트의 위치를 보고 그 필드의 위치를 알 수 있다.
- IP 패킷 헤더의 `버전`필드는 IP의 버전을 나타내는 부분이다. IPv4, IPv6등을 나타낸다. 데이터 그램의 시작 부분에 위치시킴으로써 차후의 IP 버전에 의한 패킷 형식의 재정의를 쉽게 해준다.
- `HLen 필드`는 IP 데이터그램 중 데이터 부분을 제외한 헤더 부분의 길이를 32비트 워드로 지정하는 필드이다. 일반적인 경우는 5워드이다.
- `TOS 필드`는 8비트이고 패킷을 애플리케이션 요구에 따라 서로 다르게 처리되도록 한다.
- `Length 필드`는 16비트이며, HLen과는 달리 워드 단위가 아닌 바이트 단위로 나타낸다. 따라서 IP 데이터그램의 최대 크기는 65,535바이트가 된다. 그러나 IP가 수행되는 물리적 네트워크가 긴 패킷을 처리할 수 없는 경우도 있기 때문에 단편화 및 재조립을 위한 기능도 제공해야 한다.
- `TTL 필드`는 라우팅 루프를 떠돌아 다니면서 일정한 시간이 지나도 목적지 호스트를 찾지 못해서 자원을 무한히 소비하는 패킷을 제거하기 위해서 사용된다. 원래 TTL은 패킷이 존재할 수 있는 기간을 초 단위로 설정하도록 되어 있어서 라우팅 루프 상에 존재하는 각 라우터가 이 필드의 값이 0이 될 떄까지 감소시키는 방법을 사용했지만 대부분의 라우터는 패킷 하나를 전송할 때마다 이 필드의 값을 1씩 감소시킨다. 따라서 이 값은 시간이라기보다는 홉 수를 나타낸다. 디폴트 값은 64이다.
- `Protocol 필드`는 IP 패킷이 전달되어야 하는 상위 단계 프로토콜을 나타낸다. TCP의 경우에는 6, UDP 프로토콜의 경우에는 17이며, 프로토콜 그래프 상에서 IP의 상위에 존재하는 여러 가지 프로토콜에 해당하는 값을 갖게 된다.
- `Checksum 필드`는 IP 헤더 전체를 16비트 워드에 대한 숫자로 간주해서 계산되며, 1의 보수 연산을 이용해서 덧셈을 수행하고 그 결과에 대해서 1의 보수를 취하게 된다. 따라서 전송 중에 헤더의 어떤 비트에 오류가 발생하면 수신 쪽에서 패킷 내의 체크섬 필드에는 올바른 값이 포함되어 있지 않게 된다. 체크섬 오류가 발생하게 되면 패킷을 폐기하는 것이 적절하다. CRC 만큼의 강력한 오류 발견 능력은 가지지 못하지만 소프트웨어로 구현이 쉽다.
- 발신지 주소와 목적지 부분 필드도 존대한다. 목적지 주소 부분은 데이터그램 전송시 필수적인 부분이다. 발신지 주소는 수신 쪽에서 패킷의 수신 여부와 응답 여부를 결정하게 하기 위해서 필요한 부분이다. 
- 이질성을 극복하는 데 중요한 점은 물리적 네트워크와는 무관하게 IP는 자신의 전역적인 주소 공간을 정의해야 한다. 
- 마지막으로 헤더의 뒷부분에 옵션 필드가 존재하는데 이는 HLen 필드의 검사에 의해서 결정될 수 있다.

#### 단편화 및 재조립
- 이질적인 네트워크 상에서 호스트와 호스트 사이의 일관성 있는 서비스를 제공하기 위해서는 여러가지 문제점이 존재하는데, 그 중 하나가 각각의 네트워크가 처리하는 패킷의 크기에 차이가 있다는 점이다.
- IP 서비스 모델은 두가지 방법 중 하나를 선택해야 한다. IP 데이터 그램을 어떤 하부 네트워크의 패킷에도 들어갈 수 있도록 작게 만들던지, 아니면 네트워크의 패킷보다 IP 데이터그램이 큰 경우를 대비하여 단편화 및 재조립할 수 있는 방법을 제공하여야 한다.
- 단편화 및 재조립의 방법이 더 좋은 방법인데 새로운 네트워크 기술이 생성될 때마다 네트워크에서 수행해야 하는 IP 데이터그램의 크기에 제한을 두는 것이 어렵기 때문이다. 또한 단편화 및 재조립 방법이 제공되는 경우 불필요하게 아주 작은 패킷을 전송할 필요가 없어진다.
- 모든 형태의 네트워크는 한 프레임 내에서 전송할 수 있는 최대 크기의 IP 데이터그램, 즉 `최대 전송 단위(MTU)`를 지정하고 있다는 점이다. 또한, IP 데이터그램은 링크 계층 프레임의 페이로드에 맞출 필요가 있기 때문에 MTU 값은 네트워크가 처리할 수 있는 최대 패킷 크기보다는 작아야 한다.
- 한 호스트가 IP 데이터그램을 전송할 때 자신이 원하는 크기를 선택할 수 있다. 적당한 선택 중 하나는 자기가 접속되어 있는 네트워크의 MTU를 그대로 사용하는 것이다. 목적지까지의 경로에 이보다 작은 MTU를 사용하는 네트워크가 존재하는 경우에만 단편화가 필요할 것이다. 그러나 IP의 상위 계층인 트랜스포트 프로토콜에서 지역적인 MTU보다 더 큰 패킷을 IP에게 주는 경우에는 발신지 호스트에서 이 패킷을 단편화 해야한다.
- 단편화는 일반적으로 라우터가 자신이 받은 데이터그램보다 더 작은 MTU를 사용하는 네트워크로 포워드할 때 이용한다. 이때 단편화된 패킷이 수신지 호스트에서 재조립될 수 있도록 Ident 필드에 동일한 식별자 값을 넣어서 포워드한다. 이 식별자 값은 송신 호스트에 의해서 부여되며 적절한 시간 동안 송신 호스트로부터 수신 호스트에 도달한 모든 데이터그램에 대해서는 유일한 값이 유지되어야 한다. 원래의 데이터그램에 대한 단편화된 단편은 동일한 식별자를 가지고 있으므로 수신 호스트는 이 단편을 재조립할 수 있다. 이때 수신 호스트에 모든 단편들이 도착하지 않은 경우에는 재조립 과정을 포기하고 지금까지 수신한 모든 단편들을 버리게 된다. 이때 IP는 버려진 단편에 대한 복구를 시도하지 않는다.
- 각각의 단편은 다른 단편과는 독립적으로 일련의 물리적 네트워크를 거쳐서 전송되는 완전한 IP 데이터그램이다. 또한, 각각의 데이터그램은 자기가 거쳐 가야할 각각의 물리적 네트워크에 대해서 다시 캡슐화된다.
- 라우터는 다음 단편이 뒤따른다는 의미를 나타내기 위해서 `Flag` 필드내의 M비트를 1로 표시하고, 두 번째 단편에 의해서 운반되는 데이터의 `Offset` 필드는 이전 데이터의 마지막 비트를 8로 나눈 값을 저장한다. 예를 들어 첫번째 데이터는 512비트이면 두번째 오프셋 필드 값은 64이다. 8로 나누는 이유는 IP의 설계자가 단편화는 8바이트 단위로만 이루어지도록 결정하였기 때문이다. 즉, 오프셋 필드는 바이트 묶음으로 표기한다.
- 단편화가 더 작고 유효한 IP 데이터그램을 생성시키지만, 이들 패킷이 수신되면 도착순서와 무관하게 그 패킷은 원래의 데이터그램으로 재조립될 수 있다. 재조립은 수신 호스트에서 수행된다.

#### 구현
- 수신지에 도착한 각각의 단편을 처리하기 위해서 사용하는 중요한 자료구조인 `FragList`를 정의한다.
- 목적지에 도착한 단편들은 원래의 데이터그램에 속해 있는 모든 단편이 도착할 때까지 이 자료구조에 저장된다. 그리고 나서, 이 단편은 하나의 완전한 데이터그램으로 재조립되고 상위 단계 프로토콜로 전달된다.
- FragList 내의 각 요소는 하나의 단편을 포함하거나 홀 상태로 유지되어야 한다.
- 재조립 루틴 `ipReassemble`은 도착된 데이터그램(dg) 그리고 데이터그램에 대한 IP 헤더(hdr)를 인자로 취한다. 그리고 map 구조체인 세번째 인자 `fragMap`은 들어오는 데이터그램을 적절한 FragList로 대응시키기 위해서 사용된다. 여기서 하는 작업은 IP 헤더로부터 재조립될 데이터그램을 찾기 위하여 필요한 필드를 추출한 다음, 이 필드를 이용하여 키를 구성한다. 이 키는 fragMap으로부터 FragList를 검색하는 데 이용한다. 만약 이것이 데이터그램을 위한 최초의 단편이라면 새로운 FragList는 생성되고 초기화되어야만 한다. 그리고 나서 이 루틴은 새로운 단편을 이 FragList에 삽입한다. 이때 이 단편의 오프셋과 길이의 합을 그 리스트의 다음 단편의 오프셋과 비교하는 과정이 포함된다. 대부분의 이런 작업은 hole_create 서브루틴에서 수행된다. 마지막으로 ipReassemble은 모든 홀이 채워져 있는지 검사한다. 만약 모든 단편이 존재하면 단편들을 하나의 데이터그램으로 조립하기 위해 `msgReassemble`을 호출하고 나서 이 데이터 그램을 상위 계층 프로토콜(HLP)에게 전달하기 위해 deliver를 호출한다.
- 서브루틴 hole_create는 오프셋 first에서 시작해서 오프셋 last까지 계속되는 단편 리스트에 하나의 새로운 홀을 생성한다. 이때 유틸리티 NEW가 이용되며 이는 해당 구조체의 인스턴스 하나 생성한다. 이 루틴들은 재조립의 전체적인 과정을 모두 포함하고 있지는 않다.
- IP는 일부 단편이 도착하지 않은 상황에서 회복을 위한 어떤 시도도 행하지 않으며, 다만 재조립을 위해 사용하던 메모리는 반환할 뿐이다.
- IP 재조립 과정은 하나의 단편이 없어졌다면 수신자는 계속해서 데이터그램을 재조립하려고 시도할 것이고, 재조립을 포기하면, 실패한 재조립을 수행하는 데 사용되었던 자원은 다시 회수되어야 한다. 이러한 이유에서 다른 곳들 사이에서의 IP 단편화는 일반적으로 피해야 한다. 호스트에서는 송신자와 수신자 사이의 가장 작은 MTU를 가진 링크에서도 단편화 없이 전송될 수 있을 정도로 작은 패킷을 전송하는 방식(path MTU discovery)를 수행하는 것을 권장한다.

### 전역 주소
- 두 개 이상의 호스트가 동일한 주소를 갖지 못하게 하는 전역적인 주소 체계가 필요하다. 이더넷 주소는 전역적으로 유일하기는 하지만, 그것만으로는 불충분하다. 또한, 이더넷 주소는 구조화되어 있지 않으므로 라우팅 프로토콜에 거의 도움을 주지 못하는 구조이다. 대조적으로 IP 주소는 인터네트워크 내의 계층 구조에 대응되는 여러 부분으로 구성되는 계층 구조로 되어있다.
- IP주소는 네트워크 부분과 호스트 부분으로 이루어져 있으며, 인터네트워크를 위한 논리적인 구조에 대응된다. 
- IP 주소의 네트워크 부분은 호스트가 접속되어 있는 네트워크를 식별하는 부분으로 동일한 네트워크에 연결되어 있는 모든 호스트는 IP 주소내에서 동일한 네트워크 부분을 포함한다.
- 호스트 부분은 특정 네트워크 상에서 각각의 호스트를 유일하게 식별하는 부분이다.
- 라우터는 각각의 네트워크 인터페이스를 위해서 하나씩의 주소를 갖게 된다. 즉, 라우터는 두 개의 네트워크 인터페이스를 갖는 하나의 호스트로 간주되고, IP 주소는 호스트에 대한 주소라기보다는 인터페이스에 대한 주소로 간주해야 한다.
- IP 주소는 어떤 경우에도 32비트이다.
- IP 주소의 클래스는 몇개의 MSB에 의해서 지정된다. 첫 번째 비트가 0이면 클래스 A를 의미하고, 두번째 비트가 0이면 클래스 B 그리고 처음 두 비트가 모두 1이고 세 번째 비트가 0이면 클래스 C의 주소를 의미한다.
- 클래스 A의 네트워크는 네트워크 부분을 위해서 7비트를 그리고 호스트에 24비트를 할당하는데, 126개의 클래스 A 네트워크를 둘 수 있으며, 이 각각의 네트워크는 최대 2^24-2개의 호스트를 수용할 수 있다.
- 클래스 B의 네트워크는 14비트 그리고 호스트를 위해서 16비트를 할당한다. 최대 65534개의 호스트를 수용할 수 있다.
- 클래스 C의 네트워크는 21비트를 할당하므로 254개의 호스트를 지원한다. 그러나 2^21개의 네트워크를 지원할 수 있다.
- 무계급 접근 방법은 주소 클래스 사이의 구분을 없애는 방법이다.
- IP주소는 IP 패킷의 헤더 부분에 의해서 전송된다. 그리고 라우팅 결정을 위해서 사용된다.

### IP에서 데이터그램 포워딩
- 포워딩: 입력으로부터 한 패킷을 취해서 적절한 출력으로 이 패킷을 전송하는 것을 의미
- 라우팅: 한 패킷에 대한 정확한 출력이 결정될 수 있도록 라우팅 테이블을 구성하는 과정을 의미

#### IP 데이터그램 포워딩에서 명심할 것
- 모든 IP 데이터그램은 목적지 호스트에 대한 IP 주소를 포함한다.
- IP 주소의 네트워크 부분은 하나의 물리적 네트워크를 유일하게 지정하며, 그 네트워크는 더 큰 인터넷의 일부분이다.
- 주소 내에서 동일한 네트워크 부분을 가지고 있는 모든 호스트와 라우터는 동일한 물리적 네트워크에 연결되어 있으며, 이 네트워크를 통해 프레임을 전송함으로 써 상호 통신할 수있다.
- 인터넷의 일부분으로서 연결된 모든 물리적 네트워크는 최소한 하나 이상의 라우터가 잇다. 이 라우터는 최소한 하나 이상의 다른 물리적 네트워크와 연결되어 있고, 두 네트워크에 소속된 호스트나 라우터들과 패킷을 교환할 수 있다.

#### 방법
- 발신지 호스트에서 보낸 데이터그램은 여러 개의 라우터를 거쳐서 목적지 호스트에 도달된다. 
- 한 노드에서는 그 노드가 호스트이거나 라우터이거나 관계없이, 먼저 자신이 목적지 호스트와 같은 물리적 네트워크에 연결되어 있는지의 여부를 가려내기 위한 시도를 한다. 이를 위해 목적지 주소의 네트워크 부분과 자신의 인터페이스 주소에 있는 네트워크 부분을 비교한다. 두 부분이 일치하면, 목적지가 그 인터페이스와 같은 물리적 네트워크에 있음을 의미하여 직접 그 호스트로 전송된다.
- 노드가 목적지 노드와 같은 네트워크에 존재하지 않는 경우에는 라우터로 데이터그램을 전송해야 한다. 일반적으로 각 노드는 여러 개의 라우터 중에서 하나를 선택하는데 포워딩 테이블을 참조함으로써 작업이 이루어진다. 
- 포워딩 테이블은 <NetworkNum, NextHop> 쌍의 목록으로 이루어진다. 테이블 내의 엔트리와 목적지의 네트워크 번호가 일치되는 경우가 없을 때는 디폴트 라우터를 사용한다. 호스트인 경우 디폴트 라우터만을 가지고 있는 경우가 일반적인데, 이것은 동일한 물리적 네트워크에 있지 않는 호스트로 전송되는 데이터그램은 모두 이 디폴트 라우터로 전송된다는 의미이다.
- 동일한 물리적 네트워크에 존재하는 경우, 다른 호스트의 정확한 이더넷 주소를 찾기위해 `주소 해석 방식`을 이용한다.
- 패킷을 점대점 링크나 FDDI로 데이터를 보낼 때는 다음에 전송될 노드의 MAC 주소를 찾기위해 ARP를 사용한다.
- 라우터는 네트워크 내의 모든 노드에 대해서가 아니라 네트워크 번호만을 나열한 포워딩 테이블을 가지고 있다. 그럼으로써 네트워크의 확장성을 높인다.

### 주소 변환
- IP 데이터그램은 IP 주소를 포함하고 있지만, 이 데이터그램을 전송하고자 하는 수신지 호스트나 라우터상의 물리적 인터페이스 하드웨어는 특정한 네트워크의 주소 체계만을 이해할 수 있다. 그러므로 IP주소는 해당 네트워크에서 의미 있는 최종 수신지 또는 링크 레벨의 주소로 변환해야 한다. 그리고 링크 레벨의 주소를 포함하는 프레임 속에 IP 데이터그램을 캡슐화 해서 최종 수신지로 데이터그램을 포워딩하도록 되어 있는 라우터로 전송한다.
- IP 주소를 물리적 네트워크의 주소로 대응시키기 위한 가장 간단한 방법은 IP 주소의 호스트 부분에 그 호스트의 물리적 주소를 표시하는 방법이다. 그러나 이러한 방법은 일부 네트워크에서는 사용할수 없다.
- 일반적으로는 각각의 호스트가 주소 쌍으로 구성된 테이블을 유지한다. 테이블은 IP 주소를 물리적 주소로 대응시키기 위하여 사용된다. 이 테이블은 시스템 관리자에 의해서 중앙 집중 방식으로 관리되며 그 네트워크 상의 각 호스트로 복사될 수 있다.
- 좀 더 효과적인 방법은 각각의 호스트가 네트워크를 통해서 동적으로 테이블의 내용을 스스로 알아내는 방식이다. 이 방식을 `주소 해석 프로토콜(ARP)`라 한다. ARP의 목적은 네트워크 상의 각 호스트가 IP 주소와 링크 레벨의 주소 사이의 대응을 테이블로 구성할 수 있도록 하는데 있다. 이러한 대응 관계는 수시로 변할 수 있으므로, 각 엔트리는 주기적으로 제거되어야 한다. 이 과정은 매 15분 단위로 발생된다. 호스트 내에 저장되어 있는 이러한 매핑의 집합을 `ARP캐시(테이블)`이라 한다.
- ARP는 이더넷이나 토큰링과 같은 많은 링크 레벨 네트워크가 브로드캐스트를 지원할 수 있다는 점을 이용하고 있다. 어떤 호스트가 자기가 속해 있는 네트워크 내의 다른 호스트나 라우터로 데이터그램을 전송하고자 할때, 자기 자신이 저장하고 있는 ARP 캐시를 검사해서 대응되는 엔트리를 찾지 못하는 경우에는 수신지 네트워크에 대해서 ARP를 호출한다. 네트워클 전체로 ARP 질의를 브로드캐스팅한다. 이 질의에는 원하는 IP 주소가 포함되어 있으며, 질의를 받은 각 호스트는 이 IP 주소가 자신의 IP 주소와 일치하는지 검사한다. 이것이 일치하면, 호스트는 자신의 링크 레벨 주소를 실은 응답을 그 질의를 보낸 호스트로 전송한다. 질의를 보낸 호스트는 응답 정보를 ARP 테이블에 추가한다.
- 질의 메시지에는 호출 호스트의 IP 주소 및 링크 레벨 주소도 포함되어 있으므로, 호스트가 질의 메시지를 브로드캐스트할 때 네트워크 상의 각 호스트는 호출 호스트의 링크 레벨 주소와 IP 주소를 알게 되므로 자신의 ARP 테이블에 이 정보를 저장할 수 있다. 그러나 이미 저장되어 있는 경우 보존시간을 재충전 시킬때 질의 메시지를 다시 보낸다. 호스트가 질의의 목적지라면 호스트에 대한 엔트리를 갖고 있지 않더라도 테이블에 호출 호스트에 대한 정보를 추가한다.

#### ARP 패킷 형태
- 발신자와 목표지의 IP 주소와 링크 계층 주소
- 이더넷과 같은 물리적 네트워크의 형태를 지시하는 `HardwareTyep`필드
- IP와 같은 상위 계층 프로토콜을 지시하는 `ProtocolType`필드
- 링크 계층 주소와 상위 계층 프로토콜 주소의 길이를 각각 지정하는 `HLen(하드웨어 주소길이)`과 `PLen(프로토콜주소 길이)`필드
- 요구 메시지인지 응답메시지인지를 지시하는 `Operation`필드

#### ATMARP
- ATM 네트워크가 IP 인터네트워크의 일부분으로서 동작한다면, ATM 네트워크 또한 ARP 형태를 제공할 수 있어야 한다. 그러나 ARP 패킷은 단일 네트워크에 있는 모든 호스트에게 브로드캐스트되어야 하므로 위에 설명된 ARP 과정은 단순 ATM 네트워크에서는 동작되지 않을 것이다.
- 이러한 해결 방안으로 LAN 에뮬레이션이 사용된다. LAN 에뮬레이션은 ATM 네트워크를 브로드캐스트를 지원할 수 있는 공유매체 LAN처럼 동작하도록 만드는 것이기 때문에 ARP를 수행할 수 있다.
- LAN 에뮬레이션은 크고 넓은 지역의 ATM 네트워크에서는 비효율적일 수 있다. LAN 에뮬레이션에서는 많은 패킷들이 BUS로 전송되어야 하며, 이 서버는 수신 패킷들을 LAN 에뮬레이션 내에 있는 모든 노드에게 플러딩한다. 이것은 확장성에 제한이 될 수 있다.
- 이러한 이유로 ATM 네트워크에서 사용될 수 있는 다른 ARP가 제안되었는데 이것이 `ATMARP`라 알려져있다. Classical IP over ATM 모델의 일부분이다.
- ATMARP는 주소를 해결하기 위해 서버를 사용한다. 여기서 이것을 ARP서버라 부른다.
- Classical IP over ATM 모델에서 핵심 개념은 `논리적인 IP 서브넷(LIS)`이다. LIS의 개념은 하나의 거대한 ATM 네트워크를 여러개의 작은 서브넷으로 분할한다. 같은 서브넷에 잇는 모든 노드는 같은 IP 네트워크 번호를 갖는다. 같은 서브넷에 있는 두 노드는 ATM 네트워크 상에서 직접 통신할 수 있다. 반면 다른 서브넷에 있는 두 노드는 하나 이상의 라우터를 통해서 통신을 해야한다.
- LIS 모델의 장점은 많은 수의 호스트와 라우터를 같은 IP 네트워크 번호를 주지 않고 하나의 큰 ATM 네트워크에 연결 시킬 수 있다는 것이다. 이것은 주소 할당 관리를 쉽게 한다. 즉, 하나의 ATM 네트워크에 연결되어 있는 모든 노드가 같은 관리 주체에 의하여 제어되지 않아도 된다는 사실이다. 또한, ATM 네트워크를 여러 개의 LIS들로 분할함으로써 하나의 ARP 서버에 의해 지원되는 노드 수의 제한으로 인한 확장성 문제를 개선할 수 있다.
- ARP 서버의 기본적인 역할은 LIS에 있는 모든 노드가 브로드캐스트를 사용하지 않고 IP 주소에서 ATM 주소로 찾을 수 있도록 하는 것이다. LIS에 있는 각 노드는 ARP 서버의 ATM 주소를 가지고 구성되어서, 부팅될 때 서버와 VC를 설정할 수 있어야 한다. 일단 서버와 VC가 설정되면, 노드는 등록할 IP 주소와 ATM 주소를 포함한 등록 메시지를 APR 서버에게 보낸다. 그러면 ARP 서버는 <IP주소, ATM주소>로 구성된 DB를 구축할 수 있다. 이것이 구성되면, 패킷을 특정 IP 주소로 보내기를 원하는 노드는 ATM 주소를 찾아달라고 ARP 서버에게 요청할 수 있다. 전송하려는 노드가 응답을 받으면 ATM 시그널링을 이용하여 해당 ATM주소로 VC를 설립하고 패킷을 전송한다. 일반적인 ARP처럼, IP-to-ATM 주소 대응 캐시가 유지될 수 있다. 부가적으로, 노드는 ATM 목적지까지 설립된 VC를 그곳으로 가는 충분한 트래픽이 존재하는 한 유지하여 다음 패킷이 도착할 때의 VC 설정 지연을 피할 수 있도록 한다.

### 호스트 구성
- IP 주소 생산자는 호스트가 어떤 네트워크에 속할지 네트워크에 연결된 호스트가 어디로 이동할지 모르기 때문에 생산될 때부터 호스트에 IP 주소를 할당하는 것은 불가능 하여 IP주소는 재구성이 가능해야한다.
- IP 주소와 더불어 패킷을 전송하기전에 호스트가 가져야 할 정보가 있는데 그중 하나가 디폴트 라우터의 주소이다. 디폴트 라우터는 패킷의 목적지 주소가 전송하는 호스트와 같은 네트워크에 존재하지 않을 때 패킷을 전송할 수 있는 곳이다.
- 대부분의 호스트 OS는 시스템의 관리자나 혹은 사용자에게도 호스트에서 필요한 IP 정보를 수동적으로 구성하는 방법을 제공한다. 그러나 이러한 구성은 결점이 있다. 그 중 하나는 대규모 네트워크에 있는 모든 호스트들을 직접 구성하기 위해서는 많은 작업이 필요하고, 특히 이런 호스트들이 구성되기 전까지는 네트워크를 통하여 도달할 수 없다. 이러한 구성 과정이 모든 호스트에 정확한 네트워크 번호를 부여하고, 같은 IP 주소를 가진 호스트가 존재하지 않도록 보장해야 하는 등의 오류를 범하기 쉬운 작업이다. 이런 이유로 자동적인 구성 방법이 요구되는데 대표적 방법이 `DHCP`이다.
- DHCP에는 호스트에 구성 정보를 제공하는 DHCP 서버가 존재해야 한다. 각 관리 도메인 마다 적어도 한 개 이상의 DHCP 서버가 존재한다. 가장 간단한 수준에서 DHCP 서버는 단지 호스트 구성 정보를 위한 집중화된 저장소로서의 기능을 수행한다. 각 호스트의 구성 정보는 DHCP 서버에 저장되어, 호스트가 부팅되거나 네트워크에 연결될 때 자동으로 추출된다. 그러나 이 경우라도 관리자는 각 호스트가 받아야 할 주소를 선택하여 서버에 저장해 두어야 한다. 이 모델에서 각 호스트에 대한 구성 정보는 테이블 형태로 저장되며, 일반적으로 하드웨어 주소와 같은 유일한 고객 식별자의 형식으로 인덱스된다.
- DHCP를 더욱 현명하게 사용하면 네트워크 관리자가 각각의 호스트에 주소를 일일히 할당할 필요가 없어진다. 이 모델에서, DHCP 서버는 가능한 주소들의 풀을 유지하고 있다가 요구시에 호스트에게 제공한다.
- DHCP 서버와 접촉하기 위해, 새롭게 부팅되거나 연결된 호스트는 `DHCPDISCOVER` 메시지를 특별한 IP 브로드캐스트 주소로 전송한다. 이는 네트워크에 있는 모든 호스트와 라우터에 의해 받아들여질 것이라는 것을 의미한다. (라우터들은 전체 인터넷으로 브로드캐스트되지 않도록 하기 위해, 이러한 패킷들은 다른 네트워크로 포워딩하지 않는다.)
- 가장 간단한 경우는 이 노드들 중 하나가 그 네트워크를 관장하는 DHCP 서버인 경우이다. 이 서버는 discovery 메시지를 보낸 호스트에게 응답 할 것이다. 그러나 각각의 네트워크마다 하나의 서버를 두는 방식은 바람직하지 않다. 많은 수의 서버를 요구하고 서버들이 일관되고 정확하게 구성되어야 하기 때문이다. 따라서 DHCP는 `relay agent` 개념을 사용한다.
- 각 네트워크에는 적어도 하나의 relay agent가 있고, 이것은 단 한 가지 정보, 즉 DHCP의 IP 주소만으로 구성된다. relay agent가 DHCPDISCOVER 메시지를 받았을때, 이 메시지를 DHCP 서버에게 유니캐스트하고, 응답을 기다린다. 이 응답은 요청했던 클라이언트로 전달된다.
- 이 메시지는 IP 위에서 동작하는 UDP라 불리는 프로토콜을 사용해서 실제로 전송된다. DHCP 패킷이라는 의미의 역다중화 키를 제공한다.
- 구성 정보를 얻고자 할 때, 클라이언트는 chaddr 필드에 하드웨어 주소를 넣는다. DHCP 서버는 yiaddr필드(ip 주소)를 채워서 클라이언트에게 응답한다. 클라이언트에 의하여 사용되는 디폴트 라우터와 같은 다른 정보가 options 필드에 포함될 수 있다.
- DHCP가 동적으로 호스트에게 IP 주소를 할당하는 경우에, 호스트가 할당한 주소를 무기한 보유한다면 결국 서버는 주소 풀의 주소를 소진하게 될 것이므로 호스트가 무기한으로 주소를 유지할 수 없다. 또한 호스트가 고장이거나, 네트워크로부터 연결이 끊어지거나 하면 주소를 반환할 수 없다. 따라서 DHCP는 주소를 일정시간 동안 임대하는 것만 허용하고, 임대 기간이 만료되면 서버는 이 주소를 서버의 풀로 되돌리는 권한을 가진다. 임대된 주소를 사용하는 호스트는 네트워크에 계속해서 연결되어 정상적으로 동작하기 위해서는 주기적으로 임대를 갱신할 필요가 있다.

### 오류 보고
- IP는 항상 ICMP와 함께 사용되는데, ICMP는 라우터나 호스트가 IP 데이터그램을 성공적으로 처리할 수 없을 경우에 발신지 호스트 쪽으로 보내지는 오류 메시지들을 정의하고 있다.
- ICMP는 라우터가 발신지 호스트로 보낼 수 있는 제어 메시지를 정의한다. 이때 가장 유용한 제어 메시지 중의 하나인 ICMP-Redirect는 발신지 호스트에게 더 좋은 경로가 있음을 알려주는 메시지이다.
- R1과 R2 두개의 라우터가 붙어 있는 하나의 네트워크에 연결되어 있고 R1이 디폴트 라우터일 경우, R1이 호스트로부터 데이터그램을 받은 후 자신의 포워딩 테이블에 근거하여 특정 목적지 주소에 대해서는 R2가 더 좋은 경로를 제공할 수 있다는 것을 알게 되었다면, 발신지 호스트에게 ICMP-Redirect 메시지를 보내 다음부터는 R2로 데이터그램을 보내라고 지시한다.

### 가상 네트워크와 터널
- VPN: 전송 라인을 임대하여 이 라인을 통해 여러 사이트를 연결하여 사설 네트워크를 구축한다. 이러한 네트워크에서의 통신은 연결된 사이트 사이에서만 제한적으로 가능하다.
- 사설 네트워크를 가상적으로 만들기 위해 임대 전송 라인을 일종의 공유 네트워크로 대체해야 한다. 가상 회선은 사이트 사이에 논리적인 점대점 연결을 제공하므로 임대 라인을 효과적으로 대체할 수 있다.
- IP 터널: 실제적으로 다수의 네트워크들에 걸쳐서 분산되어 있는 두 노드 사이에 설정된 가상의 점대점링크로 볼 수 있다. 가상의 링크는 터널의 입구에 있는 라우터에서 터널 반대편 종단 라우터의 IP 주소를 제공함으로써 생성된다. 터널의 입구에 있는 라우터가 가상의 링크로 패킷을 보내기 원할 때마다, 라우터는 IP 데이터그램 안으로 패킷을 캡슐화한다. IP 헤더의 목적지 주소는 터널 반대편 종단 라우터의 IP 주소가 되고, 발신지 주소는 캡슐화를 수행한 라우터의 주소가 된다.
- 터널을 만들고 인터네트워크를 통해 패킷이 이동하면서 캡슐화하는 변경을 하는 어려움을 감수하는 이유는 암호화로 보완을 한다면 터널은 공중 네트워크를 경유하는 사설링크가 될수 있다. 또 하나는 멀티캐스트 라우팅과 같이 두 라우터 사이의 네트워크에서 폭넓게 적용되지 않는 기능을 가지고 있을 경우이다. 세 번째 이유는 IP 네트워크를 통해 IP와 다른 프로토콜의 패킷을 전송하는 경우이다. 터널의 양쪽 종단점에 있는 라우터가 이 프로토콜들을 어떻게 처리해야 하는가를 알고 있다면, IP 터널은 non-IP 패킷을 보낼수 있는 점대점 링크처럼 보일 것이다. 터널은 터널 헤더의 내부에 캡슐화되어 있는 패킷의 원래 헤더에 의해 전달되고자 하는 곳과는 다른 곳으로 강제로 전달되도록 하는 기법을 제공한다.
- 터널은 인터네트워크를 통해 가상 링크를 구성하기 위한 강력하고도 일반적인 기술이다.
- 터널링의 단점은 패킷의 길이를 증가시킨다는 것이다. 패킷의 길이가 증가한다는 것은 짧은 패킷을 사용하는 곳에 문제가 될 수 있다. 또한 터널 양쪽 끝에 잇는 라우터에서의 성능이 저하될 수 도 있다.
