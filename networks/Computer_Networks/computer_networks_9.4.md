# 애플리케이션

## 오버레이 네트워크
- 인터넷 초기에는 라우터와 호스트의 역할이 명확했었다. 그러나 새로운 애플리케이션들이 자체적인 패킷 전달을 사용하는 경우가 많아져서 패킷 전달과 애플리케이션 처리의 구분이 모호해졌다. 예를 들어 `레벨 7 스위치`는 사용자가 요청한 URL을 참조하여 서버 클러스터 중에 특정 서버로 HTTP 요청을 전달하는 기능을 담당한다. 이와 같이 기존의 인터넷에 새로운 기능을 부가하는 방법으로 `오버레이 네트워크`가 확산되고 있다.
- 오버레이 네트워크는 물리적인 네트워크 위에 구현된 논리적인 네트워크로 생각할 수 있다. 오버레이의 각 노드는 기존 네트워크도 모두 존재하며, 애플리케이션에 따라 특화된 방법으로 패킷을 전달하고 처리한다. 오버레이 네트워크의 노드를 연결한 링크는 기존 네트워크에서 터널링을 통해 구현된다. 다수의 특정 애플리케이션을 지원하기 위해서는 같은 물리적 네트워크를 기반으로 다수의 오버레이 네트워크를 중첩시키거나 이미 구성된 오버레이 네트워크에 다시 오버레이 네트워크를 쌓아 올리는 방식으로 만들어 갈 수 있다.
- VPN은 터널의 양 끝의 노드는 다수의 물리적인 링크로 구성된 다중 홉 경로(터널)을 통해 연결되고, 실제 터널링을 수행하는 노드는 내부 헤더의 내용에 관계없이 외부 헤더만을 사용하여 패킷을 전달한다. 오버레이 노드는 오버레이 네트워크와 기존 네트워크에서 사용되는 주소를 모두 가지고 있으며, 동일한 주소 체계를 사용할 필요는 없다. 실제 오버레이 네트워크는 기존의 주소 체계를 따를 필요가 없고, URL이나 도메인 이름, XML 질의, 또는 패킷 내용에 따라 라우팅할 수도 있다.

### 라우팅 오버레이 네트워크
- 간단한 오버레이 네트워크는 노드에서 추가적인 애플리케이션 수준의 처리를 하지 않고 단순한 다른 종류의 라우팅 기법을 사용하는 경우이다. VPN과 비슷하지만, 이 중에서 라우팅 전략을 가지거나 두 개의 라우팅 테이블 기반의 IP 포워딩 알고리즘을 사용하지는 않았다. 이 특수한 경우의 오버레이를 `IP 터널`이라고 하며, 대부분의 사용 라우터는 VPN을 이용할 수 있는 환경을 제공해 준다.
- 단순히 터널 양단의 호스트에 상용 라우터에서 제공하지 않는 라우팅 알고리즘을 실행시키고 인터넷의 라우터를 통해서 터널링할 수도 있다. 즉, 각 호스트는 오버레이 네트워크에서 라우터처럼 동작한다. 이때 각각의 호스트는 물리적으로 하나의 링크를 통해 인터넷에 접속되어 있지만, 오버레이 노드의 개념으로는 터널을 통해 여러 개의 이웃 노드와 연결되어 있다.

#### IP의 실점적인 버전
- 오버레이는 새로운 IP 버전을 실험하는 데 이상적이다. 예를 들어, IP 멀티캐스트는 기존 IP를 확장하여, D 클래스 주소(1110)를 멀티캐스트 주소로 사용한다. DVMRP와 같은 멀티캐스트 라우팅 프로토콜과 함께 사용된다.
- IP 멀티캐스트를 사용한 오버레이 네트워크로는 MBone이 있다. MBone에서 실행되는 가장 대표적인 애플리케이션은 다자간 비디오 회의를 지원하는 vic이다.
- MBone은 VPN처럼 IP 터널과 IP 주소를 사용하지만 포워딩 방법이 다르다. MBone은 최단 경로 멀티캐스트 트리를 이요하여 방송을 듣는 모든 노드에 패킷을 전달한다. 그러나 인터넷에서는 멀티캐스트를 지원하지 않는 라우터가 있기 때문에, 오버레이 네트워크 개념을 이용하여 멀티캐스트를 지원하는 라우터 간에 기존의 라우터를 통해 터널을 형성한다.
- IPv6을 단계적으로 적용하기 위해 사용하는 6-Bone 역시 오버레이와 유사하다. 6-Bone은 MBone처럼 IPv4 라우터를 통해 패킷을 전달하기 위해 터널을 사용한다. 그러나 IPv6 128비트 주소 체계를 바탕으로 패킷을 전달한다.

#### 종단 시스템 멀티캐스트
- `종단 시스템 멀티캐스트`는 IP 멀티캐스트가 보편화되지 않은 상황에서 특정 멀티캐스트 기반의 애플리케이션에 참여하려는 종단 호스트들이 스스로 멀티캐스트 트리를 만든다는 개념에 바탕을 두고 있다.
- VPN이나 MBone과 달리 인터넷 호스트가 오버레이에 참여한다. 이러한 호스트들은 애플리케이션 프로그램에서 구현하기 쉽도록 IP 터널보다는 UDP 터널을 사용한다. 이러한 방식으로 접근하면, 인터넷 상의 특정 호스트는 다른 모든 호스트에 메시지를 보낼 수 있으므로, 기반 네트워크는 완전히 연결된 그래프로 간주할 수 있다. 즉, 종단 시스템 멀티캐스트는 인터넷을 연결된 그래프로 가정하고, 모든 구성원에게 도달 가능한 멀티캐스트 트리를 찾아 내는 것이 목적이다.
- 기존 인터넷이 완전히 연결된 구조이므로, 간단한 방법은 소스가 그룹 각각의 구성원에게 모든 직접 연결되어 있다고 생각하는 것이다. 즉, 종단 시스템 멀티캐스트는 소스 노드가 모든 그룹 구성원에게 유니캐스트 메시지를 보내는 구조를 바탕으로 구현할 수 있다.
- 일반적인 방법은 오버레이 네트워크를 여러 계층으로 구성하는 것으로, 완전한 그래프로부터 해당해당 애플리케이션을 지원할 수 있을 때까지 새로운 오버레이 서브 그래프를 만들어가는 것이다. 
- 종단 시스템 멀티캐스트의 경우 먼저 완전히 연결된 인터넷으로부터 간단 메시 오버레이 네트워크를 만든다. 다음으로 이 메시 구조 내에서 멀티캐스트 트리를 구성한다. 일단 메시 오버레이 네트워크가 선택되면 단순히 DVMRP와 같은 표준 멀티캐스트 라우팅 알고리즘을 통해 멀티캐스트 트리를 만들 수 있다. 종단 시스템 멀티캐스트 방법은 중 계 역할을 하는 메시 네트워크를 특정 멀티캐스트 그룹에 참여한 노드 중에서 고를 수 있기 때문에 인터넷 전체에 대해 생각할 경우에도 확장성 문제에 신경 쓰지 않아도 된다.
- 중계 역할을 하는 메시 오버레이 네트워크를 구축하는 핵심은 기존 네트워크의 물리적인 구조를 이용해서 적당한 네트워크 구조를 생성하는 것이다. 그러나 실제적인 인터넷 구조에서 라우터에 대한 정보는 없고 호스트에 대한 정보뿐이므로 오버레이 네트워크를 구축하는 일이 쉽지 않다. 따라서 일반적으로는 다른 노드와의 왕복지연시간을 측정하여 메시 구조 네트워크를 만든다.
- 먼저 이미 구성된 메시 구조가 있다고 한다면, 노드들은 각각 직접 연결된 이웃 노드에 대한 정보를 교환한다. 이웃 노드들로부터 상태 정보를 받으면, 자신이 가지고 있는 정보를 업데이트해서 다른 이웃 노드로 전달하게 된다. 결국은 거리 벡터 라우팅 프로토콜처럼 메시 구조 전체를 통해서 정보가 전파된다.
- 만약 어떤 호스트가 멀티캐스트 오버레이에 참여하고 싶다면 최소한 기존 오버레이에 속한 노드의 주소 하나는 알고 있어야 한다. 그리고 이 노드에 'join mesh' 메시지를 보낸다. 이러한 과정을 통해 새로운 노드와 기존 노드가 에지로 연결되어 메시에 추가된다. 일반적으로 새로운 노드는 여러 링크를 통해 메시에 참여하기 때문에, 메시지도 여러 노드에게 전달된다. 일단 노드가 메시에 연결되어 있으면, 주기적으로 'keepalive' 메시지를 이웃 노드에 보내어 그룹에 참여하고 있음을 알린다.
- 노드가 그룹을 떠나고자 할 때는 'leave mesh' 메시지를 이웃한 노드들에게 보내고, 이러한 정보는 각 노드들을 거쳐 메시 전체로 전달된다. 만약 한 노드에 문제가 발생했거나 아무 말 없이 그룹에서 떠날 경우, 이웃 노드들에게 `keepalive` 메시지가 더 이상 오지 않으므로 그 사실을 감지할 수 있다. 한 노드가 떠남으로 인해 메시 전체가 두 개의 메시로 분리되는 경우도 있다. 이때에는 'join mesh' 메시지를 사용해서 두 메시 사이에 새로운 에지를 생성해야 한다. 서로 다중으로 연결된 노드들이, 메시의 분리를 동시에 알게될 경우, 분리된 메시 사이에 추가되는 에지도 다중으로 만들어 질 수 있다.
- 메시 구조를 갖는 서브 그래프 방법도 차선책인데, 이웃 노드 선택 과정이 임의로 수행되어 임의의 링크가 오버레이 토폴로지에 추가되기도 하고, 분리된 메시 사이를 재결합함에 잇어서 전체적인 부분을 고려하지 못하여 임의로 연결하기도 하고, 자유로운 참여와 탈퇴로 구조의 변화가 자주 발생하고 기존 물리적 네트워크 환경도 유지되는 보장이 없기 때문이다. 이 문제점을 다소 완화시키는 방법은 각 노드와 연결된 링크의 가치를 평가하여 이를 고려하여 노드를 추가하고 삭제하는 것이다.
- 메시는 거리 벡터 프로토콜을 기반으로 유지되기 때문에, DVMRP를 사용하여 메시내의 멀티캐스트를 구축할 수 있다.

#### 탄력성 있는 오버레이 네트워크
- 오버레이는 인터넷에서 삼각 라우팅으로 인한 불균형이 발생하지 않도록 미리 탐지할 수 있다. 때때로 패킷을 보낼 때 직접 목직지로 보내는 것보다 중간 노드를 경유하여 보내는 것이 훨씬 더 나을 수 있다.
- BGP는 두 사이트를 연결하는 경로를 찾을 뿐이지, 그 경로가 가장 짧다고 보장하지 않기 때문이다.
- 먼저 라우팅 알고리즘의 확장성과 최적화 개념은 상충된다. BGP는 매우 큰 규모의 네트워크에서도 사용할 수 있지만, 최선의 경로를 찾거나 네트워크 고장에 신속하게 대응하지는 못한다. 반면에 특정 지점 간의 최적 경로를 일정 시간 내에 찾기 위해서는 가능한 모든 경로들의 상태를 감시하고 있어야 한다.
- RON이라는 실헝적인 오버레이가 있다. RON이 확장할 수 있는 노드의 개수는 수십 개 정도로 제한되어 잇는데, 그 이유는 N * N개의 모든 노드 사이에 지연시간, 유효 대역폭, 손실률을 포함한 동작상태를 감시하기 때문이다. 따라서, 두 노드 간의 최적 경로를 찾거나, 네트워크 상태의 변화에 따라 경로를 수정하는 것이 가능하다.
- RON은 확장성이 떨어지고, 종단 호스트가 서로 통신하기 전에 미리 알고 있어야 동일한 RON에 참여할 수 있기 때문에 불특정 호스트 간 통신에는 도움이 되지 않는다.
- 모든 오버레이들은 보통 컴퓨터 네트워크에 초점이 맞추어져 있으며, 가상화라는 개념을 사용하고 있다. 다시 말해서 물리적인 자원으로 이루어진 네트워크 위에, 개념적이고 논리적인 자원으로 만들어진 가상의 네트워크를 만드는 것이다. 심지어 이러한 가상 네트워크들을 서로 쌓아 올려서, 다중으로 구성된 네트워크를 만들 수도 있고 같은 레벨에 여러 개의 가상 네트워크가 존재할 수도 있다. 그리고 각 가상 네트워크는 사용자나 애플리케이션 또는 상위 계층 네트워크에 필요한 새로운 기능을 제공할 수도 있다.

### Peer-to-Peer 네트워크
- P2P 네트워크는 사용자 그룹의 자원을 공유할 수 있게 함으로써, 개인 사용자가 할 수 있는 것보다 더 많은 저장소와 보다 향상된 검색 및 연산 처리를 가능하게 하였다.
- 분산화 및 자기 조직화라는 것은 서버의 도움 없이 개인 노드들이 스스로 조직을 만드는 것을 의미한다. 이러한 방법은 전통적인 클라이언트/서버 간의 트랜잭션과 다를 바가 없으며, 유일한 차이점은 서버가 일반 사용자라는 것이다.
- P2P 네트워크에서 주요 관심사는 원하는 파일의 위치를 알아 내는 것이며, 또 다른 하나는 중앙 관리자와 연결 없이 원하는 파일을 자신의 컴퓨터에 다운로드 받는 것이다. 또한 이러한 시스템은 많은 노드를 가진 네트워크로 확장이 가능해야 한다. P2P 시스템은 오버레이 네트워크라고 알려진 분산화 방법을 통해서 앞의 두가지 기능을 수행할 수 있다. 이 오버레이 네트워크에서 노드는 관심 잇는 것을 공유하고자 하는 호스트들이며, 노드 간 연결하는 링크(터널)는 원하는 상대 호스트를 찾기 위하여 방문해야 할 컴퓨터의 방문 순서이다.

#### 그누텔라
- 중앙에 집중된 레지스트리를 사용하지 않는 시스템이다. 대신 그누텔라의 참여자들은 스스로를 조정하여 오버레이 네트워크를 형성한다. 즉, 그누텔라 소프트웨어를 사용하는 각 노드는 그누텔라 소프트웨어를 사용하는 몇몇의 다른 노드를 알고 있다.
- 한 노드의 사용자가 대상물을 찾고자 원하면, 그누텔라는 대상물을 찾기위한 쿼리 메시지를 그래프의 이웃 노드에게 보낸다. 만약 이웃 노드 중에서 하나가 찾고자 하는 대상물에 대한 정보를 가지고 있다면, 어디에서 대상물을 다운받을 수 있는지에 관한 정보를 담은 쿼리 응답 메시지로 응답한다. 대상물을 찾는 노드는 쿼리 응답 메시지를 받고 난 후 GET이나 PUT 메시지를 사용하여 대상물에 접근할 수 있다.
- 만약 대상물을 가지고 있는 이웃 노드가 없을 경우에는, 이웃 노드에게 쿼리 메시지를 보내는 과정이 반복된다. 다시 말하면, 그누텔라는 찾고자 하는 대상물이 어디에 있는지 알기 위하여, 오버레이 네트워크 전체에 쿼리 메시지를 보낸다. 그리고 그누텔라는 쿼리 메시지가 오버레이 네트워크에서 계속 돌아다니는 것을 막기 위하여, 각 쿼리 메시지에 TTL을 설정한다.
- 각 쿼리 메시지는 TTL과 기본적인 정보 외에 쿼리 메시지를 식별할 수 있는 쿼리식별자(QID)를 가지고 있다. 하지만 이 식별자로 최초 쿼리를 보낸 노드를 식별할 수 있는 것은 아니다. 각 노드는 최근에 보낸 쿼리 메시지에 대한 QID와 이 쿼리를 보낸 노드에 대한 기록을 유지한다. 이 기록은 두가지 방법으로 사용된다. 첫 번째는, 만약 새로 받은 쿼리의 QID가 현재 자신이 가지고 있는 것과 일치할 경우, 그 노드는 받은 쿼리 메시지를 더 이상 이웃 노드에게 포워딩하지 않는다. 이러한 행동은 TTL 값에 의한 것보다 훨씬 빠르게 포워딩을 멈추게 한다. 두 번째는 이웃 노드로부터 쿼리 응답 메시지를 받을 경우, 그 받은 메시지를 보내야 할 노드, 즉 자신에게 이 응답에 대한 쿼리 메시지를 보낸 노드가 어느 것인지 알 수 있게 해준다. 이러한 방법으로, 쿼리에 대한 응답이 중간 노드의 도움 없이 처음으로 쿼리를 보낸 노드에 도착할 수 있다.
- 한 노드가 그누텔라 오버레이에 포함되기 위해서는 최소한 하나 이상의 다른 노드에 대해 알고 있어야 한다. 이때 새로운 노드는 최소한 하나 이상의 링크를 통해서 오버레이에 합류하게 된다. 이렇게 오버레이에 합류한 노드는 오버레이 네트워크에서 전달되는 쿼리와 그에 대한 쿼리 응답 메시지를 이용하여 다른 노드에 대한 정보를 얻게 된다. 새로 가입한 노드는 위와 같은 방법으로 이웃 노드들을 발견하며, 이렇게 발견된 노드들 중에서 자유롭게 선택을 하여 이웃 노드에 대한 목록을 유지할 수가 있다. 또한 그누텔라 프로토콜은 각 이웃 노드에게 프로브 메시지를 전송하고 이에 대한 응답 여부를 통하여 그 이웃 노드가 그누텔라 오버레이에 존재하는지 알 수 있게 하는 PING & PONG 메시지를 제공한다.
- 그누텔라에 대한 기능을 개선하는 한 가지 방법은 쿼리의 전송 방법을 수정하는 것이다. 그누텔라가 쿼리를 전송하기 위해 사용하는 플루딩은 홉 수를 줄이면서 대상물을 찾는 데 좋을 특성을 보이지만, 확장성에 문제가 있다. 따라서 쿼리 메시지를 임의로 포워딩하거나, 이전 단계에서 쿼리 및 응답의 정보를 바탕으로 한 확률적인 방법을 사용하여 포워딩할 수 있다. 다른 개선점으로는 찾고자 하는 대상물의 복사본을 많이 마련하는 것인데, 그 이유는 대상물의 복사본이 많아질수록 찾기가 쉬워지기 때문이다.

#### 구조화된 오버레이
- 그누텔라와 같은 비구조화된 오버레이들은 간단한 오버레이 구조와 알고리즘을 사용하였다. 그러나 임의의 검색 방법을 사용하기 때문에 신뢰성이 떨어지는 문제가 있다. 반면, 특별한 그래프 구조로 만들어진 구조화된 오버레이는 신뢰성이 높고, 효율적으로 대상물을 찾을 수 있지만, 오버레이를 구조화하고 유지하기가 복잡하다는 단점도 있다.
- 기존의 일반적인 P2P 네트워크는 어떠한 노드가 대상물 x를 제공하는지에 대해 고려하지 않았지만, 만약 네트워크에서 대상물이 어떻게 분산되어 있는지 알 수 있다면, 보다 쉽게 대상물을 찾을 수 있을 것이다.
- 대상물의 이름과 해당 노드의 주소를 매핑하는 잘 알려진 기술을 해시 테이블을 이용하는 것이다. `hash(x) -> n` 이것은 대상물 x가 노드 n에 있다는 것을 의미하며, 대상물 x의 위치를 찾기 위해서 클라이언트는 x를 인자로 하여 해시 테이블을 검색함으로써, 그 대상물이 노드 n에 있다는 것을 알 수 있다. 해시 테이블을 이용한 방법은 대상물을 여러 노드에 분산시키는 점에서는 좋은 특성을 나타내지만, 직접적인 해싱 알고리즘은 노드의 개수가 많아질 수록 대상물을 찾는 데 그다지 이점을 얻을 수 없을 것이다. 또한, 해시 함수의 결과값을 실제 IP 주소로 바꾸는 것 또한 간단한 문제가 아니다.
- 이러한 문제들을 해결하기 위해서, 구조화된 P2P 네트워크는 `일관된 해싱` 알고리즘을 사용하는데, 이 알고리즘은 대상물 x를 ID 공간 전체에 균일하게 보존시키는 방법이다. 그것을 위하여 `대상물: hash(obj_name) -> obj_id`, `노드: hash(IP_addr) -> node_id` 의 알고리즘과 128비트 ID 공간을 사용한다.
- 128비트 ID 공간은 상당히 넓으므로, 대상물을 인자로 해싱한 결과와 각 노드의 IP 주소를 인자로 해싱한 결과가 정확히 일치하지 않을 수도 있다. 이에 각 대상물은 128비트 공간에서 대상물의 ID와 가장 가까운 ID 값을 가지는 노드에서 관리된다. 다시 말하면, 이러한 아이디어는 노드들과 대상물들을 넓은 id 공간에서 듬성듬성하게 매핑하는 높은 성능의 해시 함수를 사용하는 것이다. 이러하게 하여 해당 대상물을 번호상으로 가장 근접한 노드에 매핑하는 것이다. 이 방법은 분산된 대상물을 전 노드에 상당히 고르게 분산시킨다는 점이 보통의 해싱과 유사하며, 노드가 추가되거나 제거될 때 이동시켜야 할 대상물을 최대한으로 줄이는 장점이 있다는 것은 이전의 일반 해싱과는 다르다.
- 대상물 x에 접근하기를 원하는 사용자가 대상물 x의 ID와 가장 가까운 노드가 어떤 것인지를 알기 위하여 구조화된 P2P 네트워크에서 사용되는 방법은 메시지를 이 노드로 라우팅해 주는 방법이다. 바꾸어 말해서, 오버레이를 잘 구축하였다면, 노드의 라우팅 테이블 엔트리를 보고 라우팅시킴으로써 간단히 해당 노드를 찾을 수 있다. 이와 같은 접근 방식에서 해시 테이블은 네트워크 상의 모든 노드에 분산되어 있기 때문에, 보통 `분산 해시 테이블(DHT)`라 한다.
- 컴퓨터 ID가 65alfc(hex)이고, ID가 d46alc인 대상물을 찾고 있다고 가정한다. 컴퓨터 ID는 찾고자 하는 대상물과 전혀 다르지만 적어도 ID가 d로 시작하는 다른 노드를 알고 있다고 한다. 그 노드는 128비트의 ID 공간에서 탐색하는 컴퓨터 보다 대상물에 가깝게 위치하고 있으므로, 그 노드에게 메시지를 포워딩하면 된다. 메시지를 받은 노드 d13da3은 자신이 알고 있는 다른 노드 중에서 ID 가 가장 길게 일치하는 다른 노드를 선택하여 메시지를 그 노드로 다시 포워딩한다. 이러한 과정이 ID 공간에서 대상물의 ID와 제일 가까운 노드에 도착할 때까지 반복되며, 결국 대상물을 가지고 있는 노드에 도달하게 될 것이다. ID 공간을 통해서 메시지가 이동하는 것은 실제로는 인터넷 환경하에서 노드 간에 포워딩이 되는 것이다.
- 각 노드는 라우팅 테이블과 몇몇 노드 ID에 대한 IP 주소를 유지한다. 이것을 노드의 `말단 집합`이라고 부른다. 따라서 어떤 대상물을 가지고 있는 노드와 같은 말단 집합에 속해 있는 노드로 메시지가 라우팅된다면, 그 노드는 곧바로 최종 목적지까지 메시지를 포워딩할 수 있다. 다시 말하면, 대상물의 ID와 가장 길게 프리픽스가 일치하는 노드가 여러 개 있는 상황에서도, 말단 집합은 ID 공간에서 대상물에 제일 가까운 노드에게 메시지를 전달할 수 있도록 해준다. 또한 말단 집합에서는 임의의 노드가 라우팅할 수 있는 메시지는 동일한 집합에 있는 다른 모든 노드도 라우팅할 수 있기 때문에, 보다 확실한 라우팅이 이루어진다. 그러므로, 만약 한 노드가 메시지를 라우팅하지 못했을 경우 말단 집합에 있는 이웃 노드 중에서 하나가 대신해서 메시지를 라우팅할 수 있다.
- 오버레이에 한 노드를 추가하는 것은 어떤 대상물에 대하여 그 대상물의 위치를 찾는 메시지를 라우팅시키는 동작과 유사하다. 새로 추가된 노드는 기존의 노드 중에서 반드시 하나 이상을 알고 있어야 한다. 새로 가입하는 노드는 자신이 알고 있는 노드에게, 자신의 ID와 가장 가까운 노드에게 노드가 새로 추가 되었다는 메시지를 라우팅하도록 요청한다. 이러한 라우팅 과정을 통하여 새로 가입한 노드는 프리픽스가 일치하는 다른 노드에 대해 알게되고, 자신의 라우팅 테이블을 채울 수 있다. 오버레이에 새로운 노드가 추가된 후, 시간이 지나면 기존의 노드들도 자신의 라우팅 테이블에 새로 가입하는 노드에 관한 정보를 포함할 수 있다. 기존의 노드들은 현재 자신의 테이블에 가지고 있는 것보다 더 긴 프리픽스가 일치하는 노드가 새로이 오버레이에 가입했을 경우 이 노드를 이용할 수 있다. 말단 집합에 있는 이웃들 역시 서로 간에 라우팅 테이블의 정보를 교환함으로써, 오버레이 전체에 라우팅 정보가 전파된다.
- 구조화된 오버레이는 각 홉을 지날 때마다 얼마만큼의 지연이 발생되기 때문에, 주어진 대상물을 찾기 위한 홉 수를 제한하고 있다.
- 라우팅의 하부 구조가 주어지면, 다른 서비스를 제공하는 것이 가능하다. 예를 들면, 파일 공유 시스템은 파일의 이름을 대상물의 이름으로 이용한다. 파일의 위치를 찾기위해, 파일 이름을 인자로 한 해시 함수를 수행하여 해당하는 대상물의 ID를 찾는다. 그런 다음, 이 ID에 대해 대상물의 위치를 찾으라는 메시지를 보낸다. 시스템은 효용성을 향상시키기 위해 각 파일을 오버레이의 여러 노드에 복사한다. 일반적으로 여러 개의 복사본을 찾고자 하는 파일을 라우팅하는 노드의 말단 집합에 저장하는 것은 효율을 향상시키기 위한 하나의 방법이다. 비록 ID 공간에서 이러한 노드들이 이웃에 있다고 하더라도, 물리적으로는 인터넷 전체에 걸쳐 분산되어 있을 가능성이 높다. 
- 파일 공유 이외에도 다른 서비스를 위하여 분산 해시 테이블이 사용될 수 가 있다. 예를 들어, 멀티캐스트 애플리케이션을 고려해 보면, 메시 구조로부터 멀티캐스트 트리를 구축하는 대신에 구조화된 오버레이의 에지로부터 멀티캐스트 트리를 구축할 수 있으며, 그에 따라 몇몇 애플리케이션과 멀티캐스트 그룹을 위한 오버레이의 구축 비용과 유지비를 줄일 수 있다.

#### 비트토렌트
- 비트토렌트는 공유할 파일을 조각으로 불리는 세그먼트 단위로 나누어 복사한다. 일반적으로 각 조각은 여러 peer로부터 다운로드할 수 있지만, 파일 전체를 하나의 peer로부터 다운로드할 수도 있다. 비트토렌트의 이러한 복사 방식의 가장 큰 장점은 파일에 대한 소스가 하나뿐인 경우에도 병목현상을 방지할 수 있다는 것이다. 이는 비트토렌트를 이용한 다운로드 과정에서 발생하는 당연한 결과로 임의의 조각을 다운로드하는 peer가 그 조각에 대한 또 다른 제공자가 될 수 있기 때문이다. 따라서 해당 조각을 다운로드하는 peer가 많이 생길수록 해당 조각에 대한 제공자도 많이 생긴다. 이에 다수의 peer가 임의의 조각을 하나의 제공자로부터 다운로드할 때 발생하는 부하를 균형 있게 분배할 수 있다. 또한 여러 peer가 조각을 순서대로 다운로드하는 경우에는 결국 모든 ㅍ가 동일한 조각만 보유하기 때문에, 서로가 다른 조각에 대해서는 제공자가 될 수 없다. 따라서, 비트토렌트는 조각을 임의의 순서대로 다운한다.
- 각 파일은 swarm이라는 서로 독립적인 비트토렌트 네트워크를 통하여 공유된다. 최초 swarm은 파일의 부분이 아닌 전체를 가지고 있는 단독 객체 peer로부터 시작한다. 이 파일을 다운로드하려는 peer는 swarm에 참여하고, 이 노드가 swarm의 두 번째 peer가 된다. 그리고 첫 번째 peer로부터 파일의 조각을 다운로드하기 시작한다. 이러한 과정을 통하여 전체 파일은 아니지만 다운로드 한 조각에 대하여 또 다른 제공자가 된다. 이어서 다른 peer가 swarm에 참여하고 swarm을 생성한 최초의 peer를 포함한 다수의 peer로부터 조각을 다운로드하기 시작한다. 만약 이 파일을 다운로드하려는 노드가 많으면, swarm을 떠나는 노드들을 대체할 새로운 peer들이 계속 생겨서, swarm은 계속 존재할 수 있다. 만약 그렇지 않으면, swarm은 점점 축소되어 새로운 peer가 swarm에 참여할 때까지 최초의 peer만 존재하도록 축소될 수도 있다.
- 다운로드하려는 파일의 조각을 가지고 있는 peer를 탐색하는 과정은 파일을 다운로드하려는 노드가 swarm에 참여하는 것부터 시작한다. 이 과정을 수행하기 위해서는 파일과 swarm에 대한 메타 정보를 포함한 .torrent 파일이 필요한다. 이 파일은 다운로드하려는 파일의 크기, 조각의 크기, 각 조각으로부터 미리 계산된 SHA-1 해시 값, swarm tracker의 URL이 포함된다.
- tracker는 현재 swarm에 참여한 peer에 대한 정보를 저장하고 있는 서버이다. 따라서 모든 정보가 tracker에게 집중되어 병목 현상이 발생하거나 tracker가 고장 날 경우 심각한 문제가 발생할 수 있다. 
- 다운로드하려는 노드가 swarm에 참여하려면 peer ID를 임의로 생성한 후, 네트워크 주소와 생성된 peer ID 정보가 포함된 메시지를 tracker에게 전송해야 한다. 또한 이 메시지에는 .torrent 파일의 주요한 부분에 대한 SHA-1 해시 값이 포함되어 있다. 그리고 SHA-1 해시 값은 swarm의 ID로 사용된다.
- 새로운 peer가 swarm에 참여하기 위해 tracker에게 메시지를 보내면, tracker는 peer에게 그 swarm에 참여하고 있는 일부 peer의 ID와 네트워크 주소를 알려 준다. 그리고 peer는 수신한 정보에 기반하여 다수의 peer 중에서 일부와 TCP 연결을 설정한다. 물론 peer는 추가적으로 다른 peer와 연결을 설정하거나 tracker로부터 더 많은 peer의 정보를 요청할 수도 있다. peer와 다른 peer간의 TCP 연결 설정이 완료되면, peer는 설정된 TCP 기반에서 실질적인 비트토렌트 연결을 설정하고자 한다. peer는 연결된 peer에게 자신의 ID와 swarm ID를 전송하고, 이를 수신한 peer는 자신의 ID와 swarm ID로 응답한다. 만약 두 swarm ID가 서로 맞지 않거나 연결을 요청한 peer ID가 아니면, peer는 비트토렌트 연결을 중지한다.
- 설정된 비트토렌트 연결은 대칭적이다. 대칭적이라는 의미는 peer가 파일을 다운로드하기 위하여 다른 peer에게 연결 요청을 하여 그 연결 요청이 수립되면, 다른 peer도 새로운 연결 요청 없이 peer가 가지고 있는 파일을 다운로드할 수 있다는 것이다. 비트토렌트 연결이 설정되면, 각 peer는 이웃 peer에게 자신이 가지고 있는 조각에 대한 비트맵을 전송하고, 이 비트맵을 수신한 peer는 이웃 peer가 가지고 있는 조각의 정보를 알 수 있다. 파일을 다운로드하는 peer는 각 조각의 수신이 끝날 때마다, 자신과 직접 연결된 이웃 peer에게 자신의 조각 정보를 담은 메시지를 전송하고, 이웃 peer는 그 peer가 가지고 있는 조각의 정보를 갱신한다. 또한 peer도 이웃 peer가 전송하는 조각 정보 메시지를 기반으로 이웃 peer가 가지고 있는 조각의 정보를 알 수 있다. 이와 같은 방식을 통하여 peer는 다운로드하려는 조각을 가진 peer를 찾을 수 있다. 만약 peer가 요청한 조각을 가지고 있는 이웃 peer가 없으면, peer는 다른 peer와 새로운 연결을 시도할 수 있다. 혹은 peer는 자신과 연결된 이웃 peer 중에서 일부가 언젠가는 다른 peer로부터 그 조각을 다운로드하여, 그 peer도 이웃 peer로부터 그 조각을 받을 수 있을 것이라는 기대와 함께 자신이 원하는 다른 조각의 다운로드 작업을 계속 진행할 것이다.
- 조각을 임의의 순서대로 다운로드하는 방법은 임의의 peer가 가지고 있는 조각이 다른 peer가 가지고 있는 조각에 포함되는 부분집합 혹은 초집합이 되어 다른 peer가 새로운 조각을 다운로드하기 전까지 임의의 peer는 기다려야 하는 상황을 피할 수 있다.
- 비트토렌트는 중앙 집중적인 tracker를 이용하여 동작한다. 그러나 이러한 tracker를 사용하면 SPOF 문제나 병목현상이 발생할 수 있다. 또한 비트토렌트를 이용하여 파일을 공유하고자 하는 사람은 tracker를 반드시 제공해야 하는 불편함이 있다. 이에 DHT 기반으로 구현된 비트토렌트의 새 버전에는 tracker가 없이 동작하는 swarm을 지원한다. tracker 없이 동작이 가능한 비트토렌트 클라이언트 소프트웨어는 비트토렌트 peer뿐만 아니라, 다른 peer를 찾기위한 peer finder도 구현되어 있다.
- peer finder는 DHT 기반으로 동작하는 swarm을 구현하기 위해서 UDP 기반의 프로토콜을 정의하여 오버레이 네트워크를 형성한다. 형성된 오버레이 네트워크에 속한 peer finder들은 자신과 연결된 peer의 정보를 교환할 수 있으며, peer는 peer finder를 통하여 swarm 내의 다른 peer를 찾을 수 있다. 또한, peer finder는 서로 다른 swarm에 속해 있는 peer와 연결될 수 있기 때문에, 서로 다른 swarm을 이어 주는 역할을 한다. 다시 말해서 swarm은 비트토렌트 peer들이 구축한 네트워크이며, peer finder가 형성한 네트워크는 swarm 간의 연결을 통해 네트워크를 확장한 것이다.
- peer finder들은 임의로 자신의 finder ID를 생성하며, 길이는 swarm ID와 같이 160비트이다. 각 peer finder는 자신의 ID와 비슷한 ID를 소유한 여러 peer finder와 자신의 ID와 어느 정도의 차이가 있는 여러 peer finder의 정보를 가지는 테이블을 유지한다. peer finder가 특정 peer를 찾는 알고리즘은 peer finder F가 특정 swarm에 속한 peer를 찾으려고 할 때, F는 이웃 peer finder의 정보가 기록된 테이블을 참조하여 swarm ID와 비슷한 ID를 가진 peer finder들에게 찾고자 하는 특정 swarm에 대한 요청을 보내는 것으로 시작한다. 만약 요청을 수신한 peer finder가 해당 swarm에 속한 peer를 알고 있다면, 그 요청에 대하여 해당 peer의 정보를 알려준다. 그렇지 않으면, 요청한 swarm의 ID와 비슷한 ID를 가진 peer finder의 정보를 알려 준다. 따라서 F는 이와 같은 방식으로 peer finder들에게 반복적으로 요청 메시지를 계속 전송할 수 있다. 만약 해당 swarm ID와 더 비슷한 peer finder가 없으면 검색이 끝나게 된다. 검색이 끝난 후에, F는 자신이 획득한 peer finder들의 연결 정보를 자신의 테이블에 저장하여 관리한다. 또한 F는 자신과 연결되었던 peer finder들 중에서 찾고자 하는 swarm ID와 가장 유사한 ID를 가진 peer finder를 선택한 후에 F 자신이 획득한 정보를 선택한 peer finder에게 알려준다. 이와 같이 동작하는 알고리즘에 따르면 swarm ID와 가장 유사한 ID를 가진 peer finder가 F에 의해서 선출되고, 선출된 peer finder는 swarm과 새로운 유사 관계를 맺을 수 있기 때문에, 주어진 swarm ID와 가장 비슷한 ID를 가진 peer finder가 해당 swarm에 속한 peer를 찾을 수 있을 가능성이 높아진다.
- 앞의 알고리즘은 F가 이미 peer finder 네트워크에 속해 잇다는 것을 가정한 것이다. 즉, F는 이미 그 네트워크에 속한 peer finder와 연결할 수 있는 방법을 알고 있을 것이다. 처음 설치되는 peer finder가 다른 peer finder를 아는 것은 trarcker가 없는 swarm에서는 .torrent 파일에 tracker의 URL 정보 대신에 하나 또는 여러 peer finder에 대한 연결 정보를 명시한다. 따라서 새로 설치되는 peer finder는 .torrent 파일을 획득하여 다른 peer finder를 발견할 수 있다. 또한 tracker를 사용하는 swarm이 있으면, 그 swarm에 속한 peer는 해당 swarm과 관련된 peer finder 정보를 tracker로부터 획득할 수 있으며, 이러한 정보를 획득한 peer는 finder 연결 정보 교환 과정을 제공하는 비트토렌트 peer protocol을 사용하여 여러 이웃 peer들에게 획득한 peer finder 연결 정보를 알려줄 수도 있다.
- 비트토렌트에서는 공평성을 보장하거나 좋은 네트워크 시티즌쉽을 직접 처리할 수 있는 방법을 사용하는 특이한 점이 있다. 기존의 프로토콜에서는 이러한 부분을 고려하지 않았기 때문에 각 peer의 무분별한 행동은 공평성 문제를 발생시킬 수 있다. 예를 들면, 이더넷 통신에서 이기적인 peer는 더 좋은 성능을 얻기 위하여 다른 peer가 사용하는 지수적 백오프 알고리즘보다 유리한 알고리즘을 사용할 수 있으며, 이기적인 TCP peer는 더 좋은 성능을 얻기 위해 혼잡 제어 기법을 사용하지 않을 것이다.
- 비트토렌트의 좋은 성능은 조각을 업로드하는 peer들의 동작 방식에 의존적이다. 대부분의 비트토렌트 사용자는 최대한 다운로드를 빠르게 하고, 업로드를 최소화하려고 한다. 이러한 이기적인 행동을 억제하기 위해, 비트토렌트 프로토콜은 각 peer가 다른 peer들에게 보상과 처벌을 할 수 있는 메커니즘을 제공한다. 만약 어떤 peer가 자신이 소유하고 있는 파일을 다른 peer에게 업로드하는 행동을 제대로 하지 않으면, 다른 peer는 소유 peer가 자신으로부터 다운로드하는 파일의 전송을 중지시킬 수 있으며, 또한 소유 peer의 파일 전송을 중지하라는 메시지를 다른 peer들에게 보내어 이기적인 행독을 하는 peer를 초크시킨다. 또한 peer가 더 이상 이기적으로 행동하지 않으면, 초크 상태를 해제시킬 수 있는 메시지를 보낼 수도 있다. 또한 초킹 기법은 TCP 성능을 향상시키기 위하여 각 peer가 사용할 수 있는 비트토렌트의 연결 개수를 제한하는 데 사용할 수도 있다.

### 컨텐츠 분배 네트워크
- 일반적으로 사용자가 웹 페이지를 다운로드 할 때, 최초 접속 구간, 최종 접속 수간, ISP 구간에서 병목 현상이 발생할 수 있다. 첫 번째 문제는 사용자가 해결해야 할 문제이나, 두 번째와 세 번째 문제를 처리하기 위해서는 복제를 사용할 수 있다. 이러한 시스템을 컨텐츠 분배 네트워크(CDN)이라 한다.
- CDN의 기본 개념은 대리 서버를 지리적으로 분산시키는 것인데, 일반적으로 대리 서버는 백엔드 서버의 집합으로서 페이지를 캐싱하는 기능을 담당한다. 게다가 다수의 ISP가 한 사이트에 접속하는 것보다는 대리 서버가 모든 백본 ISP에 분산되어 있다면, 각각의 ISP가 웹 서버에 직접 접속하지 않고, 이러한 대리 서버 중의 하나에 접속할 수 있다.
- 대리 서버는 캐시로 보인다. 클라이언트에서 요청한 페이지가 자신에게 없는 경우, 대리 서버는 그 요청을 백엔드 서버로 요청한다. 그러나 실제로 백엔드 서버는 대리 서버가 요구할 때까지 기다리기보다는 그 이전에 대리 서버들에게 자신의 데이터를 미리 복제해 둔다. 동적인 컨텐츠와 마찬가지로 정적인 페이지도 대리 서버에 분산한다. 그러나 클라이언트는 자주 변경되거나, 계산 결과로 만들어지는 컨텐츠에 대해서는 백엔드 서버로 요청을 보내야 한다.
- 지리적으로 널리 분산된 서버들로는 이러한 문제를 완전히 해결할 수는 없다. 이를 해결하기 위해서는 CDN이 `리다이렉터`들을 제공할 필요가 있는데, 리다이렉터는 클라이언트의 요청을 가장 적절한 서버로 전달해 주는 역할을 수행한다. 리다이렉터의 기본적인 목적은 클라이언트의 요청이 가장 빠른 응답시간에 처리될 수 있도록 서버를 선택하는 것이다. 두번째 목적은 시스템이 기반 하드웨어가 지원할 수 있는 초당 요청 수만큼 처리하도록 하는 것이다. 주어진 기간 동안 처리할 수 있는 평균 요청 수는 기본적으로 시스템에 큰 부하가 주어졌을 때 결정된다.
- CDN은 클라이언트의 요청을 어떻게 분산시키는지를 결정하기 위해 몇 가지 인자를 사용한다. 예를 들어, 응답시간을 최소화하기 위해서는, 리다이렉터가 네트워크 근접도를 기준으로 서버를 선택할 수 있다. 이와는 대조적으로 전체 시스템의 성능을 높이기 위해서는, 서버들 사이에서 부하가 균등하게 분산될 수 있도록 균형을 맞춰야 한다. 만약 분산 메커니즘에서 소재지를 고려한다면, 즉 요청된 페이지를 이미 캐시에 가지고 있을 가능성이 있는 서버를 선택한다면, 성능과 응답시간이 모두 향상된다.

#### 메커니즘
- 각 리다이렉터가 모든 가용 서버의 주소를 알고 있다고 가정하자. 실제로는 서버의 변화에 따라 서버의 주소에 대한 최신의 정보를 유지하기 위해 out-of-band 형태의 통신이 발생된다.
- 리다이렉션은 클라이언트에게 서로 다른 서버의 주소를 알려 주도록 DNS를 확장하여 구현할 수 있다. 예를 들어, 클라이언트가 도메인 이름을 조회하고자 요청하면, DNS 서버는 그 사이트를 제공하는 서버 중에서 가장 적은 부하상태에 잇는 웹 서버의 IP 주소로 응답할 수 있다. 다른 방으로는 웹 서버의 집합이 주어졌을 때, 단순하게 라운드 로빈 방식으로 IP 주소를 되돌려 줄 수도 있다. DNS를 기반으로 한 리다이렉션의 기본 단위는 특정 URL이라기보다는 사이트 레벨이 된다. 그러나 내장된 링크를 되돌려 줄 때, 서버는 클라이언트가 해당 객체의 액세스에 가장 적합할 서버의 URL로 다시 지정할 수도 있다.
- 사용화된 CDN은 기본적으로 URL 재지정과 DNS 기반 리다이렉션을 조합하여 사용한다. 확장성을 고려하여, 상위 레벨 DNS 서버는 먼저 지역 레벨 DNS 서버를 지정하고, 지역 레벨 DNS 서버는 실제 서버의 주소를 응답해 준다. 빠른 응답을 위해서는 DNS 서버가 자원 레코드의 TTL을 조정하는데, 20초 정도의 짧은 시간마다 DNS 질의를 보내도록 조정한다. 이렇게 하면 클라이언트가 DNS 질의 결과를 캐시에 저장하지 않게 되므로 가장 최근의 URL과 서버 간의 매핑을 사용하게 된다.
- 리다이렉션의 또 다른 방법으로는 HTTP 리다이렉트 특성을 이용하는 방법이 있다. 클라이언트는 요청 메시지를 서버로 전송하고, 서버는 클라이언트가 그 페이지에 접속하는 데 보다 효율적인 서버를 알려 준다. 그러나 서버 기반의 리다이렉션은 인터넷의 왕복지연시간을 증가시키고, 때로는 리다이렉션 처리로 서버가 과부하 상태에 빠질 수도 있다. 대신 클라이언트 근처에 사용 가능한 노드가 있다면, 그 노드는 요청 메시지를 가로채고, 서버 대신에 클라이언트의 요청에 응답한다. 이러한 경우, 리다이렉터가 사이트 내에서 발생되는 모든 요청이 자신을 통과하도록 하는 위치에 있거나 또는 클라이언트가 프록시 서버의 주소를 명시적으로 설정해 둠으로써 해결할 수 있다.
- 오버레이로서 CDN을 바라보는 관점이 다소 경직되어 있지만, 이들은 매우 중요한 공통 특성을 공유한다. 오버레이 노드와 같이 프록시 기반 리다이렉터는 애플리케이션 계층에서 라우팅을 결정한다. 주소와 네트워크 구성에 대한 지식 대신에, URL과 더불어 서버의 위치와 부하에 대한 지식을 기반으로 HTTP 요청을 포워딩한다. 오늘날 인터넷은 리다이렉트를 직접(클라이언트가 HTTP 요청을 리다이렉터에게 전송하고 이것을 목적지로 전달한다는 의미) 지원하지 않으므로, 리다이렉션은 라다이렉터가 적절한 목적지 주소를 알려 주고 이를 이용하여 클라이언트가 직접 서버에 접속하도록 하는 간접적인 방식으로 구현된다.

#### 정책
- 리다이렉터가 요청을 포워딩하기 위해 사용하는 라운드 로빈 방식 또는 가용 서버 중의 하나를 임의로 선택하는 방법이 있다. 이 두 가지 접근 방법은 CDN 전반에 걸친 부하를 균등하게 분포시키는 면에서는 좋은 편이지만, 클라이언트가 인지하는 응답시간을 줄여 주는 면에서는 좋은 편이 아니다.
- 두 가지 기법은 모두 네트워크 근접도를 고려하지 않았으며, 또한 소재지에 대한 정보도 고려하지 않았다. 따라서 동일한 URL에 대한 요청이 서로 다른 서버로 포워딩되고, 선택된 서버의 메모리 캐시에 해당 페이지가 없는 경우도 생길 수가 있다. 이러한 경우 서버가 페이지를 획득하기 위해 디스크를 읽거나 백엔드 서버로부터 페이지를 받아 오게 한다. 전체적인 조정 과정 없이 분산된 리다이렉터의 집합이 동일한 페이지를 동일한 서버에게 요청하기 위하여 해싱 함수를 사용한다. 모든 리다이렉터는 URL을 작은 범위의 값에 매핑하기 위하여 일종의 해싱함수를 사용한다. 이러한 접근 방법의 기본적인 이점은 리다이렉터 간의 통신이 불필요하다는 점이다. 어느 리다이렉터든지 URL을 수신하고, 해싱 프로세서는 동일한 출력을 만들어 낸다.
- 전통적인 modulo 해싱 기법은 이러한 환경에 적합하지 않다. 그 이유는 서버의 수가 변경되면 modulo 연산 결과가 특정 페이지를 동일한 서버에 할당하는 비율을 줄이는 결과를 초래하기 때문이다. 서버의 집합에 자주 변화가 일어나지 않는 한, 서버 집합에 새로운 서버를 추가하여 대량의 재할당을 초래하는 것은 바람직하지 않다.
- consistent hashing 기법은 다른 방법이 될수 있다. 먼저 각 리다이렉터는 모든 서버에 대해서 단위 서클에 해싱한다. 그리고 찾고자 하는 URL은 해시 값과 가장 근접한 서버에 할당된다. 이러한 기법에서 노드가 고장나면, 그 노드의 부하는 단위 서클 상에서 인접 노드로 전달된다. peer-to-peer 네트워크의 경우와 달리, 식별자가 가장 가까운 서버를 찾기 위해서 한 노드에서 다른 노드로 전달할 때, 각각의 리다이렉터는 서버의 집합이 어떻게 단위 서클에 매핑되는지를 알고 있으므로, 각각에 대해 독립적으로 가장 가까운 서버를 선택할 수 있다.
- 이러한 전략은 서버의 부하를 고려하여 쉽게 확장될 수 있다. 리다이렉터가 가용 서버에 대해 현재의 부하 상태를 알고 있다면, 이러한 정보는 완벽하게 최신의 정보로는 유지할 수 없으나, 리다이렉터가 최근 몇 초 동안 각 서버로 포워딩한 요청의 횟수를 셀 수 있고, 이 횟수를 서버의 현재 부하를 추정하는 값으로 사용할 수 있다. URL을 수신하면 리다이렉터는 URL과 각 가용 서버에 대해 해싱하고, 결과 값을 정렬한다. 이렇게 정렬된 목록은 리다이렉터가 가용서버라고 간주하게 될 목록을 정의하게 된다. 그리고 나서 리다이렉터는 목록에서 부하가 특정 임계값 이하인 서버를 찾아 내려간다. 단순한 consistent 해싱에 비해 이러한 접근 방법의 이점은 서버의 순서가 각각의 URL에 따라 다르기 때문에 하나의 서버에 문제가 생기면 그 부하가 다른 서버들로 분산된다는 점이다. 이러한 접근 방법은 캐시 배열 라우팅 프로토콜(CARP)의 기본이 된다.
- 부하가 증가함에 따라 이 기법은 정렬된 목록의 첫 번째 서버를 사용하다가 점차 다른 서버로 요청을 분산시키게 된다. 또한 분주한 서버에서 처리되는 일부 페이지는 덜 분주한 서버로 전달된다.
- 네트워크 근접도를 적어도 두 개의 서로 다른 방법으로 수식에 적용할 수 있다. 서버가 요청에 응답하는 시간을 측정하고, 이 측정값을 이전 알고리즘의 서버부하 인자로 사용함으로써, 네트워크 근접도를 서버의 부하로 생각하는 방법이다. 이러한 방법은 멀리 떨어지고 부하가 큰 서버보다는 가깝고 부하가 적은 서버를 선호하게 된다. 두 번째로는 CARP에서 고려하는 서버의 후보 집합을 인접한 서버로 제한함으로써, 근접도를 계산에 넣는 방법이다. 이때 어려운 문제로는 많은 서버 중에서 인접한 서버들을 결정하는 방법이다. 한가지 방안으로는 클라이언트가 동일한 ISP에서 사용할 수 있는 서버들만을 선택하는 것이다. 좀 더 기교적인 방법으로는, BGP에서 제공되는 자율 시스템의 배치도를 분석하여, 클라이언트로부터 일정 홉 수 내에 존재하는 서버만을 후보 서버로 선택하는 방법이다.
