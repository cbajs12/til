# 네트워크 보안

## 보안 시스템
- 애플리케이션 계층에서 운용되는 시스템으로는 전자 메일 보안을 제공하는 Pretty Good Privacy(`PGP`), 안전한 원격 로그인 기능을 가진 보안쉘(`SSH`)을 들 수 있다. 트랜스포트 계층으로는 IETF의 전달계층보안(`TLS`) 표준과 TLS가 유래된 이전 프로토콜인 `SSL`이 있다. IPsec 프로토콜은 IP 계층에서 운용된다. 802.11i는 무선 네트워크의 링크 계층의 보안을 제공한다.
- 보안 프로토콜은 어떤 암호작성 알고리즘을 사용할지를 변경하는 능력을 가지고 있다. 보안 시스템을 알고리즘에 독립적으로 만드는 것이 좋은 이유는 선호하는 암호작성 알고리즘이 언제든지 사용목적에 대하여 충분히 강하지 못하다고 판명될지 모르기 때문이다. 이 경우 프로토콜의 사양이나 구현을 변경하지 않고도 새로운 알리즘을 신속하게 채택할 수 있다는 것은 좋은 것이다.

### Pretty Good Privacy
- PGP는 전자메일에 보안을 제공하는 데 널리 사용되고 있다. 이것은 인증, 기밀성, 데이터 무결성, 무거절을 제공한다.
- PGP의 기밀성과 수신자 인증은 수신자가 알려진 공개 키를 가지고 있다는 것에 기반을 두고 있다. PGP의 발신자 인증과 무거절은 발신자가 알려진 공개 키를 가지고 있다는 것에 기반을 두고 있다. 이들 공개 키는 인증서와 PKI의 신뢰성이 있는 웹을 사용하여 사전 분배된다. PGP는 인증서에 RSA와 DSS를 사용한다. 이 인증서는 키의 주인이 어떤 암호작성 알고리즘을 지원하고 어떤 것을 선호하는지를 부가적으로 기술한다.
- PGP는 프로토콜과 그 프로토콜을 사용하는 애플리케이션을 동시에 지칭한다. 프로토콜에는 각 방향으로 단 한 번의 메시지 전송만 포함된다.
- alice가 bob에게 이메일로 보낼 메시지가 있는 경우 alice의 PGP 애플리케이션은 먼저 메시지를 alice에 의하여 디지털로 서명하게 한다. MD5나 SHA-1이 디지털 서명에 사용될 수 있는 해시의 일종이다. 그 다음 PGP 애플리케이션은 바로 이 메시지 하나만을 위한 새로운 세션 키를 생성한다. AES나 3DES가 대칭 키 암호기법으로 사용된다. 디지털 서명된 메시지는 세션키를 이용하여 암호화된다. 세션 키 자체는 bob의 공개 키를 이용하여 암호화된 후 메시지에 추가된다. alice의 PGP 애플리케이션은 기존에 bob의 공개 키에 부여했던 신뢰의 수준을 alice에게 상기시켜 준다. 신뢰 수준이란 bob을 위해 보유하고 있는 인증서의 수와 이들 인증서에 서명한 개인들의 신뢰정도에 따라 결정된다. 마지막으로 메시지를 ASCII에 대응되는 표현(SMTP 프로토콜에 적합하도록)으로 변경하기 위하여 base64 코딩이 적용된다. 이메일을 통해 PGP 메시지를 수신하면 bob의 PGP 애플리케이션은 이 절차를 역으로 단계별로 수행하여 원래의 평문 메시지를 추출하고 alice의 디지털 서명을 검증하고, 또한 alice의 공개 키에 대하여 bob이 보유하고 있는 신뢰 정도를 bob에게 상기시켜 준다.
- 이메일은 PGP가 적절한 인증 프로토콜이 이전의 메시지 교환과 무관하게 단일 메시지의 데이터 전송 프로토콜에 내포되도록 허용하는 특이한 성질을 가지고 있다. alice의 디지털 서명은 그녀를 인증하는 데 충분하다. 비록 메시지가 적시에 도착했는지에 대한 증거는 없지만 합법적인 이메일에는 적시라는 개념이 없으며 어찌되었든 세션 키와 이 키로 암호화한 데이터가 동시에 도착했다. 메시지가 원본이라는 증거는 없다. 그러나 bob은 이메일 사용자이며 또한 사람이다. 사람들은 아마도 중복된 메일에 대응할 수 있는 능력이 있을 것이다. alice는 세션 키를 bob의 공개 키로 암호화했으므로 이 메시지를 읽을 수 있는 사람은 오직 bob이라는 것을 확신할 수 있다.

### 보안 쉘
- SSH 프로토콜은 원격 로그인 서비스를 위하여 사용되며 인터넷 초기 Telnet이나 rlogin 프로그램을 대체할 의도로 개발되었다. SSH는 강력한 클라이언트/서버의 인증과 메시지 무결성을 지원하기 위하여 가장 널리 사용되고 있다. SSH 클라이언트는 사용자의 데스크탑에서, SSH 서버는 사용자가 기밀성을 보장받으면서, 로그인하려는 원격 기계에서 수행된다. SSH는 SSH 프로토콜과 이 프로토콜을 수행하는 애플리케이션을 동시에 지칭한다.
- SSH는 신뢰할 수 없는 네트워크를 통해 전달되는 데이터를 암호화하고, 로그인하기 위해 사용하는 인증기법의 능력을 향상시켜 주는 방법을 제공한다.
- SSH 버전2는 `SSH_Trans`(트랜스포트 계층 프로토콜), `SSH_AUTH`(인증 프로토콜), `SSH_CONN`(연결 프로토콜)
- `SSH_Trans`는 클라이언트와 서버 기계 사이에서 암호화된 채널을 제공한다. 이는 TCP 연결 위에서 수행된다. 사용자가 원격기계에 로그인하려면 첫 번째 단게는 이들 두 기계 간에 `SSH_Trans` 채널을 설정하는 것이다. 두 기계가 채널을 설정하기 위해서는 먼저 클라이언트가 RSA를 사용하여 서버를 인증해야 한다. 일단 인증이 되면 클라이언트와 서버는 채널을 통해 전달될 모든 데이터를 암호화하는 데 사용할 세션 키를 설정한다. 이런 개괄적인 설명에는 `SSH_Trans` 프로토콜이 양쪽에서 사용할 암호화 알고리즘을 협상해야 한다는 사실과 같은 몇 가지 세부사항이 생략되어 있다. 예를 들어, AES가 일반적으로 사용된다. 또한 `SSH_Trans`는 채널을 통해 교환되는 모든 데이터의 무결성을 검사하는 기능도 포함하고 있다.
- 생략하기 어려운 문제는 서버를 인증하기 위하여 필요한 서버의 공개 키를 클라이언트가 어떻게 보유하게 되는냐이다. 서버는 연결시에 클라이언트에게 자신의 공개 키를 알려 준다. 클라이언트가 특정 서버에 처음으로 연결하는 경우 SSH 애플리케이션은 사용자에게 이 기계는 전에 한 번도 연결한 적이 없다고 경고하고 그래도 계속하기를 원하는 지 물어 본다. SSH가 서버를 효과적으로 인증하기 전에 이런일을 하는 것은 위험한 것이기는 하나 사용자는 이 질문에 흔히 예라고 대답한다. SSH 애플리케이션은 서버의 공개 키를 기억하고 다음부터 사용자가 같은 서버에 연결할 때 이 저장된 키를 서버가 응답한 키와 비교한다. 이들이 일치하면 SSH는 서버를 인증한다. 그러나 일치하지 않으면 SSH 애플리케이션은 사용자에게 잘못되었다고 경고하고, 사용자는 이 연결을 폐기할 수 있는 기회를 가지게 된다.
- 일단 `SSH_Trans` 채널이 확보되면 다음 단계는 사용자가 서버에게 자신을 인증시키는 것이다. SSH는 이것을 수행하기 위하여 세 가지 다른 기법을 허용한다. 첫째, 두 기계가 보안 채널을 통해 통신하므로 사용자는 단순히 자신의 패스워드를 서버에게 전송하는 것도 무방하다. SSH의 경우에는 패스워드가 `SSH_Trans`에서 암호화된다. 두 번째 기법은 공개 키 암호화를 사용한다. 이 경우 사용자는 이미 서버에게 자신의 공개 키를 등록해 두는 것이 필요하다. 세 번째 기법은 호스트 기반 인증이라 불리는데 기본적으로 사용자가 미리 작성된 신뢰성 있는 호스트의 목록 중에서 어느 것이라 주장하면 자동적으로 서버에서 해당 사용자라고 믿어 주는 방식이다. 호스트 기반 인증에서는 클라이언트 호스트는 처음으로 서버에 접속될 때 서버에게 자신을 인증시켜야 한다.
- SSH를 반드시 이해해야 하는 이유는 사용자가 생성하고 관리해야 하는 모든 키들과 운용되는 정확한 인터페이스들이 OS에 종속적이기 때문이다. 예를 들어, 대부분의 UNIX에서 수행되는 OpenSSH 패키지는 공개/개인 키를 생성하기 위해 사용되는 `ssh-keygen` 명령을 지원한다. 이 키들은 사용자의 홈 디렉토리 아래 `.ssh` 디렉토리에 여러 가지 파일로 저장된다. 예를 들어, `~/.ssh/known_hosts` 파일에는 사용자가 로그인했던 모든 호스트에 대한 키를 기록하고, `~/.ssh/authorized_keys` 파일에는 이 기계에 로그인하려는 사용자를 인증하기 위하여 필요한 공개 키가 저장되며(서버용), `~/.ssh/identitiy` 파일에는 원격 기계에 대하여 사용자를 인증하기 위하여 필요한 개인기들을 보관하고 있다(클라이언트용).
- SSH는 원격 로그인의 보안을 위하여 유용하다는 것이 입증되었고, 이것은 X window나 IMAP 메일 리더와 같이 안전하지 않은 TCP 기반 애플리케이션을 지원하도록 확장되었다. 이 아이디어는 이들 애플리케이션들을 안전한 SSH 터널을 통해 수행하는 것이다. 이런 기능을 `포트 포워딩`이라 하는데 여기서는 `SSH_CONN` 프로토콜이 사용된다. 호스트는 자신의 트래픽을 SSH 연결을 통해 전달함으로써 상대방 호스트의 서버와 간접적으로 통신하는 아이디어이다. 이 기술을 포트 포워딩이라 하는 이유는 메시지가 서버의 알려진 SSH 포트를 통해 도착하면 SSH는 먼저 내용을 해독하여 이를 서버가 듣고 있는 실제 포트로 포워딩하기 때문이다.

### 트랜스 포트 계층 보안
- 웹에서의 트랜잭션 처리에서도 프라이버시, 무결성 그리고 인증이 필요하다. 이 문제에 대한 해결책으로 널리 사용되는 첫째가 SSL(보안 소켓 계층)이다.
- SSL과 TLS의 설계자는 이 문제가 HTTP를 사용하는 웹 트랜잭션에만 국한된 것이 아니라 애플리케이션 프로토콜(HTTP)과 트랜스포트 프로토콜(TCP등) 사이에 위치한 범용 프로토콜을 만든다는 것을 인식하게 되었다. 트랜스포트 계층 보안이라고 부르는 이유는 이 프로토콜 계층이 안전하다는 사실을 제외하고는 일반 트랜스포트 프로토콜 계층과 비슷하기 때문이다. 즉 발신자가 연결을 설정하고, 전송될 바이트들을 전달하면, 보안 트랜스포트 계층은 필수적인 프라이버시, 무결성, 인증을 보장하면서 수신자에게 이 바이트들을 전달할 것이다. TCP 위에서 안전한 트랜스포트 계층을 구동시킴으로써 TCP의 모든 일반적인 특징들 또한 애플리케이션에 제공된다.
- HTTP가 이러한 방법으로 사용될 때 이를 `HTTPS`라 한다. 사실 HTTP 자체는 변하지 않는다. 단순히 데이터를 전송하고 데이터를 수신하는데, 기존의 TCP가 아닌 TLS 계층으로부터 데이터를 보내고 받는다. 편의상 디폴트 TCP 포트가 `HTTPS(443)`에 할당되어 있다. 즉, TCP 포트 443으로 서버에 접속하는 경우, 아마도 TLS 프로토콜과 교신하게 될 것이고, 이 TLS 프로토콜은 인증과 해독 과정을 거쳐 HTTP에게 데이터를 전달할 것이다. SSL/TLS의 독자적인 구현도 나와 있지만 더 많은 경우 이들을 사용하는, 특히 웹 브라우저와 같은 애플리케이션과 통합되어 구현되는 것이 일반적이다.

#### 핸드쉐이크 프로토콜
- 한 쌍의 TLS 참여자들은 수행시 그들이 사용할 암호작성 방식을 협의한다. 참여자들이 협의하는 것들은 데이터 무결성을 위한 HMAC의 구현에 사용할 해시(MD5/ SHA), 기밀성을 위한 대칭 키 암호기법 선택(DES, 3DES, AES), 세션 키 설정 기법 선택(Diffie-Hellman, 고정 Diffie-Hellman, RAS나 DSS를 활용한 공개 키 인증 프로토콜)이 있다.
- 참여자들은 압축 알고리즘의 사용도 같이 협상할 수 있다. 그 이유는 이 기법이 다른 것들을 협상하는 동안 부가적인 협상을 하기 쉽기 때문이며, 보안을 위하여 이미 데이터에 고비용의 바이트 연산을 하기로 결정한 상태이기 때문이다.
- TLS에서 기밀성을 위한 암호기법은 각 방향마다 하나씩 두 개의 키와 그리고 이와 유사한 두 개의 초기 벡터를 사용한다. HMAC는 두 참여자에 대하여 서로 다른 키를 사용한다. 따라서 암호기법과 해시의 선택과 무관하게 TLS 세션에는 6개의 키가 필요하다. TLS는 이들 키를 하나의 고유 `마스터 비밀`로부터 얻는다. 마스터 비밀은 384비트(48바이트)  값으로 TLS의 세션 키 설정 프로토콜의 결과 얻어지는 세션 키의 일부분에서 추출된다.
- TLS에서 선택사항에 대하여 협상하고 공유 마스터 비밀을 설정하는 부분을 `핸드쉐이크` 프로토콜이라 한다.(실제로 데이터를 전송하는 부분은 TLS의 `record 프로토콜`이 담당한다). 핸드쉐이크 프로토콜은 세션 키 설정의 핵심이며 세션 키 대신에 마스터 비밀을 가지고 수행된다. TLS는 공개 키 인증서로부터 Diffie-Hellman까지 다양한 세션 키 설정 기법의 선택을 지원한다. 따라서 이들과 대응되는 다양한 프로토콜도 지원한다. 더 나아가 핸드쉐이크 프로토콜은 양 참여자들의 상호 인증하는 경우와 한 참여자만 인증하는 경우(일반적인 경우, 웹사이트를 인증하는 경우), 혹은 전혀 인증하지 않는 경우(익명 Diffie-Hellman) 중에서도 선택 가능하다. 따라서 핸드쉐이크 프로토콜이란 여러 가지 세션 키 설정 프로토콜들을 하나의 프로토콜에 함께 결합한 프로토콜이다.
- 클라이언트는 먼저 자신이 지원하는 암호작성 알고리즘의 조합을 선호도에 따라 내림차순으로 정리한 목록을 보낸다. 서버는 클라이언트가 정리한 목록에서 선택된 하나의 암호작성 알고리즘 조합을 클라이언트로 답변해 준다. 이 메시지에는 각각 클라이언트 nonce와 서버 nonce가 포함되어 있으며 이들은 나중에 마스터 비밀을 생성하기 위하여 사용된다.
- 이 단계에서 협상은 완료된다. 이제 서버는 세션 키 설정 프로토콜을 기반으로 부가적인 메시지를 전송한다. 이 단계에는 공개 키 인증서나 Diffie-Hellman 매개변수들을 전송하는 것도 포함된다. 서버에서 클라이언트의 인증이 필요하면 서버는 이를 요청하는 다른 메시지를 보낸다. 그러면 클라이언트는 협의된 키 교환 프로토콜의 일부를 통하여 답변해 준다.
- 이제 클라이언트와 서버는 마스터 비밀을 생성하는 데 필요한 정보를 각자가 가지게 되었다. 그들이 교환한 세션 키는 실제로는 키가 아니고, TLS에서 `premaster 비밀`이라 부르는 값이다. 마스터 비밀은 이 premaster 비밀 값, 즉 클라이언트 nonce와 서버 nonce로부터(MD5와 SHA 모두를 활용한 발표된 공식을 이용) 계산된다.
- 마스터 비밀에서 유도된 키들을 이용하여 클라이언트는 이전의 모든 핸드쉐이크 메시지의 해시를 포함하는 메시지를 서버에게 보낸다. 여기에 서버도 이와 유사한 답변을 보내 준다. 이 과정을 통해 그들은 주고 받았던 메시지에 어떤 불일치가 있었는지를 탐지할 수 있다. 예를 들어, 만약 중간자가 암호작성 알고리즘 선택을 약화시키기 위하여 초기의 암호화되지 않은 클라이언트 메시지의 내용을 수정했었다면 이 단계에서 탐지될 것이다.

#### 레코드 프로토콜
- 핸드쉐이크 프로토콜이 세션을 설정하는 동안 TLS의 레코드 프로토콜은 트랜스포트 프로토콜에 기밀성과 무결성을 추가해 준다. 애플리케이션 계층에서 내려온 메시지들은 다음 단계를 위하여 편리한 크기의 블록으로 단편화되거나 조합된 것, 압축되는 것, HMAC를 이용하여 무결성을 보장, 대칭 키 암호기법을 이용하여 암호화, 전송되기 위하여 트랜스포트 계층으로 전달의 내용을 가지고 있다.
- 레코드 프로토콜은 HMAC을 인증인자로 사용한다. HMAC은 MD5나 SHA-1을 사용하는데 이는 참여자들 간에 협의되어야 한다. 클라이언트와 서버는 HMAC을 계산하는 데 있어 서로 다른 키를 사용하기 때문에 이를 깨는 것은 어렵다. 또한 각 레코드 프로토콜 메시지에는 연속번호가 부여되는데 이것들이 HMAC을 계산할 때 포함된다. 이 연속번호는 메시지에 명시적으로 포함되지 않는다. 이런 묵시적인 연속번호는 메시지가 중복되거나 순서가 바뀌는 것을 방지해 준다. 이 기능이 필요한 이유는 비록 TCP가 일반적인 가정 하에서는 순차적이고 중복이 없는 메시지를 보장하지만, 이 가정은 적대자가 TCP 메시지를 가로채고 가짜 메시지를 보내는 상황까지 포함하는 것은 아니기 때문이다. 한편 TLS가 순서에 따른 다음 묵시적 순서번호를 가진 합법적인 TLS 메시지에 기반을 하는 것이 가능한 것은 TCP가 전송을 보장하고 있기 때문이다.
- TLS 프로토콜의 다른 기능은 세션을 복구하는 능력이다. 서버로부터 이미지나 텍스트의 페이지를 가져오는 데 사용하는 각 HTTP 연산에는 새로운 TCP 연결의 설정이 필요하다. 많은 그래픽 객체들을 포함하는 페이지를 가져오기 위해 많은 TCP 연결들이 필요할 것이다. TCP 연결은 실제 데이터 교환되기 전에 3단계 핸드쉐이크가 요구된다. TCP 연결이 데이터를 교환할 준비가 된 후에도 클라이언트는 실제 애플리케이션 데이터가 전송되기 전에 적어도 두 배의 RTT(데이터 처리 자원과 네트워크 대역폭을 소비하는) 시간이 소요되는 TLS 핸드쉐이크 프로토콜을 시작해야 한다. TLS의 복구 기능이 이 문제를 완화시킨다.
- 세션 복구는 클라이언트와 서버가 과거에 공유 상태를 이미 설정해 두었을 경우 사용할 수 있는 핸드쉐이크의 최적화이다. 클라이언트는 단순하게 초기 핸드쉐이크 메시지에 이전에 설정된 세션의 세션 ID를 포함한다. 서버가 자신이 여전히 그 세션에 대한 상태를 보유하고 있다는 것을 발견하고 그 세션이 생성될 때 세션 복구 옵션이 선택되어 있었다면, 서버는 클라이언트에게 성공이라 답변하고, 이전에 협상된 파라미터와 알고리즘을 사용해서 데이터 전송을 시작할 수 있다. 세션 ID가 서버에 저장된 어떤 세션 상태와도 일치하지 않거나 그 세션은 복구가 허용되지 않는다면, 서버는 일반 핸드쉐이크 과정으로 되돌아간다.

### IP 보안
- IPsec의 지원은 IPv4에서는 선택사항으로 IPv6에서는 필수사항으로 정의되었다.
- IPsec은 세 단계의 자유를 제공한다. 첫째로 고도로 모듈화되어 사용자가 다양한 암호화 알고리즘과 특별한 보안 프로토콜들 중에서 자유롭게 선택할 수 있도록 한다. 둘째로 IPsec은 사용자가 접근제어, 무결성, 인증, 원본성, 기밀성을 포함하는 보안 서비스의 방대한 메뉴 중에서 선택하는 것을 허용한다. 셋째로 IPsec은 좁은 스트림과 넓은 스트림 모두를 보호하기 위해서 사용될 수 있다.
- 개괄적인 관점에서 보면, IPsec은 두 부분으로 구성된다. 한 부분은 유효한 보안 서비스를 구현하는 두 가지 프로토콜이다. 이들은 접근제어, 비연결성 메시지 무결성, 인증과 반재생 방지와 같은 기능을 제공하는 인증 헤더(AH)와 이 서비스에 기밀성까지 보장하는 캡슐화된 보안 페이로드(ESP)이다. AH는 거의 사용되지 않는다. 두 번째 부분은 키 관리에 대한 지원인데 이것은 ISAKMP라고 알려진 프로토콜을 활용하고 있다.
- 이 두 분을 함께 결합한 추상적인 개념이 바로 `보안 연합(SA)`이다. SA는 하나 이상의 가능한 보안 서비스에 의하여 보호되는 단방향 연결이다. 한 쌍의 호스트들 간에 양방향 통신의 보안을 위해서는 각 방향으로 하나씩 두 개의 SA가 필요하다. IP는 비연결성 프로토콜이지만 보안은 키나 순서번호와 같은 연결 상태 정보에 의지한다. SA가 생성되면 이를 수신한 기게는 SA에 `보안 매개변수 인덱스(SPI)`를 부여한다. 이 SPI와 목적지 IP 주소의 조합으로 특정 보안 연합을 식별할 수 있다. ESP의 헤더에 SPI를 기록하여 수신 호스트는 이 정보를 이용하여 수신된 패킷이 어느 SA에 속하는지를 알 수 있으며, 따라서 어떤 알고리즘과 키가 그 패킷에 적용해야 할지도 결정할 수 있다.
- SA는 ISAKMP에 의해 설정되고, 협상되며, 수정되고, 삭제된다. 그것은 키 생성이나 데이터의 인증을 위하여 교환될 패킷의 형식을 정의한다. 이 형식은 단지 골격만을 제공하는 것이다. 키나 인증 데이터의 정확한 형태는 사용되고 있는 키 생성 기술, 암호화 알고리즘, 인증 메커니즘 등에 따라 결정된다. 또한 ISAKMP는 특정 키 교환 프로토콜을 지정하고 있지는 않지만 인터넷 키 교환(IKE)을 하나의 기술로 제안하고 있다. IKE는 실제 사용되는 프로토콜이다.
- ESP는 설정된 SA를 통해 데이터를 안전하게 전달하는 데 사용되는 프로토콜이다. IPv4에서 ESP 헤더는 IPv4 헤더 다음에 삽입되고, IPv6에서는 확장 헤더의 형태로 제공된다. ESP의 형식은 헤더와 테일로 구성된다. `SPI` 항은 수신 호스트가 해당 패킷이 어느 SA에 속하는지를 판단하는데 사용한다. `SeqNum` 필드는 재생 공격으로부터 보호하기 위하여 사용한다. 패킷의 `PayloadData`에는 `NextHdr` 필드에서 기술하고 있는 데이터를 포함하고 있다. 기밀성 기능이 선택되엇다면 데이터는 SA와 연계된 어떤 암호기법을 사용하여 암호화될 것이다. `PadLength` 필드는 데이터에 추가된 패딩의 크기를 알려준다. 패딩은 때때로 필요한데 그 이유는, 예를 들어 어떤 암호기법에서 평문은 항상 특정 바이트 수의 배수가 되어야 한다든지 혹은 생성된 암호문이 항상 4바이트 단위로 정리되어야 하는 경우가 있기 때문이다. 마지막으로 `AuthenticationData` 필드에는 인증인자가 들어간다.
- IPsec은 직접적인 `트랜스포트 모드`와 더물어 `터널 모드`도 지원한다. 각 SA는 이 모드 중 하나의 모드로 동작한다. 트랜스포트 모드 SA에서 ESP의 페이로드 데이터는 단순히 UDP나 TCP와 같은 상위계층의 메시지이다. 이모드에서 IPsec은 SSL/TLS가 TCP와 상위계층 사이에 끼어 있는 것과 비슷하게 중간 프로토콜 계층처럼 동작한다. ESP가 메시지를 수신하면 그 페이로드는 상위 계층으로 전달된다.
- 그러나 터널모드 SA에서는 ESP의 페이로드 데이터 자체가 IP 패킷이다. 이 내부의 IP 패킷의 발신지나 목적지 주소는 외부 IP 패킷의 그것과 다를 수 있다. ESP 메시지가 수신되면 그의 페이로드는 일반적인 IP 패킷과 같은 방식으로 포워딩된다. ESP를 사용하는 가장 대중적인 방법 중 하나가 두 라우터, 일반적으로 방화벽 사이에 IPsec 터널을 만드는 것이다. 예를 들어, 발신 라우터의 IP 패킷은 상대 라우터로 보내는 ESP 메시지의 페이로드가 된다. 수신 라우터는 이 메시지의 포장을 풀어 그 페이로드 IP 패킷을 실제 목적지로 포워딩한다.
- 또한 이 터널은 ESP가 기밀성과 인증을 사용하도록 구성하여, 이 가상 링크 상에서 교환되는 데이터에 대한 부정한 접근을 방지함으로써 이 터널의 다른 쪽 끝에서는 위조된 데이터를 받는 일이 없도록 보장할 수 있다. 또한 터널은 여러 개의 흐름을 하나의 터널로 통합하므로 터널의 단말들 간에 얼마나 많은 트래픽 흐름이 잇는지가 모호하게 되므로 트래픽 기밀성도 보장할 수 있다. 이런 터널의 네트워크로 오나전한 VPN을 구축할 수도 있다. VPN을 통해 통신하는 호스트는 VPN의 존재를 인식할 필요가 없다.

### 무선 보안(802.11i)
- 무선 링크는 물리적인 보안이 전혀 없으므로 보안에 노출되기 쉽다. IEEE 802.11i 표준은 링크 계층에서 802.11(Wifi)에 인증, 메시지 무결성, 기밀성을 제공한다. `WIFI Protected Access2(WPA2)`는 흔히 802.11i와 동의어로 사용되지만 기술적으로는 WPA2는 제품이 802.11i에 적합한지 검증해주는 WiFi Alliance의 등록상표이다.
- 기존의 표준들과의 호환성을 위하여 802.11i는 1세대 보안 알고리즘(WEP)와 802.11 개체인증을 포함하고 있다. 그러나 이 프로토콜에 대한 주요한 보안의 허점이 현재 잘 알려져 있다.
- 802.11i 인증은 두 가지 모드를 지원한다. 두 모드에서 성공적인 인증의 최종 결과는 공유되는 한 벌의 마스터 키이다. 개인적 모드는 `사전공유 키(PSK)` 모드로 알려져 있으며 약한 보안을 제공하지만 가정용 802.11 네트워크와 같은 환경에서는 훨씬 편리하고 경제적이다. 무선 기기와 접속점(AP)은 공유된 `passphrase`로 사전 설정되어 있다. 여기에서 한 벌의 마스터 키가 암호작성 방식으로 추출된다.
- 802.11i의 더 강력한 인증모드는 LAN 접속을 제어하기 위하여 IEEE 802.1X 골격에 기반을 두고 있다. 이 모드는 인증 서버(AS)를 이용한다. AS와 AP는 반드시 보안 채널을 통해 연결되어야 하며 동일한 호스트를 공유하기도 한다. AP는 무선기기와 AS 사이에서 인증 메시지를 전달해 준다. 인증을 위해 사용되는 프로토콜은 `확장 인증 프로토콜(EAP)`이다. EAP는 다양한 인증 수단(스마트카드, Kerberos, 공개 키 인증 등)을 지원하기 위하여 설계되었다. 따라서 EAP는 프로토콜이라기보다는 인증을 위한 골격으로 생각해야 한다. 많은 것들 중 특히 EAP에 적합한 프로토콜들을 `EAP 기법`이라 한다. 예를 들어, EAP-TLS는 TLS 인증에 기반을 둔 EAP 기법이다. 802.11i는 인증을 위하여 어떤 EAP 기법을 기반으로 할 것인지에 대한 제한을 두지는 않으나 상호 인증을 수행할 수 있는 프로토콜이 필요하다. 이는 적대자가 AP를 통해 네트워크에 접속하는 것을 방지하고 동시에 적대자가 가짜의 악의적 AP로 무선기기를 속이는 것도 방지해야 하기 때문이다. 성공적인 인증의 결과는 무선기기와 AS 사이에서 공유하는 한 벌의 마스터 키이다. AS는 이것을 AP로 전달해 준다.
- 한 벌의 마스터 키를 가지고 무선기기와 AP는 한 벌의 임시 키를 설정하기 위하여 4-way 핸드쉐이크라는 세션 키 설정 프로토콜을 수행한다. 한 벌의 임시키는 실제로 일시적인 키로 불리는 세션 키를 포함하는 키의 모임을 의미한다. 세션 키는 `CCMP`라는 프로토콜에서 802.11i의 데이터 기밀성과 무결성을 제공하기 위하여 사용된다.
- CCMP는 CBC-MAC 프로토콜에서의 CTR(카운터 모드)을 의미한다. CCMP는 기밀성을 위하여 암호화할 때 AES의 카운터 모드를 사용하는 것이다. 카운터 모드 암호화에서 카운터의 연속된 값들이 평문의 연속된 블록의 암호화에 적용된다.
- CCMP는 메시지 인증 코드(MAC)를 인증인자로 사용한다. CCMP는 CBC를 기밀성을 위한 암호화에 사용하지 않지만 MAC 알고리즘은 CBC를 기반으로 한다. 사실 CBC는 CBC로 암호화된 블록을 전송하지 않은 채 수행된다. 단지 마지막 CBC 암호화 블록이 MAC으로 사용된다. 초기화 벡터의 역할은 특별히 제작된 첫 번째 블록에 의해 수행된다. 이 블록에는 48비트의 패킷번호, 즉 연속번호가 포함된다(패킷번호는 기밀성 암호화에 포함될 수 있으며 이 경우는 재생 공격에 노출될 수 있다). MAC은 평문과 함께 연속적으로 암호화될 수 있다. 이것은 동일한 인증인자를 가진 다른 메시지를 발견할 수 있는지와 관련 있는 생일공격을 방지하기 위해서이다.
