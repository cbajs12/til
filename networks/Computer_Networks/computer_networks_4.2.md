# 인터네트워킹

## 라우팅
- 포워딩은 패킷을 받고 그 목적지를 주소를 보고, 테이블을 참조하고, 테이블에 의해 결정된 방향으로 패킷을 보내는 과정을 일컫는다. 라우팅이란 포워딩 테이블을 만드는 과정이다. 라우팅은 복잡한 분산 알고리즘에 의해 수행된다.
- 포워딩 테이블과 라우팅 테이블은 혼용되기도 하지만 포워딩 테이블은 패킷이 포워딩될 때 사용되므로 포워딩 기능을 수행하기 위한 충분한 정보를 가지고 있어야한다. 네트워크 번호와 다음 홉의 이더넷 주소같은 MAC 정보가 포함되야 한다. 반면, 라우팅 테이블은 포워딩 테이블을 구성하기 위한 선행자로서 라우팅 알고리즘에 의해 구성된다. 네트워크 번호와 다음 홉의 대응 관계가 포함된다. 또한 해당 정보를 어떻게 배웠는지에 대한 정보도 포함되어 언제 이 정보를 폐기해야하는 지를 결정할수 있다.
- 포워딩 테이블은 패킷을 포워딩할 때 네트워크 번호를 찾는 과정을 최적화할 수 있는 구조로 될 필요가 있고, 라이팅 테이블은 토폴로지의 변화를 계산하기 위해 최적화될 필요가 있다.
- 현재 인터넷에서 사용되고 있는 계층적 라우팅 구조에서의 구성요소로 도메인 내부 라우팅 프러토콜 혹은 인터리어 게이트웨이 프로토콜(IGP)로 알려진 프로토콜을 사용한다. 
- 라우팅 도메인은 동일한 관리 제어 하에 있는 라우터로 구성된 인터네트워크이다.

### 그래프로 표현된 네트워크
- 라우팅은 본질적으로 그래프 이론의 문제이다.
- 노드는 호스트, 스위치, 라우터등이 될수 있다. 에지는 네트워크 링크에 해당된다.
- 라우팅에서 기본적인 문제는 두 노드 사이에 최소 비용 경로를 찾는 것이다.
- 간단한 네트워크의 경우에는 모든 최단 경로를 계산하고 이 값을 각 노드의 비휘발성 저장장치에 담아두는 방법을 생각할수 있지만 이러한 정적인 방법은 장애에 대처가 안되며, 새로운 노드 및 링크의 추가를 고려하지 않으며 과도한 부하가 걸리는 링크에는 큰 비용을 할당해야 하지만 비용 변화를 시키지 못한다.
- 이러한 문제 때문에 실제 네트워크에서 라우팅은 노드 간에 라우팅 프로토콜을 수행하여 이루어진다. 이들 프로토콜은 링크와 노드의 장애가 있고 에지의 비용이 변화되는 환경에서 최소 비용 경로를 찾아내는 문제에 대한 분산적이고 동적인 방법을 제공한다.
- 분산을 원활하게 동작하도록 만들기 위한 것에는 많은 문제들이 있다. 그 중 하나는 분산 알고리즘에서는 두 개의 라우터가 어떤 순간에 특정 목적지로 가는 가장 짧은 길에 대해서 서로 다른 판단을 할수도 있기 때문이다.

### 거리 벡터 알고리즘
- 각 노드는 모든 다른 노드에 대한 거리를 갖는 1차원 배열을 구성하고 인접한 이웃에게 이 벡터를 전송한다. 
- 거리 벡터 라우팅의 기본 가정은 각 노드가 이웃과 직접 연결하고 있는 각각의 링크 비용을 알고 있다는 것이다. 
- 전체적인 관점은 네트워크의 어떤 지점에서도 얻을 수 없다.
- 초기 테이블은 직접 연결되어 있는 링크에 1의 값을 설정하며, 간접 링크와 동작하지 않는 링크 비용은 무한대로 설정한다. 그후 모든 노드가 직접 연결된 이웃 노드에게 자신의 거리 목록을 담은 메시지를 보낸다. 각 노드는 메시지를 통하여 에지에 대한 비용을 더하거나 무시하면서 비용을 갱신한다.
- 토폴로지의 변화가 없다면 이웃한 노드 사이에 몇 번의 정보 교환으로 각 노드는 완전한 라우팅 테이블을 가진다. 이것을 수렴이라 한다.
- 노드가 이웃에게 갱신 정보를 보내기로 결정하는 상황은 주기적인 갱신과 트리거 갱신이 있다.
- 주기적인 갱신은 각 노드는 아무 변화가 없어도 일정 시간마다 자동적으로 갱신 메시지를 보낸다. 이 서비스는 해당 노드가 아직 동작 중이라는 것을 다른 노드가 알 수 있도록 해준다. 이러한 빈도는 몇초에서 몇분단위가 된다.
- 트리거 갱신은 노드가 이웃으로부터 자신의 라우팅 테이블을 변경해야 하는 갱신 메시지를 받았을 때 발생한다. 노드의 라우팅 테이블이 변화될 때 마다 갱신 메시지를 보내며, 메시지가 이웃의 라우팅 테이블을 변경시키고, 메시지를 받은 노드도 이웃으로 메시지를 전달한다.
- 링크나 노드에 장애가 발생했을 경우 장애를 발견한 노드는 새로운 거리 목록을 이웃에게 보내며, 테이블을 갱신한다. 장애를 감지하는 방법은 노드가 제어 패킷을 보내고 응답이 오는가를 보면서 다른 노드로의 링크를 계속 검사하는 방법이다. 또 다른 방법은 주기적인 라우팅 갱신 메시지를 받지 못하면 장애가 났다고 판단한다.
- count to inifinity: 한 엣지가 장애가 났을때 노드간의 정보 갱신에 문제가 생겨서 어떠한 노드도 장애가 난 노드로 갈 수 없다는 것을 알지 못하고 비용을 무한까지 더하게 되고 그동안 테이블이 안정화 되지 못하는 것을 의미한다. 이것에 대한 부분적 해결 방안중 하나는 무한대의 값을 비교적 작은 숫자를 사용하는 것이다. 이러면 무한까지 걸리는 시간이 줄어든다. 또다른 방법은 `수평 분할`이 있다. 
- 수평 분할은 어떤 노드가 라우팅 갱신 메시지를 이웃에게 보낼때 특정 이웃으로부터 알게된 경로는 해당 이웃에게 되돌려 보내지 않는 것이다. 이것을 강력하게 변형 시킨것이 `극약처방 수평 분할`이다. 이 방법은 해당 이웃에게 되돌려 보내지만 경로 정보에 부정정보를 넣어 표시한다. 그러나 이 두 방법의 문제점은 두 개의 노드를 포함하는 라우팅 루프에서만 동작한다는 것이다. 보다 큰 네트워크에서는 근본적인 방법이 필요하다.

#### 라우팅 정보 프로토콜
- IP 네트워크에서 가장 널리 사용되는 라우팅 프로토콜 중 하나느 RIP이다.
- 인터네트워크에서 라우터의 목표는 패킷을 어떻게 다양한 네트워크로 포워딩할지를 배우는 것이다. 그러므로 라우터는 다른 라우터로의 도달 비용보다는 네트워크로의 도달 비용을 알려준다.
- 대부분의 패킷은 <네트워크 주소, 거리> 쌍으로 구성되어 있다.
- RIP는 거리 벡터 라우팅을 그대로 구현한 것이다. RIP를 수행하는 라우터는 매 30초 마다 갱신 메시지를 전파하고, 다른 라우터로 받은 갱신 메시지를 이용하여 자신의 라우팅 테이블을 갱신한다.
- RIP는 IP뿐만 아니라 다양한 주소 체계도 지원한다. 브로드케스팅 되는 네트워크 주소는 실제적으로 <주소체계, 주소> 쌍으로 표시된다.
- RIP는 15개 이상의 홉을 갖지 않는 소규모 네트워크에서만 수행될 수 있다는 한계가 있다.

### 링크 상태
- 링크상태 라우팅을 위한 가정은 거리 벡터와 유사하다. 이 기법도 거리 벡터와 같이 각 교환기에게 어떤 목적지에 대한 최소 비용 경로를 알아내기에 충분한 정보를 제공하려는 것이 목표이다.
- 모든 노드는 직접 연결된 이웃에게 어떻게 닿는지 알고 있으며, 이 지식이 모든 노드에게 확실히 배포된다면, 모든 노드는 네트워크의 완전한 맵을 그리기에 충분한 지식을 갖게 된다는 것이 이 라우팅의 기본적인 개념이다. 링크상태 프로토콜은 링크상태 정보를 신뢰성 있게 배포시키는 것과 축적된 모든 링크상태 지식을 통합하여 경로를 계산하는 두가지 기법으로 동작된다.

#### 신뢰성 있는 플러딩
- 라우팅 프로토콜에 참가하는 모든 노드가 다른 모든 노드로부터 링크상태 정보를 확실하게 가져오는 과정이다.
- 기본 개념은 한 노드가 자신의 링크상태 정보를 자신과 직접 연결된 모든 링크로 보내는 것이며, 이 정보를 받은 노드는 이를 자신의 모든 링크로 포워딩한다. 이 작업은 이 정보가 네트워크에 있는 모든 노드에게 도달할 때까지 계속된다.
- 각 노드는 링크상태 패킷(LSP)라고 하는 갱신 패킷을 만든다. 이것은 LSP를 만든 노드의 식별자, 노드와 직접 연결된 이웃 노드의 목록과 각각에 대한 링크 비용, 순서번호 그리고 패킷의 수명(TTL)의 정보를 포함한다. 처음 두 항목은 경로 계산을 가능하게 하기 위해서 필요한 것이고, 뒤의 두 항목은 이 패킷을 모든 노드에게 플러딩하는 작업이 신뢰성을 갖도록 하는 데 사용된다. 여기서 신뢰성이란 서로 상이한 LSP들이 네트워크를 돌아다닐수 있기 때문에 가장 최근의 정보를 받도록 하는 것을 의미한다.
- 인접한 라우터 사이에 있는 LSP 전송은 신뢰성 있는 링크 계층 프로토콜처럼 신뢰성 있는 ACK와 재전송을 사용하여 수행될 수 있다.
- 노드는 받은 LSP에서 저장되있음을 파악한다. 저장되지 않았다면 저장하고, 이미 저장된 정보라면 순서번호를 비교하여 큰 순서번호의 것을 최신이라고 판단하고 교체한다. 그외의 정보는 버린다. 받은 LSP가 새로운 것이라면 노드는 LSP를 보낸 노드를 제외하고 나머지 모든 이웃에게 LSP의 사본을 전송한다.
- 한 노드의 새로운 LSP의 생성은 주기적인 시간의 경과나 토폴로지의 변화에 의하여 발생할 수 있다. 토폴로지의 변화에 근거하여 LSP를 생성하는 경우는 이웃 노드가 없어지거나 장애가 있을 경우 뿐이다. 각 노드는 주기적인 시간 간격을 두고 이웃에게 hello 패킷을 전송한다. 오랜 시간 이 패킷을 못받는다면 이 사실을 알리기 위해 LSP를 생성한다.
- 플러딩 구조에서 중요한 목표는 가능한 빨리 모든 노드에게 플러딩 되어야 하고, 오래된 정보는 제거 되고, 순환되지 않도록 해야 한다는 것이다. 또한, 네트워크로 전송 되는 라우팅 트래픽의 총량은 최소하되는 것이 바람직하다.
- 라우팅 트래픽을 줄이는 쉬운 방법은 필요할 때만 LSP를 생성하는 것이다. LSP의 주기적인 생성기간을 매우 길게 하는것인데 토폴로지가 변화될 때의 플러딩 프로토콜의 신뢰성이 보장된다면, 주기적 메시지를 자주 보낼수 필요가 없다.
- 새로운 정보가 오래된 정보를 대체하도록 보장하기 위해 LSP는 순서번호를 사용한다. 각 노드는 새로운 LSP를 주기적으로 생성한다. 새로운 LSP 생성할 때, 순서번호는 1씩 증가된다. 이러한 순서번호는 중복적으로 사용되면 안되므로 이 항은 매우 커져야한다. 노드가 꺼졌다가 다시 켜지면 순서번호는 0부터 시작한다. 노드가 오랫동안 꺼져있다면 노드는 그 노드로부터 나온 모든 과거의 LSP는 타임아웃될 것이다.
- LSP는 또한 TTL을 전달한다. 오래된 링크상태 정보가 네트워크로부터 제거되는 것을 보장하기 위해 사용된다. 노드는 새로 받은 LSP를 이웃에게 플러딩하기 전에 항상 TTL을 감소시킨다. TTL이 0이 될때 노드는 이 LSP를 다시 플러딩한다 이럼으로써 네트워크에 있는 모든 노드에게 LSP를 제거하라고 신호를 보낸다.

#### 경로 계산
- 한 노드가 다른 노드로부터 LSP 사본을 받았을 때, 이 노드는 네트워크 토폴로지의 완전 맵을 계산할 수 있으며, 이 맵으로부터 각 목적지에 대한 최선 경로를 결정할 수 있다. 이 결정 방법은 다익스트라 최단 경로 알고리즘에 기초한다.
- 각 교환기는 포워드 검색 알고리즘이라고 하는 다익스트라 알고리즘의 구현을 이용하여, 수집된 LSP들로부터 직접 라우팅 테이블을 계산한다.
- 각 교환기는 Tentative와 Confirmed이라는 목록을 유지한다. 각 목록은 목적지, 비용, 다음 홉의 형태를 갖는 항목의 집합을 포함한다.
- 1) Confirmed 목록은 자신 자신에 대한 항목으로 초기화된다. 항목의 비용은 0이다.
- 2) 바로 앞 단계에서 Confirmed에 추가된 노드(Next)에 대해 해당 노드의 LSP를 선택한다.
- 3) Next의 각 이웃에 대해, 자신으로부터 Next까지의 비용과 Next에서 이웃까지 비용의 합으로 이웃까지의 비용을 계산한다. 이웃이 목록 두개에 모두 포함되어 있지 않다면, 이웃과 비용, 자신으로부터 Next까지로 향하는 방향을 Tentative 목록에 추가한다. 이웃이 Tentative 목록에 포함되어 있으며, 계산된 비용이 현재 목록에 들어 있는 이웃의 비용보다 작으면 현재의 항목을 계산된 것으로 대체한다.
- 4) tentative 목록이 비게 되면 종료한다. 그렇지 않으면 Tentative 목록에서 최저 비용을 갖는 항목을 골라 Confirmed 목록으로 이동시키고, 2번 단계로 되돌아간다.
- 링크 상태 알고리즘의 장점은 빨리 안정화 되며, 많은 트래픽을 생성하지 않고, 노드의 장애나 토폴로지의 변화에 빠르게 대응한다. 단점으로는 각 노드에 저장되어야 할 정보의 양이 매우 커질수 있다는 점이다.

#### Open shortest path first protocol
- 링크상태 라우팅 프로토콜로 가장 많이 사용되는 것 중 하나가 OSPF이다. Open은 IETF의 후원하에 생성된 표준을 의미한다. SPF은 링크 상태 라우팅에서 나온 말이다.
- OSPF는 기본적인 링크상태 알고리즘외에도 라우팅 메시지 인증, 부가적인 계층구조 그리고 부하균등을 포함하여 많은 기능을 추가하였다.
- 라우팅 메시지 인증: 어떤 잘못 구성된 호스트가 비용 0으로 전체 네트워크의 모든 호스트에 도달할 수 있다고 선언하는 경우가 종종 있는데 이를 위한 기능이다. 이 잘못된 호스트가 보내는 메시지는 주변의 모든 라우터로 부터 경로설정을 받게 되어 모든 트레픽이 몰리게 된다. 해결 방식은 라우팅의 갱신을 인증받도록 함으로써 피할수 있다. 인증을 위하여 8바이트 패스워드를 사용하는 식이다.
- 부가적인 계층구조: 계층구조는 시스템을 보다 확장성 있게 만드는 기본적인 도구이다. OSPF는 도메인을 지역으로 분할함으로써 부가적인 계층구조를 도입하였다. 이로 인해 도메인 내의 라우터는 그 도메인 내의 모든 네트워크에 도달하는 방법을 알 필요 없이 원하는 지역에 도달할 수 있는 방법만 알고 있으면 가능하다. 따라서 각 노드에 저장되어야 하고 전송되어야 할 정보의 양이 감소된다.
- 부하 균등: OSPF는 동일한 장소에 동일한 비용으로 도착 가능한 다중 경로도 허용하고 있으므로, 이를 통해 통신 부하가 분산되도록 조정할수 있다.
- OSPF 메시지 유형은 여러가지 있지만 헤더는 동일하다. Version 필드는 2로 설정되어 있고, Type 필드는 1~5사이의 값으로 가질수 있다. SourceAddr는 메시지의 송신지를 지정하고 AreaId는 노드가 위치한 지역 32비트 식별자이다. 인증 데이터를 제외한 전체 패킷은 IP 헤더와 같은 알고리즘을 사용하는 16비트 체크섬에 의해 보호된다. Authentication type은 인증이 사용되지 않으면 0, 단순한 패스워드가 사용되면 1, 암호화된 인증 체크섬이 사용되면 2가 된다. Authentication 필드는 패스워드나 암호화된 체크섬을 전송한다.
- OSPF 메시지 유형중 type1은 hello 메시지이며, 연결되어 있다는 것을 알리기 위하여 사용된다. 나머지 유형은 메시지 요구, 송신 그리고 긍정 응답을 하는데 사용된다. 링크 상태 메시지의 기본적인 구성 요소는 LSA이다. 한 메시지에는 많은 LSA가 포함될 수 있다.
- OSPF가 동작하는 라우터는 직접 연결되어 있는 하나 이상의 네트워크들을 브로드캐스팅하는 링크상태 패킷을 생성할 수 있다. 부가적으로, 어떤 링크에 의하여 다른 라우터와 연결되어 있는 라우터는 그 링크를 통해 그 라우터에 도달할 수 있는 비용을 브로드캐스팅해야 한다. 이 두가지 브로드캐스팅은 도메인 내에 있는 모든 라우터가 도메인 내에 있는 모든 네트워크에 대하여 도달 비용과 그 네트워크로 가는 적절한 다음 홉을 결정하기 위해 필요하다.
- Type1 LSA는 라우터 사이의 링크비용을 브로드 캐스팅한다. Type2 LSA는 라우터가 연결되어 있는 네트워크를 브로드캐스팅하기 위해 사용된다. 반면에 다른 Type은 추가적인 계층구조를 지원하기 위해 사용된다.

#### Type1 링크 패킷 구성
- LS Age는 숫자가 증가하여 정의된 최대 값에 도달하면 LSA가 소멸된다는 것만 제외하면 TTL과 같다
- Type은 Type1을 가리키고 Link-state ID와 Advertising router 필드는 이 타입 LSA에서 같다. 각각은 이 LSA를 생성한 라우터의 32비트 식별자로 설정된다. ID를 할당하는 방법은 여러가지 방법이 있을수 있지만, 라우팅 도메인 내에서는 유일해야 하고, 라우터는 지속적으로 동일한 라우터ID를 사용해야만 한다. 
- LS sequence number는 오래되거나 중복된 LSA를 발견하기위해 사용된다.
- LS checksum은 데이터가 망가지지 않았다는 것을 증명하기 위해 사용된다.
- Length는 완전한 LSA 바이트 단위의 길이를 표시한다.
- LSA 내의 각 링크는 LinkID, 몇 개의 Link Data 그리고 metric에 의해 표현된다고 가정하면, 이 필드의 처음 두개로 링크를 식별한다. 식별하는 일반적인 방법은 그 링크의 반대쪽 끝에 연결된 라우터의 라우터 ID를 Link ID로 사용하는 것이다 그리고 나서 필요하다면 Link Data를 사용하여 평행으로 연결된 다중 링크들 중 하나를 식별한다. metric은 링크의 비용이다. Link Type은 링크에 대한 정보(점대점, 토큰링등)를 알려준다.
- TOS정보는 OSPF가 TOS의 값에 따라 IP 패킷이 다른 경로를 선택하게 해준다. 하나의 링크에 하나의 메트릭을 할당하는 대신에, 데이터의 TOS값에 따라 다른 여러 개의 메트릭들을 할당할 수도 있다. 그후에 OSPF는 TOS 필드의 값이 다르게 설정되어 있는 패킷들에 대하여 서로 다른 최단 경로를 선택해 준다.

### 메트릭
- 메트릭(링크 비용)은 몇가지 방법이 있다. 그중 간단한 방법은 모든 링크에게 1의 비용을 할당하는 것이다. 이 경우 최소 비용 경로는 최소 홉을 갖는 것이 된다. 그러나 이런 방법은 몇가지 단점이 있는데, 소요시간을 고려하여 링크를 구분하지 않는다. 즉, 노드가 위성이든 호스트이든 똑같은 것으로 취급한다. 두 번째는 용량을 고려하여 경로를 구별하지 않는다. 마지막으로 현재의 부하를 고려하여 링크를 구별하지 않는다. 따라서 과부하된 링크를 우회하는 것이 불가하다.
- 최초의 ARPANET 라우팅 메트릭은 각 링크로 전송되기 위해 저장되어 있는 패킷의 수로 측정되었다. 그러나 이 방식은 링크의 대역폭과 소요시간을 고려하지 않아 문제가 되었다.
- 개선된 라우팅 기법은 링크 대역폭과 소요시간 모두를 고려하였으며, 패킷의 수가 아닌 지연시간을 부하의 측정값으로 사용하였다. 동작은 각 수신 패킷은 도착시간이 기록되고, 나갈때도 출발시간이 기록된다 그후 링크 레벨의 ACK가 상대 쪽에서 오면, 노드는 해당 패킷의 지연시간을 `지연 = (출발시간 - 도착시간) + 전송시간 + Latency`로 계산한다. 전송시간과 latency는 각각 링크의 대역폭과 소요시간을 의미하여 통계적으로 정의된다. 출발시간은 ACK가 도착하지 않고 패킷이 타임아웃되면 패킷이 재전송 되는 시간으로 재설정된다. 최초의 방법보다는 개선되었지만 부하가 많은 상황에서는 불안정하져 높은 부하에서 많은 링크가 많은 시간을 유휴상태로 소비한다. 또한 링크 값의 범위가 너무 큰것도 문제가 되었다.
- 개선된 ARPANET 라우팅 메트릭은 그전 버전의 문제들을 해결하였다. 메트릭의 동적인 범위를 현저하게 축소하였고, 링크의 종류를 고려하였으며, 시간에 따른 메트릭의 변화를 점진적으로 이루어지게 하였다. 점진적인 변화는 여러 방법에서 이루어지는데 지연시간의 측정값은 링크의 효율로 대체되었고, 갑작스러운 변화를 없애기 위해 이 값을 이전에 보고된 효율과 평균이 되도록 하였다. 두 번째는 한 측정 주기와 다음 주기 사이에서 메트릭이 변화할 수 있는 크기에 제한을 두었다.
- 메트릭 설정에서 널리 통용되는 방식은 상수에 `1/링크 대역폭`을 곱한 값을 사용하는 것이다.

### 이동 호스트를 위한 라우팅
- 호스트가 한 네트워크의 연결이 끊어지고 다른 네트워크에 연결되는 상황을 위하여, 호스트가 새로운 네트워크로 연결될 때 이 호스트에게 새로운 주소를 할당하는 것이다.
- DHCP같은 기술은 새로운 주소 할당을 간단하 과정으로 만들어 준다. 그러나 다른 경우에는 이 방법이 적절하지 않을 수 있다.
- 모든 애플리케이션은 한 종단점이 이동하는 경우에도 지속적으로 수행되어야 하며, 이 동작은 애플리케이션에서 인식하지 못하는 것이 이상적이다. 이 문제를 해결하기 위하여 설계된 절차를 `Mobile IP`라 한다.
- 대부분의 라우터가 변경되지 않고, 이동성 유지를 위해 일부 라우터, 즉 이동 호스트의 `home agent`라는 라우터에만 몇가지 새로운 기능을 추가한다. 이 라우터는 이동 호스트의 home 네트워크에 위치한다. 이동 호스트는 `home address`라고 불리는 하나의 영구적인 IP 주소를 가진다고 가정하고, 네트워크 번호는 home agent의 번화 같다. 이것은 이동 호스트로 패킷을 보낼 때 다른 호스트에 의해 사용될 주소이다. 이것은 변하지 않기 때문에 호스트가 이동하는 동안에도 계속 지속되는 애플리케이션 프로그램에 의해 사용될 수 있다.
- 여러 가지 상황에서, `foreign agent`라는 기능이 추가된 두 번째 라우터가 필요하다. 이 라우터는 이동 노드가 home 네트워크로부터 멀리 떨어져 있을 때 연결되어 있는 네트워크에 위치한다.
- home agent와 foreign agent는 agent 브로드케스팅 메시지를 사용해서 그들이 연결되어 있는 네트워크에 주기적으로 그들의 존재를 알린다. 이동 호스트는 새로운 네트워크에 연결되었을 때 브로드캐스팅을 요청할 수 있다. home agent에 의한 브로드 캐스팅은 이동 호스트가 자신의 home 네트워크를 떠나기 전에 자신의 home agent의 주소를 배울 수 있도록 해준다. 이동 호스트가 foreign 네트워크에 연결되면, 이동 호스트는 foreign agent로부터 브로드캐스트를 듣고, 자신의 home agent 주소를 제공하면서 그 agent에 등록한다. 그러면 foreign agent는 home agent와 접촉하고, care of address를 부여해 준다. 이 주소는 일반적으로 foreign agent의 주소이다.
- home agent가 이동 노드로 가는 패킷을 가로채는 방법은 home agent가 실제적으로 `proxy ARP`라고 불리는 기술을 이용해서 이동 노드의 역할을 맡는다. 이것은 home agent가 ARP 메시지 안에 자신의 주소가 아닌 이동 노드의 IP 주소를 삽입한다는 것을 제외하면 기본 ARP와 같이 동작한다. 이것은 자신의 하드웨어 주소를 사용해서, 같은 네트워크에 있는 모든 노드는 home agent에 있는 하드웨어 주소와 이동 노드의 IP 주소와의 대응을 알게 된다. 이 과정에서 이 ARP 저옵가 네트워크에 있는 다른 노드에 의해 키시될 수도 있다. 이 캐시된 정보가 적절한 시기에 무효화되도록 home agent는 이동 노드가 foreign agent에 등록하고 바로 ARP메시지를 생성한다. 이 ARP 메시지는 정상적인 ARP 요구에 의한 답변이 아니므로 `무상 ARP`라 불린다.
- home agent가 가로챈 패킷을 foreign agent로 전송하기 위해서 터널링 기법을 이용한다. home agent는 foreign agent로 패킷이 전송되도록 IP 헤더로 단순히 패킷을 포장하여 인터네트워크로 전송한다. 모든 중간 라우터들은 foreign agent로 가는 IP 헤더만을 볼수 있다. 다른 각도에서 보면, home agent와 foreign agent 사이에 터널을 구성하고, home agent가 이동 노드로 갈 패킷을 터널을 통해 전송한다.
- 패킷이 foreign agent로 도착하면, foreign agent는 추가된 IP 헤더를 제거하고 이동노드로 전송한다. foreign agent는 이 패킷들이 다시 home 네트워크로 되돌아가야 하는 경우가 발생할지 모르기 때문에 이 패킷들을 기존의 IP 패킷과 같이 다룰 수 없다. 대신에 Foreign agnet는 이 주소를 등록된 이동 노드의 주소로서 인식해야 한다. 그런 다음 패킷을 등록 과정에서 알게 된 이동 노드의 하드웨어 주소로 전송해야 한다.
- foreign agent와 이동 노드가 같은 기계 내에 존재할수 있다. 즉, 이동 노드가 foreign agent 기능을 수행할 수 있다. 이것이 가능하도록 하기 위해 이동 노드는 foreign 네트워크의 주소 공간에 위치한 IP 주소를 동적으로 가질수 있어야 한다. 그런다음 이 주소는 care-of-address로 사용될 것이다. 이동성은 DHCP가 foreign 네트워크에서 사용된다는 가정하에, home agent와 이동 노드에 몇가지 새로운 소프트웨어를 첨가함으로써 이루어질 수 있다.
- 이동 노드에서 고정 노드로의 트래픽은 IP 패킷의 송신자 필드에 변하지 않는 주소를 넣고, 수신자 필드에 고정된 노드의 IP 주소를 넣은 다음, 일반적인 방법을 사용해서 고정 노드에 패킷을 전송하면 된다.

#### 이동 IP의 경로 최적화
- 위의 방법은 중대한 결점이 있는데 송신 노드에서 이동 노드로의 경로가 최적의 경로가 아니라는 것이다. 특히 송신자로부터 home agent를 거쳐 이동 노드로의 경로가 삼각형의 두 변을 형성하고, 세번째 변은 직접 경로를 나타내는 삼각 라우팅 문제가 발생할 수 도있다.
- 삼각 라우팅 문제를 해결하기 위한 기본 개념은 송신 노드가 care-of-address를 알도록 만드는 것이다. 그후 송신 노드는 foreign agent와 터널을 생성할 수 있다. home agent가 이동 노드 중 하나로 패킷을 전송한다면, 이것은 송신자가 최적의 경로를 사용하는 것이 아니라고 추론할 수 있다. 그러므로 송신자에게 foreign agent로 데이터 패킷을 포워딩하는 것에 추가하여, `binding update` 메시지를 보낸다. 이런 기능이 있는 송신자는 binding update 메시지들을 이용하여 binding cache에 새로운 엔트리를 생성하는데, 각 엔트리는 이동 노드의 주소와 care-of address의 대응으로 구성된다. 이 후부터는 송신자는 데이터 패킷을 이동 노드로 전송할 때, 캐시 내의 있는 대응을 검색하여 foreign agent로 직접 패킷을 터널링할 수 있다.
- 만약 이동 호스트가 새로운 네트워크로 이동하는 경우, binding cache에 시간히 경과한 잘못된 내용이 남아 있다면 심각한 문제가 된다. 만약 예전의 캐시 엔트리가 사용된다면, foreign agent는 자신의 네트워크에 더 이상 존재하지 않는 이동 노드에 대한 패킷을 터널을 통해 받을 것이다. 이 경우 이 캐시 엔트리를 더이상 사용하지 말라고 알려주기 위해 송신자에게 binding warning 메시지를 보낸다. 이 방식은 foreign agent가 이동 노드 내에 존재하지 않는 경우에만 사용 가능하다. 이런 이유로 캐시 엔트리는 binding update 메시지 안에서 정의도니 일정 시간이 지나면 지워질 필요가 있다. 정확한 시간은 binding update 메시지에 의해 정해진다.

### 라우터의 구현
- 라우터의 방식들은 스위치의 구조와 비슷하다. 그러나 다른 점도 존재한다.
- 라우터는 가변 길이의 패킷을 처리해야 한다. 이런 제한은 ATM 스위치에는 없었으나 이더넷 스위치나 프레임 릴레이 스위치에는 적용되는 제한이다. 다수의 고성능 라우터는 셀 기반의 스위칭 패브릭을 이용하여 설계된다. 이 경우 각 포트에서는 가변 길이의 패킷을 셀로 변화하는 기능과 그 반대로의 변환 기능이 있어야 한다.(단편화 및 재조립)
- 라우터는 일반적으로 초당 일정한 수의 패킷을 전달할 수 있다. 따라서 초당 비트 수로 표기되는 라우터의 성능은 패킷의 크기에 따라 결정된다.
- pps는 특정 포트에 도달한 패킷이 전송되는 속도이고, 회선속도는 `패킷크기 * pps = 회선속도`이다. 여기의 패킷 크기가 바로 라우터가 회선속도로 전송 가능한 패킷 크기이다. 
- IP 패킷을 포워딩하는 기능에 관하여 라우터는 집중형과 분산형 포워딩 모델로 구분한다.
- 집중형 모델에서는 모든 포트로 들어오는 모든 트래픽에 대하여 하나의 처리 엔진이 IP 포워딩 알고리즘을 수행한다. 
- 분산형 모델에서는 각 포트마다 하나씩 처리 엔진을 가지거나 혹은 하나 이상의 엔진을 가지고 있다. 분산형 모델이 더 많은 처리 능력을 가지고 있으므로 능력이 더 좋지만 각각의 포워딩 엔진 자신의 테이블을 가져야 하므로 제어 프로세서는 포워딩 테이블을 시차 없이 일관성을 유지하도록 갱신해야 하므로 복잡한 소프트웨어 구조를 가진다.
- 라우터가 스위치가 다른 점 또 하나는 IP 라우팅 알고리즘 자체이다. 스위치 알고리즘보다 좀 더 복잡하다. IP 포워딩 알고리즘이 특정 IP 주소가 해당 라우터의 인터페이스를 통해 직접 도달 가능한지 여부와 이 패킷을 다른 라우터로 보내야 하는지를 판단해야 한다. 무계급 주소 체계를 사용하는 현재의 인터넷에서는 포워딩 결정 하기 위하여 검증해야 하는 비트의 수는 1~32사이의 수로 정해진다.
- 네트워크 프로세스는 일반 프로세스와 같이 프로그램이 가능한 부품이지만 더 네트워킹 작업에 최적화 되어 있다.
