# 종단 간 데이터

## 데이터 압축
- 송식 측에서는 데이터를 압축하고, 이후 네트워크에서 전송한 뒤, 수신 측에서 푸는 작업을 하는 것은 중요하다. 여러 가지 면에서 압축은 데이터 인코딩과 불가분의 관계에 있다. 즉, 어떻게 데이터 조각을 비트 모음으로 인코드하는가에서, 가장 최소한의 비트 모음으로 어떻게 데이터를 인코드할 것인가에 대해 생각할 수 있는 것이다. 예를 들어, 일반적으로 기호로 이루어진 데이터 블록에서 각 기호가 발생될 상대적 확률을 안다면, 주어진 데이터 블록을 인코드하는 데 드는 비트 수를 최소화하도록 각 기호에 상이한 개수의 비트를 할당할 수 있다. 이것이 `Huffman 코드`의 기본 개념이다.
- 압축을 위해서는 `무손실 압축`과 `손실 압축`이 있다. 무손실 압축은 압축/풀기 과정으로 재생도니 데이터가 원래 데이터와 정확하게 동일하다는 것을 보장해야 한다. 무손실 압축 알고리즘은 실행코드, 텍스트 파일, 숫자와 같은 데이터 압축에 사용되는데, 이런 데이터의 처리 프로그램은 데이터의 오류를 용납할 수 없기 때문이다. 반면에 손실 압축은 수신된 데이터가 송신된 데이터와 정확하게 같다고 보장하지 않는데, 회복할 수 없는 정보를 제거하기 때문이다. 또한 수신 측에서도 손실된 정보는 요구하지 않는다. 손실 알고리즘은 이미지, 음성, 비디오의 압축에 사용한다. 이런 데이터는 사람이 인자하는 것보다 더 많은 정보가 포함되며, 사람의 두뇌가 보충할 수 있는 오류나 불완전함을 포함할 수도 있기 때문이다. 손실 알고리즘은 일반적으로 무손실 알고리즘보다 뛰어난 압축 비율을 달성하는 것이 가능하다.
- 많은 압축 알고리즘에서 전송을 시작하기도 전에 모든 데이터를 압축 할 필요는 없지만, 어느 정도는 일정량의 데이터를 모아 놓을 필요가 있다.
- 손실 압축 알고리즘에서 프로세스 자원만이 중요한 요인이 되는 것이 아니다. 애플리케이션에 의존하여, 사용자는 대역폭과 압축으로 인한 정보의 손실량 사이에서 상당히 다른 트레이드오프를 만들기 원한다. 예를 들면, x-ray 사진을 읽는 판독기는 화질의 저하를 허용하지 않지만, 무료 통화를 사용하는 사람들은 음질의 적당한 손실은 허용할 것이다.

### 무손실 압축 알고리즘

#### Run Length Encoding(RLE)
- 주어진 기호의 연속적 발생을 하나의 기호로 대체하는 것이다. 거기에 그 기호의 발생 횟수가 몇 개인가를 표시한다. 예를 들면, AABBCDDDD는 3A2B1C4D로 인코딩된다. RLE는 주변의 픽셀이 가지는 값끼리 비교하여 단지 변화량만 인코딩하는 방식으로 디지털 이미지를 압축하는 데 사용할 수 있다. 반복되는 부분이 많은 이미지에서 이 기술은 효과적이다. RLE는 텍스트 파일에 잘 동작되는데, 이러한 파일에는 제거 가능한 여백이 많이 포함되어 있기 때문이다. 그러나 지역적으로 변화가 큰 이미지에서는 압축으로 인해 바이트 수가 늘어나는 경우가 생기는데, 이것은 기호가 되풀이되지 않는 경우 한 기호를 나타내는 데 2바이트가 필요하기 때문이다.

#### Differential Pulse Code Modulation(DPCM)
- 기준이 되는 기호를 선택하고, 데이터 안의 각 기호에 대해 그 기호와 기준 기호와의 차이를 인코딩하는 방법이다. 예를 들면, A를 기준기호를 사용할 때, 문자열 AAABBCDDD는 A000112333으로 인코딩된다. 이 간단한 예는 DPCM의 진정한 효과를 보여주지 못한다. 그 효과란 차이가 적을 경우 그것을 인코딩할 때 원래 기호보다 적은 수의 비트로 인코드할 수 있다는 것이다. 차이가 너무 커지면, 새로운 기준기호를 선택해야 한다.
- 대부분의 디지털 이미지에서 DPCM은 RLE보다 효과적인데, 인근 픽셀이 대개 비슷하다는 사실을 활용하기 때문이다. 이 연관성으로 인해, 주변 픽셀값끼리의 차이가 갖는 변화 범위는 원래의 이미지가 갖는 변화 범위보다 매우 적을 수 있으며, 그래서 이러한 범위를 더 적은 수의 비트로 표현할 수 있는 것이다. DPCM을 사용할 때 디지털 이미지에 대해서는 1.5:1의 압축 비율율을 얻을 수 있다.
- `델타 인코딩`은 기호를 인코딩할 때 바로 앞의 기호와 비교하여 그 차이를 기록하는 방식으로 인코딩한다. AAABBCDDD는 A001011000으로 나타낼 수 있다. 이 방식은 이미지에서 인접한 픽셀이 유사하다는 데 주목한다. 델타 인코딩을 사용한 후에 RLE를 수행하는 것도 가능한데, 서로 같은 연속된 인접한 기호들이 많을 때 연속된 0의 형태로 나타나기 때문이다.

#### 사전 기반 방식
- 이것의 잘 알려진 방식은 Lemple-Ziv(LZ) 압축 알고리즘으로, Unix compress 명령어는 LZ 알고리즘의 일종을 사용한다.
- 데이터 안에 발생될 것이라고 예상되는 가변길이 문자열을 모아서 사전을 만들고, 이 문제열이 데이터 안에 나타날 때마다 사전에서 대응되는 인덱스로 교체하는 것이다. 예를 들어, compression이라는 단어가 48이라는 인덱스를 가진다면 compression 단어가 나올때 마다 48로 교체하는 것이다.
- 물론 문제는 사전을 어디에서 만들어 내는가이다. 한 가지 옵션은 정적인 사전을 정의하는 것인데, 보다 좋은것은 압축하려는 데이터에 맞추어 만드는 것이다. LZ 압축에서 사용하는 것은, 압축하려는 데이터의 내용을 기초로, 적응성이 있도록 사전을 정의하는 것이다. 그러나 이 경우 압축을 푸는 쪽의 알고리즘이 작업을 할 수 있도록, 압축할 때 만들어진 사전을 데이터와 함께 수신 측에 보내야 한다.
- `GIF`에서는 LZ 알고리즘의 변형된 형태를 사용해 디지털 이미지를 압축한다. GIF는 우선 24비트 컬러 이미지를 8비트 컬러 이미지로 줄인다. 이것은 그림에 사용된 색깔의 종류를 가려냄으로써 달성하는데, 일반적으로 2^24보다 훨씬 적은 종류의 색깔이 있으며, 그림에 사용된 색깔에 가장 적합한 256개의 색깔을 고른다. 이 색깔을 표로 저장하면, 8비트로 인덱스할 수 있으며, 인코딩할 때에는 각 픽셀의 값을 적절한 인덱스로 교체한다. 이것은 256색 이상을 갖는 그림에서는 손실 압축의 예가 된다. GIF는 다음으로 이 결과에 LZ 변형을 사용하여, 일반적인 연속된 픽셀을 사전을 참조할 수 있는 문자열로 만든다. 이 방식을 사용하면 GIF는 때때로 10:1 이상의 압축 비율을 달성할 수 있는데, 단 이미지의 변화가 크지 않을 경우에만 그렇다.

### 이미지의 압축
- 디지털 이미지 데이터용으로 설계된 압축 알고리즘을 위한 `JPEG`라는 디지털 이미지 형식을 규정하였다.
- JPEG, GIF, MPEG는 압축 알고리즘일 뿐만 아니라 이미지나 비디오 데이터를 위한 형식도 규정한다.
- 이미지는 한 번에 하나의 8x8 블록으로 만들어져 공급된다. 그리고 첫 단계에서는 DCT 연산을 적용한다. 입력된 이미지를 공간영역의 신호로 생각한다면, DCT는 이 신호를 공간 주파수 영역의 신호로 변환한다. 이 단계는 무손실 연산이나, 다음의 손실 연산을 위해 필수적인 사전작업이 된다. DCT 연산에 이어 양자화를 적용하는 데, 이 동안에는 신호에 포함된 비트 중에서 의미가 적은 비트를 버린다. 세 번째 단계에서는 최종 결과를 인코드하는 데, 이 단계를 수행하면서 앞의 두 단계의 손실 압축에 무손실 압축 과정을 추가하게 된다. 그리고 풀기는 이러한 세 단계의 과정을 반대로 수행하면 된다.

#### DCT 단계
- 이것은 그레이스케일 이미지만을 고려한 것이고, 이미지의 각 픽셀에 그 픽셀의 밝기 정도를 나타내는 8비트 값이 주어지는데, 0은 흰색, 255는 검은색이다.
- DCT는 FFT을 수행하는 변환 과정이다. 이것은 8x8로 된 픽셀값 매트릭스를 받아들여 주파수 계수로 된 8x8의 매트릭스를 내놓는다. 입력되는 매트릭스는 2차원 공간에서 정의되는 64개의 점으로 된 신호로 생각할 수 있다. DCT는 이 신호를 64개의 공간 주파수로 분리한다. 낮은 주파수는 그림의 크고 엉성한 부분에 해당되는 반면, 높은 주파수는 미세하고 세부적인 부분에 해당도니다. DCT의 기본 개념은 이미지의 근본이 되는 윤곽 부분을 보다 덜 근본적인 미세한 부분과 분리하는 것이다.
- 첫 주파수 계수는 출력 매트릭스에서 (0, 0)에 있는데, 이를 DC 계수라고 한다. DC 계수는 64개의 입력 픽셀 평균값을 의미한다. 출력 매트릭스의 다른 63개의 요소는 AC 계수라고 한다. 이것은 이 평균값에 보다 높은 공간 주파수 정보를 더한다. 그러므로 첫 주파수 계수에서 54번째 주파수 계수로 감에 따라, 저주파 정보에서 고주파 정보로, 다시 말해 이미지의 윤곽에서부터 미세하면서도 고운 세부 묘사로 가는 것이다. 이 고주파 계수는 이미지의 식별성에서 보다 덜 중요하기 때문에 어떤 부분의 계수를 버릴것인지 결정하는 것이 양자화이다.

#### 양자화 단계
- DCT 자체로는 정보를 잃어 버리지 않으며, 단지 어떤 정보를 버릴 것인지 결정하기 쉬운 형태로 이미지를 변환한다. 양자화에서는 주파수 계수 중 중요하지 않은 부분을 없앤다.
- 45, 98, 23, 66 ,7과 같은 정수를 압축하려 한다면, 이 숫자들을 10의 배수로 표현해도 충분하다고 결정되면, 각 숫자들을 정수 연산을 사용해 10이라는 `퀀텀`으로 나누게 되는데, 그 결과로 4, 9, 2, 6, 0이 나온다.
- 이 숫자 각각은 원래의 숫자를 인코드하는 데 필요한 7비트 대신 4비트면 인코드할 수 있다. JPEG는 64개의 계수 각각에 쓸 퀀텀을 양자화 테이블로 만들어 사용한다. 이 퀀텀표는 정보를 얼마만큼 버리는가, 그럼에 따라 어느정도 압축이 달성되는가를 조절하는 데 사용되는 매개변수로 생각할 수 있다. 낮은 계수는 1에 가까운 양을 갖고, 높은 계수는 큰 값을 갖는다.
- 양자화 테이블의 결과로 많은 고주파 계수가 양자화되면 0으로 바뀌는 결과가 나오는데, 이것은 제 3단계에서 많은 압축이 이루어질 수 있도록 만든 것이다.

#### 인코딩 단계
- 양자화된 주파수 계수를 더욱 압축하여 인코드하는 것이다. 이 결과로 더욱 압축이 일어나지만, 이 과정은 비손실 과정이다. 위치 (0, 0)에 있는 DC 계수로부터 시작하며, 지그재그 순서로 처리된다. 이 지그재그를 따라가면서 RLE를 적용한다. RLE는 단지 계수 0에만 적용하는데, 고주파 계수 중에서 많은 부분이 0이기 때문에 RLE 효과가 크게 된다. 이 후 각각의 개별 계수 값은 Huffman 코드를 사용해 인코드한다. 여기에 더해 DC 계수에는 8x8의 소스 블록에 대한 많은 정보가 담겨 있고, 이미지는 일반적으로 블록과 블록 사이에서 천천히 변화하므로, 각 DC 계수는 앞 블록의 DC 계수와의 차이로 인코드된다(델타 인코드).

#### 컬러 이미지
- 컬러 이미지의 경우, 각 픽셀에 적용할 수 있는 여러 가지 다른 표현 방식이 있다. 한 방식은 RGB라 하는데, 각 픽셀을 빛의 세 구성 요소인 빨강, 초록, 파랑으로 나타낸다. RGB는 일반적으로 그래픽 입출력 기기들이 지원하는 컬러표현 방식이다. 또 다른 표현 방식을 YUV라고 하며, 이 또한 세 구성 요소를 갖는데, 명도(Y)와 두 가지의 채도(U, V)를 갖는다. YUV도 3차원 좌표 시스템이다. 그러나 RGB와 비교하였을때, YUV 좌표는 인간의 시력 시스템에 보다 더 잘 어울리게 표현할 수 있다.
- 어떤 컬러 이미지 속의 각 픽셀에는 세 개의 독립적인 값이 주어진다는 것이다. 이러한 이미지를 압축하기 위해서는, 이들 세 구성요소가 각각 하나의 그레이스케일 값이 처리되는 것과 같은 방식으로 독립적으로 처리되어야 한다. 하나의 컬러 이미지는 세 개의 독립적인 이미지로 생각할 수 있는데, 이 세 이미지는 화면 상에서 동일한 위치에 겹쳐 표현된다. 일반적으로 JPEG는 여러 겹으로 구성된 이미지를 압축하는 것도 가능하다.
- JPEG는 압축의 정도와 이미지의 충실도를 조절하는 여러 가지 변화를 줄 수 있다. 예를 들어, 다른 양자화 표를 사용하면 가능하다.

### 비디오 압축
- 비디오는 단순히 정지화상 이미지의 연속을 일정한 속도로 보여 주는 것이다. 이때 각 프레임은 JPEG에서 사용된 것과 동일한 DCT에 기초를 둔 기술을 사용하여 압축할 수 있다. 그러나 이것으로는 비디오의 연속적 화면에 존재하는 프레임 간의 차이를 제거하는 데 충분하지 않다. MPEG는 이러한 프레임 간의 차이를 고려하여 압축한다. MPREG는 비디오에 오디오 신호를 인코딩하는 방식까지도 규정한다.

#### 프레임의 종류
- MPEG는 일련의 비디오 프레임을 입력받아서 이것을 `I 프레임, P 프레임, B 프레임`이라고 하는 세 종류의 프레임으로 압축한다.
- 입력된 각 프레임은 이 세 종류의 프레임 중 하나로 압축된다. I 프레임은 기준 프레임으로 생각될 수 있는데, 이것은 자체적으로 완전한 것으로 자기 앞 또는 뒤 프레임 중에서 어떤 것에도 의존하지 않는다. 개략적으로 설명하면, I 프레임은 단순히 비디오 소스에 있는 정보를 JPEG로 압축한 것이라고 할 수 있다. P와 B 프레임은 자체적으로 완전하지 못한데, 기준이 되는 어떤 I 프레임으로부터의 상대적 차이점을 이용하여 압축한 것이다. 보다 엄밀히 말하면, P 프레임은 이전의 I 프레임으로부터의 차이점을 명기하며, B 프레임은 앞과 뒤에 나오는 I나 P 프레임 사이의 보정값을 규정한 것이다.
- 예를 들어, 연속된 7개의 비디오 프레임이 MPEG로 압축된 후 나오는 일련의 I, P, B 프레임이 있다고 하면 2개의 I 프레임은 독자적으로 존재한다. 각각은 다른 프레임과는 개별적으로 수신 측에서 압축을 풀 수 있다. P 프레임은 앞에 있는 I 프레임에 의존하는데, 오직 선행하는 I 프레임이 이미 도착한 경우에만 수신 측에서 압축을 풀 수 있다. B 프레임은 선행하는 I 또는 P 프레임과 뒤이어 나오는 I 또는 P 프레임에 의존한다. 이것의 기준 프레임은 B 프레임의 압축을 풀기 이전에 수신 측에 도착해 있어야 한다.
- 각 B 프레임은 뒤에 나오는 프레임에도 의존하므로, 이 프레임은 압축된 순서대로 전송되지는 않는다. MPEG는 I 프레임과 P 및 B 프레임 사이의 비율을 규정하지는 않았는데, 이 비율은 요구되는 압축 및 화질에 따라 변화할 수 있다.
- MPEG 스트림 디코딩은 네트워킹 시스템에서 자주 실행되는 작업인데, MPEG 인코딩은 많은 오버헤드가 있어서 일반적으로 실시간으로 수행되기에는 무리가 있다. 예를 들면, VOD 시스템에서 비디오는 미리 인코딩되어 디스크에 저장될 것이다. 시청자가 이것을 원한다면, MPEG 스트림을 시청자 기계로 전송하여 실시간으로 이 스트림을 디코드하여 보여준다.
- I 프레임은 소스 프레임을 JPEG로 압축한 버전과 거의 동일하다. 주요 차이점은 MPEG가 16x16의 `매크로 블록` 단위로 동작한다는 것이다. YUV로 표현된 컬러 비디오에 대해서 각 매크로 블록 내의 U와 V 구성 요소는 8x8으로 하향 샘플한다. 즉, 매크로 블록의 2x2 하부 블록 각각에 하나의 U값과 V값이 주어지는데, 4개의 픽셀값의 평균이 된다. 이 하부블록은 4개의 Y값을 갖는다. 이것이 가능한 것은 가시적으로 이미지를 흐르지 않게 하면서도 U와 V 구성요소의 정보를 줄여 전송할 수 있기 때문인데, 인간이 밝음보다 색깔에 대해 보다 덜 민감한 특성을 이용하고 있다. P와 B 프레임도 또한 매크로 블록 단위로 처리된다. 각 매크로 블록에는 비디오 움직임에 대한 정보가 실려 있다. 즉, 기준 프레임에 대해 상대적으로 매크로 블록이 어느 방향으로 얼마나 움직였는가를 보여준다. 다음으로 압축 풀기 과정 동안 프레임을 재구성한다.
- B 프레임 안의 각 매크로 블록이 선행 및 후행 프레임 모두에 대해 꼭 상대적으로 정의되는 것은 아니며, 이 보다는 단순히 둘 중 한쪽에 대한 상대적인 것으로 명시된다. B 프레임 내의 주어진 매크로 블록은 I 프레임에서 사용되는 것과 동일한 내부 코딩을 사용할 수 있다. 이렇게 유연성이 있는 것은, 활동사진이 너무 빠르게 변화하는 경우에 전방이나 후방 예측 인코딩 대신에 내부 인코딩을 하는 것이 더 합리적이기 때문이다. 그러므로 B 프레임 속의 각 매크로 블록에는 그 매크로 블록을 위해 어떤 인코딩이 사용되었는가를 가리키는 타입 필드가 포함된다.
- 압축을 하면서 B 또는 P 프레임을 생성할 때, MPEG는 기준 매크로 블록을 어떤 것으로 할 것인지를 결정해야 한다. 예를 들어, P 프레임 내의 각 매크로 블록은 I 프레임 속의 매크로 블록에 대한 상대값으로 정의되지만, P 프레임의 매크로 블록이 I 프레임에서 상응되는 매크로 블록과 프레임 속에서 동일한 위치에 있을 필요가 없다. 이 위치의 차이는 움직임 벡터로 주어지는 것이다. P 프레임의 매크로 블록이 가능한 I 프레임의 대응 매크로 블록과 거의 유사하도록 움직임 벡터를 선정하는 것이 좋다. 이렇게 하면 그 매크로 블록에 대한 델타값이 작아지게 된다. 이것은 한 프레임으로부터 다음 프레임으로 가는 동안에 그림 속의 물체들이 어디로 움직엿는지 알 필요가 있다는 것을 뜻한다. 이것은 `움직임 계산` 문제인데, 이 문제의 어려움 때문에 동일한 하드웨어에서 MPEG 인코딩이 디코딩보다 오래 걸리게 되는 것이다. MPEG는 특별한 기술을 명시하지는 않고, 이 정보를 B와 P 프레임으로 인코딩하기 위한 형식을 정의하였으며 압축을 푸는 동안에 픽셀을 재구성하기 위한 알고리즘을 명시할 뿐이다.

#### 효과와 성능
- 일반적으로 90:1의 압축 비율을 달성한다.
- MPEG에는 값비싼 계산 과정이 포함된다. 압축을 하는 측은 일반적으로 오프라인으로 진행된다.

#### 다른 비디오 인코딩 표준들
- ITU-T에서는 실시간 멀티미디어 데이터를 인코딩하기 위해 H 계열을 정의해 놓았다. 일반적으로 H 계열은 비디오, 오디오, 제어 및 다중화에 대한 표준을 정의한다.
- MPEG-4는 자연적인 비디오와 합성 비디오 양쪽 모두를 포함하도록 MPEG를 일반화한 것이다. 즉, 각각의 프레임을 사각의 매크로 블록만으로 처리하는 것이 아니라, 비디오 객체의 집합으로 처리한다. 또한, MPEG-4는 비트율을 낮추는 목적도 있다.

### 네트워크를 통한 MPEG의 전송
- MPEG에는 비디오 스트림의 포맷이 정의되어 있다. 이 스트림을 네트워크 패킷으로 분할하는 것은 명시하고 있지 않다. 그러므로, MPEG는 디스크에 비디오를 저장하는 데 사용하고, TCP 등을 통해 제공되는 스트림 기반의 네트워크 연결을 통해 비디오를 전송하는 것이다.
- MPEG 포맷은 복잡한데 이것은 비디오 스트림을 인코딩하는 방식에 모든 가능성을 부여하려는 데에서 비롯되었다. MPEG 프로파일은 프로파일을 MPEG 헤더의 형태로 명시하지 않았다는 것을 제외하면 버전과 동의어로 생각할 수 있다. 수신 측은 헤더 필드의 조합을 통해 그 프로파일을 추정해야 한다. MPEG-2 스트림이 갖는 주요 프로파일은 중첩된 구조를 가진다. 가장 바깥 쪽에 있는 비디오는 `SeqHdr`로 분리되는 연속된 Groups of Pictures(GOP)를 갖는다. 이 연속은 `SeqEndCode(0xb7)`에 의해 종료된다. 모든 GOP에 선행하는 SeqHdr은 특히, GOP 내에서의 매크로 블록에서 사용되는 두 개의 양자화 매트릭스를 기술한다. 이 정보는 각각의 GOP에 의해 주어지기 때문에, 비디오 전체를 통해 GOP 경계에서의 양자화 표와 프레임 비율을 변경하는 것이 가능하다. 이것으로 시간 흐름에 따라서 비디오를 적응시키는 것이 가능하다.
- 각 GOP는 GOP를 구성하는 프레임들 뒤에 따라오는 `GOPHdr`에 의해 주어진다. GOPHdr는 GOP를 위한 동기화 정보를 비롯하여, GOP 내의 프레임의 수를 명시한다. 각 픽처는 `PictureHdr` 및 픽처를 구성하는 조각들(slices)의 집합으로 주어진다. PictureHdr은 픽처의 유형을 명시하고, 또한 픽처에 관련된 양자화 표를 정의한다. `SliceHdr`는 조각의 세로 위치 및 양자화 테이블을 변경할 수 있는 다른 가능성을 명시한다. 여기서는 전체적으로 새로운 표를 사용하는 대신에 고정적인 척도를 이용한다. 다음으로, SliceHdr가 매크로 블록의 연속에 이어서 나온다. 마지막으로 각 매크로 블록은 픽처 내의 블록의 주소 및 매크로 블록 내의 여섯 블록의 데이터를 명시해 놓은 헤더를 포함한다. 하나는 U 인자를 위해, 하나는 V 인자를 위해, 넷은 Y 인자를 위해 사용된다(Y 인자는 16x16이고, U 와 V는 8x8이다).
- MPEG 포맷이 갖고 있는 능력 가운데 하나는 시간에 따라 인코딩을 바꿀 수 있는 기회를 인코더에게 부여하는 것이다. 프레임 비율, 해상도, GOP를 정의하는 프레임 유형의 혼합, 양자화 테이블 그리고 각 매크로 블록에서 사용하는 인코딩을 모두 바꿀 수 있다. 그 결과로, 화질과 네트워크 대역폭을 맞바꾸어 네트워크를 통해 전송되는 비디오의 전송률을 조정하는 것이 가능하다.
- TCP 연결을 통해 MPEG가 전송된다면 패킷화는 중요한 문제가 아니다. TCP는 다음의 IP 데이터그램을 전송할 충분한 여유가 있을 때를 결정할 수 있다. 그런데 비디오를 대화 형태로 사용할 때는, TCP가 지연에 민감한 애플리케이션에 맞지 않느 몇몇 특성을 가지기 때문에 TCP를 거의 사용하지 않는다. 따라서 UDP를 통해 비디오를 전송할 때는 스트림을 분리하는 위치를 주의 깊게 선택한다면 더 나은 성능을 보여 줄 수 있다. 왜냐하면 한 패킷을 잃어버릴 때 여러 개의 매크로 블록이 영향을 받는 것이 아니라, 하나의 매크로 블록 내에서만 잃어버리도록 제한하는 것이 낫기 때문이다. 이것은 애플리케이션 계층 프레임화의 한 예이다.
- MPEG 방식으로 압축된 비디오를 네트워크를 통해 전송할 때 스트림을 패킷화하는 것은 첫 번째 문제이다. 다음 문제는 패킷 손실과 타협하는 것이다. 만약 네트워크에서 B 프레임을 잃어버렸다면, 앞의 프레임을 재전송함으로써 비디오를 심각하게 희생하지 않을 수 있다. 이와 반대로, I 프레임을 잃어버린다면 심각한 결과를 초래할 수 있다. 뒤이어 나오는 B 및 P 프레임은 I 프레임 없이는 처리될 수 없다. 그러므로 I 프레임을 잃어버리게 되면 비디오의 여러 프레임을 잃어버리게 된다. 잃어버린 I 프레임을 재전송할 수 있다면 실시간 화상회의에서는 심각한 지연을 초래할 수 있다. 이 문제에 대한 해결책 가운데 하나는 차별화된 서비스 기술을 사용하여 I 프레임을 포함하는 패킷에 대해 손실 가능성을 낮추도록 표시하는 것이다.
- 비디오를 어떻게 압축할 것인가는 네트워크 대역폭만을 기준으로 정의할 수 없다. 화상회의와 같은 대화식 애플리케이션은 적은 지연을 필요로 한다. 중요한 기준은 GOP 내에서의 I, P, B 프레임 혼합이다. 예를 들어 GOP에 IBBBBPBBBBI가 있을때 발생할 수 있는 문제는, 뒤따라오는 P 또는 I 프레임을 사용할 수 있을 때까지는 네 개의 B 프레임을 기다려야 한다는 것이다. 왜냐하면 각각의 B 프레임은 뒤따라오는 P 또는 I 프레임에 의존하기 때문이다. 이러한 이유 때문에 많은 화상회의 애플리케이션에서는 비디오를 JPEG 방식으로 압축하는데, 이것을 motion-JPEG라고 부른다. 그런데, 첫 프레임에만 주로 위존하고 뒤의 프레임에는 덜 의존하는 프레임 간 인코딩에서는 크게 문제 되지 않는다.

### 오디오 압축
- MPEG는 비디오 압축뿐만 아니라 오디오를 압축하는 방식에 대한 표준도 같이 정의해 놓았다. 이 표준은 비디오 내에 포함되어 있는 오디오 혹은 오디오 데이터만을 압축하는 경우에도 사용될 수 있다.
- CD 음질의 오디오를 128Kbps의 ISDN 데이터/음성 회선 쌍을 통해 전송하려면 어느 정도의 압축이 필요하다. MPEG는 3계층의 압축을 정의함으로써 나타내는데, `MP3`로 알려져있다. 압축률을 달성하기 위해서 MP3는 MPEG로 비디오를 압축할 때 사용되는 것과 유사한 기법으 사용한다. 먼저, 오디오 스트림을 주파수 대역별로 몇 개로 나누는데, MPEG에서 비디오 스트림을 Y, U, V로 나누는 것과 비슷하다. 다음으로, 각 주파수 대역을 연속된 블록으로 나누는데, 이것은 MPEG에서의 매크로 블록과 비슷한데, 차이점은 64~1024의 다양한 길이를 가질 수 있다는 것이다. 마지막으로, 각 블록은 변형된 DCT 연산, 양자화 그리고 Huffman 인코딩을 사용해서 변환되는데, 이것은 MPEG 비디오와 같은 방식이다.
- MP3의 요령은 주어진 비트율 내에서 가능한 높은 음질을 유지하고, 얼마나 많은 주파수 대역을 사용하는가 하는 것과 각 대역에서 얼마나 많은 비트 수가 할당되는가 하는 것이다. 이 할당을 결정하는 방법은 음향심리학 모델을 통해 이루어진다. 예를 들어, 남자의 목소리를 압축할 때는 저주파 대역에 더 많은 비트 수를 할당하고, 여자 목소리에는 고주파 대역에 더 많은 비트 수를 할당하는 것이다. MP3는 주어진 압축률을 달성하기 위해 각 대역에서 사용되는 양자화 표를 계속해서 바꾼다.
- 일단 압축이 되면 각 대역폭은 고정된 크기의 프레임으로 패키지화되고, 헤더가 붙는다. 헤더에는 디코더가 각 대역폭을 몇 비트로 압축하였는가를 결정하도록 해주는 비트 구성 정보를 포함한 동기화 정보가 포함되어 있다.
