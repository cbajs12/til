# 애플리케이션

## 전통적인 애플리케이션
- WWW과 DNS는 애플리케이션들이다. DNS 애플리케이션은 네트워크 애플리케이션 취급받고 있지만(트랜스포트 프로토콜 상위에 구현된 분산 DB이다), 사용자가 직접 사용하는 애플리케이션은 아니다.
- WWW와 DNS는 사용자가 서버에게 요청을 보낸 후, 서버가 적절하게 응답하는 요청/응답 패러다임을 사용한다. 이 애플리케션들을 전통적인 애플리케이션이라고 한다.
- 애플리케이션 프로그램과 애플리케이션 프로토콜을 구별해야 한다. 예를 들어, HTTP는 원격 서버로부터 웹 페이지를 가져오기 위해 사용되는 프로토콜이다. SMTP는 전자우편용 프로토콜이다. DNS는 이름 서버에게 질의하고 응답기 위해 사용되는 프로토콜이다. 그렇지만 프로토콜이라보다는 그보다 상위개념에 가깝다. SNMP는 원격 네트워크에 위치하는 노드의 상태를 알어보고 수정하기 위한 프로토콜이다.
- 요구/응답 형 통신 방식을 따르고 있는 애플리케이션 프로토콜들이 RPC 프로토콜 위에서 사용될 것이라 예상하지만, TCP나 UDP 위에서 구현된다. 사실상, 각 프로토콜들은 TCP나 UDP 위에서 RPC와 비슷한 방식의 기능을 도입하고 있다. 각 프로토콜들은 임의의 원격 프로시저 호출을 지원하기 위해 설계된 것이 아니라, 특정 요구 메시지들만 취급하여 보내고 이에 대한 응답을 답기 위해 설계되었기 때문에, RPC 기능 중에서도 아주 간단한 기능만 포함하고 있다.
- DNS를 제외한 HTTP, SMTP, SNMP 프로토콜은 모두 교환되는 데이터 형식을 명시하는 프로토콜을 별도로 가지고 있다. 이것이 이 프로토콜들이 상대적으로 간단한 이유이다. 아주 복잡한 데이터 정의에 대한 부분은 이 프로토콜의 부수적인 문서로 되어 있다. 예를 들어, SMTP는 전자우편을 교환하기 위한 프로토콜이지만, RFC 822와 MIME은 전자우편 메시지들의 형식을 정의하고 있다. 마찬가지로, HTTP는 웹 페이지를 가져오기 위한 프로토콜이지만, HTML은 이러한 페이지들의 형식을 정의하는 문서이다. 마지막으로 SNMP는 네트워크의 노드에 질이를 보내는 프로토콜이지만, MIB는 질의에 사용되는 변수들을 정의하고 있다.

### 전자우편
- 전자우편의 동작을 이해하는 시작점은 첫째 기반이 되는 메시지 트랜스포트 프로토콜(SMTP)과 사용자 인터페이스를 구별하고, 둘째 이러한 트랜스포트 프로토콜과 교환되는 메시지 형식을 정의하는 부수적인 프로토콜(RFC 822, MIME)을 구별하는 것이다.

#### 메세지 형식
- RFC 822에 정의된 메시지들은 헤더와 바디, 두 부분으로 구성된다. 두 부분 모두 ASCII 문자로 표현된다. 원래 바디 부분은 문자로만 구성되는 것으로 가정하였다. 따라서 모든 종류의 데이터를 전달할 수 있도록 확장하기 위해 MIME이 만들어지게 되었다. 이러한 데이터에는 여러 가지 정보, 예를 들면 JPEG 이미지등이 포함될 수 있지만 이들 정보는 여전히 ASCII 문자로 표현된다. 따라서 RFC 822에 포함된 데이터는 문자이지만 때로는 사람이 읽을 수 없는 경우도 있다.
- 메시지 헤더에서 각 라인은 `<CRLF>`(문자 라인의 끝을 나타냄)로 끝난다. 헤더와 바디는 한 줄의 빈 라인으로 분리된다. 각 헤더 라인은 type과 value로 표시되는데, 이들 간은 콜론으로 분리된다. 사용자들이 전자우편 메시지를 작성할 때 헤더 라인의 내용을 채워야 하기 때문에 이 라인들은 사용자들에게 익숙한 편이다. 예를 들어, `To`, `Subject`, `Date`, `From`, `Received`등이 있다.
- MIME은 세 부분으로 구성된다. 첫 번째 부분은 헤더 라인의 집합으로, RFC 822에 의하여 정의되었던 것을 확장한 것이다. 이 헤더 라인들은 메시지 바디에 다양한 방법으로 전송될 데이터들을 기술한다. 헤더 라인들은 `MIME-Version`(사용되는 MIME 버전), `Content-Description`(라인과 같이 바디에 포함된 메시지에 대한 설명으로 사람이 읽을 수 있는 형태로 표현), `Content-Type`(메시지에 포함된 데이터의 유형) 그리고 `Content-Transfer-Encoding`(바디 부분의 데이터를 인코딩하는 방법) 등을 포함한다.
- 두 번째 부분은 content type의 집합에 대한 정의이다. 예를 들면, MIME은 두 가지의 이미지를 정의하고 있다. 이 이미지 유형들은 `image/gif`와 `image/jpeg`로 표시된다. 또 다른 예로, `text/plain`은 바닐라 822-style 메시지에서 찾을 수 있는 간단한 문제를 의미하는 반면, `text/richtext`는 marked up 문자(특정 폰트나, 이텔릭체등에 사용되는 문자)를 포함하는 것을 의미한다. 세 번째로, MIME 애플리케이션의 유형을 정의하고 있는데, 이것은 애플리케이션의 출력에 적용되는 subtype을 정의한다(예를 들면, `application/postscript`나 `application/msword`등).
- 또한, MIME은 하나 이상의 데이터 유형으로 구성된 `multipart` 유형을 정의하고 있다. multipart 유형에서 가능한 서브 유형의 하나로 `mixed` 유형이 있는데 이는 독립적인 데이터 유형들의 집합이 특정 순서에 따라 배열된 것을 의미한다. 이 때 각 부분은 그 부분의 유형을 설명하는 자신의 헤더 라인을 가진다.
- 세 번째 부분은 다양한 데이터 유형을 인코딩하여 그 데이터가 ASCII 형태의 전자우편 메시지로 전달될수 있도록 하는 방법이다. 어떤 데이터 유형에 대해서, 이미지에서 주어진 8비트는 256개의 다른 값을 가지게 되는데, 이 때 일부 값은 적당한 ASCII 문자들에 매핑되지만 일부는 ASCII 문자로 표시되지 않는 경우가 있다. 그러나 전자우편에서 메시지는 ASCII 문자만 수용할 수 있다. 왜냐하면, 이 메시지들은 여러 중간 단계의 시스템들을 거쳐갈 때, 중간 시스템들은 모든 전자우편 메시지가 ASCII 문자로만 구성된 것이라는 가정을 하고 있기 때문이다. 그래서 ASCII가 아닌 문자들을 포함한 메시지들에는 에러가 발생할 수 있다. 이 문제를 해결하기 위해 MIME은 이진 데이터를 직접 ASCII 문자로 인코딩하는 방법을 사용하고 있는데, 이 인코딩 방법을 `base64` 방식이라고 한다. 이 방법은 세 개의 이진 바이트를 4개의 ASCII 문자로 변환시킨다. 이것은 이진 데이터를 24비트 단위로 분리하고, 각각을 네 개의 6비트 부분들로 쪼갠다. 그리고 각 6비트 부분들은 64개의 유효한 ASCII 문자에 대응된다.

#### 메시지 전달
- 한 호스트에서 다른 호스트로 메시지를 전송하는 데 사용하는 데 SMTP 프로토콜을 사용한다.
- 사용자는 `메일 리더`를 이용해서 전자우편을 편집하고 저장하며 검색하고 읽는다. 웹 브라우저가 다양하듯이 메일 리더 또한 다양하다. 각 호스트에는 `메일 데몬`이 실행되고 있다. 이 프로세스는 전자우편에서 우체국의 역할을 한다. 메일 리더가 다른 사용자에게 보낼 메시지를 데몬에게 전달하면, 데몬은 TCP 위에 수행되는 SMTP를 통해 다른 호스트의 데몬에게 메시지를 전송하고, 그 데몬은 전송된 메시지를 사용자의 `메일박스`에 저장한다. SMTP는 누구나 구현할 수 있는 프로토콜이기 때문에 여러 메일 데몬이 존재할 수 있다. 그러나 대부분은 `sendmail` 프로그램을 기반으로 만들어졌다.
- 어떤 경우에는 송신자의 호스트에서 실행되는 sendmail 프로그램이 수신자의 호스트에서 실행되고 있는 sendmail 프로그램에게 SMTP/TCP 연결을 직접 설정할 수도 있지만, 대부분의 경우에는 송신측 호스트에서 수신측 호스트까지의 경로에 하나 이상의 `전자우편 게이트웨이`를 거치게 된다. 이러한 게이트웨이도 종단 호스트처럼 sendmail 프로세스를 실행하고 있다. 이러한 중개 노드는 전자우편 메시지를 저장하고 전달하는 역할을 하기 때문에 게이트웨이라고 불린다. 전자우편 게이트웨이는 보통 메시지를 디스크에 저장한 후 시간적 여유를 두고 다음 호스트로 전송한다.
- 전자우편 게이트웨이가 필요한 이유는 수신자가 언제나 특정 호스트를 지정해 두고 그 호스트로 메일을 받으려고 하지 않는 데 있다. 예를 들어, `a@gmail.com`의 경우 gmail에서 메일 보관하고, 수신인이 메일을 읽을 때 최종 호스트로 전달된다. 따라서, 메시지를 전달하는 게이트 웨이는 각 사용자와 그가 메일을 읽을 호스트 간을 매핑하는 DB를 가지고 있어야 한다. 이 경우 송신자는 수신자가 메일을 읽을 호스트를 기억하고 그곳으로 보낼 필요가 없다. 또 다른 이유는 수신측 컴퓨터가 언제나 켜져 있는 것은 아니기 때문에, 전자우편 게이트웨이에 저장할 필요가 있다. 이 경우에 수신자는 도착한 메시지를 받아오는 SMTP 대신에 POP3와 같은 메일 패치 프로토콜을 사용하여 메일을 읽을 수 있다. 그러나 송신자에서 수신자의 게이트웨이로 메시지를 전달하는 경우에는 SMTP 프로토콜이 이용된다.
- 메일을 전달하는 경로상에 게이트웨이가 몇 개 존재하는가에 관계 없이 각 호스트 간에 전자우편을 전달하는 데에는 각각 별도의 SMTP 연결을 사용한다. 각 SMTP 연결은 두 개의 메일 데몬 간에 설정되는데, 이때 하나는 클라이언트로, 다른 하나는 서버로 동작함으로써 정보를 교환하게 된다. 물론 두 호스트 간에 다수의 메시지가 하나의 연결을 통해 전달될 수도 있다. RFC 822에서는 메시지의 기본 표기법으로 ASCII를 사용하도록 정의하고 있고, SMTP 역시 ASCII 기반으로 되어 있다.
- SMTP는 클라이언트와 서버 간에 지속적으로 정보를 교환한다. 이러한 과정에서 클라이언트는 명령(HELO, MAIL, RCPT, DATA, QUIT등)을 보내며, 서버는 응답(250, 550등)을 보낸다. 또한, 서버는 코드 대신에 인간이 읽기 쉬운 설명(No such user here등)으로 응답할 수도 있다. 일반적으로 클라이언트는 처음에 `HELO` 명령을 사용하여 서버에게 자신이 누구인지를 밝힌다. 이때 매개변수로는 도메인 이름이 사용된다. 그러면 서버는 TCP 연결에 사용된 IP 주소와 제시된 도메인 이름이 일치하는지 확인하고, 서버가 클라이언트에게 메시지를 보낼 때 이 IP 주소를 사용한다. 그리고 나서 클라이언트는 서버에게 사용자에게 보내는 메일을 수락할 것인지 묻는다. 서버는 그것에 대한 응답을 한다. 그러면 클라이언트는 데이터를 보낸 후 이어서 종료 메시지를 보내는데 이 메시지는 첫 칸에 '.'로 표시된다. 마지막으로 클라이언트는 연결을 끊는다.
- `VRFY`는 클라이언트가 사용자에게 실제로 메시지를 전송하지 않으면서, 사용자의 전자우편 주소를 확인하고자 할 경우 사용한다.

#### 메일 리더
- 메일 리더가 사용자 메일박스가 저장된 호스트에서 실행되는 경우에는 단순히 메일박스를 구현한 파일을 읽거나 쓰면 된다. 그러나 메일박스가 저장된 호스트와 메일 리더가 수행되는 컴퓨터가 다른 경우, 사용자는 `POP`나 `IMAP`와 같은 별도의 프로토콜을 사용해서 원격 호스트에 있는 메일박스에 접근할 수 있다.
- IMAP는 많은 점에서 SMTP와 비슷하다. IMAP는 TCP 상에서 동작하는 클라이언트/서버 프로토콜이다. IMAP에서 클라이언트는 ASCII로 구성된 명령을 보내면 메일 서버는 이에 응답한다. 이러한 메시지 교환은 클라이언트의 인증으로부터 시작되고, 사용하고자 하는 메일박스를 선택한다. LOGIN, AUTHENTICATE, SELECT, EXAMINE, CLOSE, LOGOUT 등은 클라이언트가 생성하는 명령어들이며, 서버 쪽에서는 OK라는 명령어로 응답한다. 이밖에 다른 명령어로는 FETCH, STORE, DELETE, EXPUNGE 등이 있다. 서버 쪽에서 응답하는 명령어는 NO(클라이언트에게 그 동작 허가불가), BAD(명령어 구조가 잘못됨) 등이 있다.
- 사용자가 FETCH로 메시지를 요청할 때, 서버는 MIME 형식으로 응답하고 메일 리더는 그것을 해석한다. 이때 IMAP는 메시지에 덧붙여 메시지의 속성을 정의한다. 메시지 속성은 메시지의 크기나 각종 플래그(Seen, Answered 등)의 정보를 포맣나다. 이러한 플래그는 클라이언트와 서버 간에 상태를 맞추기 위해 사용된다. 사용자가 모든 메시지를 지운 경우, 클라이언트는 서버에게 EXPUNGE 명령을 보내서 서버가 메일박스에 저장되어 있는 모든 메시지를 지우도록 한다.
- 사용자가 자신에게 온 메일에 응답하거나 새로운 메일을 보내면 메일 리더는 IMAP를 이용하지 않고 SMTP를 이용한다. 왜냐하면 메시지를 수신측 메일박스로 전달하는 과정에서 사용자의 메일 서버가 첫 번째 메일 게이트웨이의 역할을 하기 때문이다.

### WWW
- 웹은 클라이언트와 서버로 구성되어 있고, 이들 간에는 HTTP라는 공통 언어로 통신한다.
- 어떤 브라우저든지 URL을 열 수 있는 기능을 가지고 있는데, URL은 웹 상에서 객체의 위치 정보를 제공한다.
- URL을 연다면, 웹 브라우저는 즉시 해당 웹 서버와 TCP 연결을 설정하고 index.html이라는 이름의 파일을 가져와서 모니터에 출력할 것이다. 웹 상의 파일에는 다른 파일을 가리키는 URL을 포함할 수도 있는데, 이때 웹 브라우저는 지정한 URL을 열 수도 있다. 이와 같이 파일에 포함된 URL들을 하이퍼텍스트 링크라고 한다.
- 웹에서 페이지를 보기 위해 특정 아이콘을 클릭하면, 브라우저 TCP 상에서 동작하는 HTTP를 이용하여 서버에서 해당 페이지를 가져온다. 이때 사용되는 HTTP는 SMTP처럼 텍스트 기반 프로토콜이다.
- HTTP 프로토콜에서 `START_LINE`은 요청 메시지 인지 응답인지를 구분하며, 실제로 이 부분이 요청 메시지인 경우 실행될 원격 프로시저이거나, 응답 메시지일 경우 요청에 대한 'status'를 나타낸다. `MESSAGE_HEADER`는 여러 라인이 될 수 있고, 아예 없을 수도(종료를 의미) 있는데, 이것은 전자우편에서 헤더와 비슷한 형식을 취한다. `MESSSAGE_BODY`에 빈 라인이 오면, 이것은 일반적으로 요청 메시지에 대해 응답이 없음을 의미한다.

#### 요청 메시지
- HTTP 요청 메시지의 첫 라인은 세 부분으로 구성된다. 수행할 동작, 동작이 수행될 웹 피이지 그리고 HTTP의 버전 정보가 그것이다. HTTP는 여러 동작을 요청할 수도 있지만, GET(특정 웹 페이지 가져옴)과 HEAD(특정 웹 페이지의 상태 정보를 가져옴)은 기본적인 동작이다.
- `IF-MODIFIED-SINCE`는 클라이언트가 웹 페이지를 조건부로 요청할 때 사용하는 것으로, 지정한 시간 이후에 해당 페이지가 수정되엇으면 서버에서 페이지를 다시 보내 주는 경우에 사용한다.

#### 응답 메시지
- 요청 메시지와 마찬가지로 `START_LINE`으로 시작된다. 이 경우, 이것의 구성은 HTTP 버전 정보, 요청이 성공되었는지 여부를 나타내는 세 개의 숫자 코드, 그리고 응답의 원인을 나타내는 문자열로 이루어 진다. 예를 들어, `HTTP/1.1 202 Accepted`와 같은 식이다. 
- 코드의 첫 번째 자릿수가 유형을 나타낸다. 1xx는 정보와 관련, 2xx는 성공, 3xx는 리다이렉션, 4xx는 클라이언트 에러, 5xx는 서버 에러이다.
- 요청 메시지와 마찬가지로 응답 메시지도 하나 이상의 `MESSAGE_HEADER`를 포함한다. 이 헤더에는 클라이언트에게 전달하는 각종 정보가 포함된다. `LOCATION`(요청된 URL이 다른 위치에 있음을 나타냄), `Content-Length`(내용의 바이트 수), `Expires`(내용의 유효기간), `Last-Modified`(서버에서 내용을 마지막으로 수정한 시간)등의 정보가 포함된다.

#### URI
- URL은 URI의 한 종류이다. URI는 문서나 그림, 그리고 서비스와 같은 자원을 식별하는 문자열이다.
- URI 형식을 사용함으로써 다양한 자원 식별자의 형식을 하나의 URI 식별자 표현 형식으로 통합하여 나타낼 수 있다. URI의 첫 번째 부분은 자원의 종류를 식별하기 위한 방법을 의미하는 `스키마`이다. 예를 들어 메일 주소라는 자원은 `mailto`라는 식별자를 사용하며, 파일 이름은 `file`이라는 식별자를 사용한다. URI의 첫 번째 부분과 콜론으로 구분되는 URI의 두번째 부분은 `스키마 명세부분`이다. 스키마 명세부분은 첫 번째 부분의 스키마 속성과 일치하는 자원 식별자로 표현되어야 한다.
- 한편, 자원이 반드시 획득이 가능하거나 접근이 가능할 필요는 없다. `mid`는 마시지 자체의 식별자로서 메시지 ID를 표현하는데 사용한다. 그리고 URI가 항상 자원이 존재하는 곳의 위치를 나타내는 주소개념을 사용하는 것은 아니다. 주소개념을 사용하지 않는 경우에는 URI가 단지 식별자 개념으로 사용된다. 그러나 URI가 주소 개념을 사용하는 경우에는 URL과 유사한 개념이라고 볼 수 있다. 즉 URI 스키마 내에 자원의 위치를 지정하는 주소가 포함되어야 URL이 되는 것이다.
- XML은 http 스키마를 사용하는 URI에 의하여 식별될 수 있지만 단순히 이름공간을 표현하기 때문에 URL로 사용되는 것은 아니다.

#### TCP 연결
- HTTP 버전 1.0에서는 서버로부터 받는 데이터마다 별도의 TCP 연결을 사용하도록 되어 있다. 이것은 아주 비효율적이다.
- HTTP 버전 1.1에서 가장 중요한 개선점은 한 연결을 지속적으로 사용할 수 있는 점이다. 즉, 클라이언트와 서버가 하나의 TCP 접속을 통해 다수의 요청/응답 메시지를 교환할 수 있다는 점이다. 이러한 장점의 첫째는 접속 설정에 따른 오버헤드를 현저히 줄일 수 있다. 이로써 서버의 부하가 줄게 되고, 부거적인 TCP 패킷으로 인한 네트워크 부하가 감소되며, 사용자 인지 지연시간이 줄어든다. 두 번째는 클라이언트가 하나의 TCP 연결을 통해 다수의 요청 메시지를 보낼 수 있기 때문에 TCP의 혼잡 윈도우 기법을 더욱 효과적으로 수행할 수 있다는 점이다. 그 이유는 각 페이지마다 별도의 슬로 스타트를 수행할 필요가 없기 때문이다.
- 그러나 지속적 연결에도 문제점이 있다. 그것은 얼마나 오랫동안 지속적인 TCP 접속을 유지할 것인지 알 수 없다는 것이다. 이것은 특히 서버에게 문제가 된다. 그 이유는 수천의 클라이언트로부터 접속을 유지하도록 요청받을지도 모르기 때문에, 특히 성능에 문제가 발생될 수 있다. 이러한 문제의 해결 방법은 일정 시간 동안 요청이 없으면, 서버가 해당 연결을 끊는 방법이다. 이 경우와 클라이언트와 서버는 상대측이 연결을 닫았는지 계속해서 감시해야하며, 상대편이 연결을 종료하면 자신도 연결을 종료시켜야 한다.

#### 캐싱
- 클라이언트 측에서는 서버에서 가져오는 것보다 캐시에서 가져오는 것이 더 빠르다. 서버 측에서도 캐시가 요청을 대신 처리해 주면 서버의 부하를 줄일 수 있다.
- 캐싱은 여러 곳에 구현될 수 있다. 예를 들어, 사요자의 브라우저가 최근 접속한 페이지를 저장할 수 있다면, 사용자가 같은 페이지를 다시 방문할 경우 저장되어 있는 복사본으로부터 쉽게 페이지를 얻을 수 있다. 다른 예로, 어떤 지역 단위로 캐시를 제공할 수 있다. 이것은 이전에 어떤 사용자에 의하여 다운로드된 페이지를 또 다른 사용자가 사용할 수 있는 이점이다 있다. 
- 인터넷에서는 각 ISP들이 그들의 고객을 위해 캐시를 마련할 수 있다. 이 경우 사용자는 사이트 내에 어느 호스트가 캐시 서비스를 제공하는지 알 수 있고, 그들의 브라우저를 캐시 서비스가 제공되는 호스트에 바로 접속되도록 설정할 수 있다. 이러한 호스트를 일반적으로 `프록시`라 부르기도 한다. 여러 사이트로부터 보내온 HTTP 요청은 ISP 라우터를 통해 전달되는데, 라우터가 URL을 캐시에 저장되어 있는지를 파악하여 캐시에 존재한다면 바로 응답한다.
- 캐싱 기법은 아주 중요한데, 특히 페이지에 대한 정보가 유효한지 표시하는 기법이 고려되어야 할 사항이다. 예를 들면, 서버는 페이지를 클라이언트에게 보낼 때 각 페이지마다 유효기간을 표시한다. 캐시는 이 유효기간을 기억하고 있으면 만기될 때까지 해당 페이지가 유효한지 확인할 필요가 없다. 만약 유효기간이 지나면 캐시는 HEAD 혹은 조건부의 GET 동작을 사용하여 해당 페이지가 유효한지 확인하면 된다. 

### 이름 서비스
- 호스트를 식별하기 위해 사용되는 IP 주소는 라우터의 입장에서는 처리하기에 적합하지만, 사용자의 입장에서는 친숙하지 못하다. 이런 이유로 네트워크의 각 호스트는 일반적으로 고유한 이름을 가진다.
- 이름 서비스는 종종 `미들웨어`라 불리기도 하는데, 이는 하위의 네트워크와 애플리케이션 계층 사이에 존재하기 때문이다.
- 호스트 주소와 호스트 이름은 두 가지 측면에서 차이가 있다. 첫 번째, 호스트 이름은 항상 가변 길이의 문자로 구성되어 사람들이 기억하기 쉽게 되어 있다. 두 번째, 이름은 네트워크가 호스트를 찾아가기 위해 필요한 정보를 포함하고 있지 않지만, 주소는 호스트를 찾는데 필요한 정보를 포함하고 있다. 물론 `플랫` 주소(구성 요소로 나누어지지 않는 주소)를 사용하는 경우는 예외이다.
- `이름 공간`은 가능한 이름의 집합을 의미한다. 이름 공간은 `플랫`하거나(이름이 구성 요소로 나누어지지 않거나), 계층적일 수 있다.
- 이름 부여 시스템은 이름과 값을 바인딩해 놓은 정보를 유지하고 있다. 값이란 이름 부여 시스템에 이름을 제시한 후 반환받고자 하는 어떤 값을 의미한다. 대부분의 경우 이것은 주소가 된다.
- `해석 기법`이란 이름을 가지고 호출하면 바인되는 값을 반환하는 프로시저를 의미한다. `이름 서버`는 메시지에 이름을 넣어 질의하면 주소를 찾아 주는 이름 찾기 시스템의 특정한 구현을 지칭한다.
- 인터넷은 이름 부여 시스템으로 `DNS`를 사용하고 있다.  인터넷 초기에는 네트워크 정보 센터(NIC)에서 이름과 주소를 바인딩하는 1차원 테이블을 사용하였는데. 이 표를 `hosts.txt` 파일이라 한다. 따라서, 어떤 지역에서 새로운 호스트를 인터넷에 접속시키려고 하면 관리자는 새로운 호스트의 이름/주소 쌍을 이메일을 통하여 NIC에 보내야 한다. 이 정보는 손으로 직접 테이블에 추가되고 수정도니 테이블은 수일에 걸쳐 각 지역에 전송되며, 각 지역의 관리자는 그 지역 내의 모든 호스트에 이이름을 추가한다. 인터넷에 접속된 호스트의 증가로 이러한 시스템이 제대로 동작하지 않아서 DNS를 도입하였다. DNS에서는 플랫한 이름 공간 대신에 계층 구조를 가진 이름 공간을 채택하였다. 그리고 이 이름 공간을 구현한 바인딩 테이블은 중보되지 않게 지역을 분리하여 인터넷 상에 분산되어 위치한다.
- 사용자가 애플리케이션에 호스트 이름을 제공하고, 애플리케이션은 이 이름을 이용하여 이름 부여 시스템에 문의함으로써 호스트 주소로 변환하는 과정이 일어나낟. 그러고 난 후, 애플리케이션은 호스트의 IP 주소를 트랜스포트 계층 프로토콜에 제공하여 연결을 설정한다.

#### 도메인 계층 구조
- DNS는 인터넷 객체에 대한 계층적 이름 공간을 제공한다. Unix 파일의 이름 구조는 '/'로 구분되고 왼쪽에서 오른쪽으로 처리되는 데 비해, DNS 이름은 오른쪽에서 왼쪽으로 처리되며 '.'으로 구분된다. DNS가 반드시 호스트 이름을 호스트 주소로 대응하는 데만 사용하지는 않는다. 정확히 말하면, DNS는 도메인 이름을 어떤 값에 대응시킨다는 뜻이다.
- DNS 계층 구조는 트리로 나타낼 수 있다. 여기서 트리의 노드는 한 도메인을 나타내고, 트리의 단말들은 호스트 이름에 해당된다. 여기서 `도메인`이란 용어는 단순히 이름을 정의할 수 있는 공간이라는 의미뿐이다.
- 도메인 이름 계층 구조는 완전히 추상적인 개념이다. 첫 번째 단계는 계층 구조를 `영역`이라 하는 부 트리로 분할하는 것이다. 각 `지역`은 계층 구조의 일부를 책임지고 있는 관리조직에 대응되는 것으로 생각할 수 있다. 지역이란 DNS가 구현되는 기본 단위를 의미한다. 각 지역에는 두 개 이상의 이름 서버가 있어야 한다. 각 이름 서버는 인터넷을 통하여 접근 가능한 프로그램이다. 클라이언트는 이름 서버에 질의를 보내고, 이름 서버는 필요한 정보를 답변으로 보낸다. 이 답변에는 클라이언트가 원하는 최종 정보가 있을 수도 있지만, 때로는 클라이언트가 다음에 질의를 보낼 다른 서버의 주소가 포함되어 있는 경우도 있다. 그래서 DNS는 이름 서버의 계층으로 생각하는 것이 좋다.
- 각 지역에는 고장에 대비하여 두 개 이상의 이름 서버가 있어야 한다. 즉, 한 서버에 장애가 발생하더라도 여전히 정보를 제공할 수 있어야 한다. 한편 하나의 이름 서버가 여러 지역을 지원하도록 구현될 수도 있다.
- 각 이름 서버는 지역 정보를 `자원 레코드`의 집합으로 구현하며, 자원 레코드란 이름값으로 바인딩된 정보를 의미한다. `<Name, Value, Type, Class, TTL>` 으로 구성된다. `Type` 필드는 Value가 어떤 방식으로 해석되는가를 나타낸다. 값이 A이면 이름-주소 바인딩이며, NS이면 Value 필드는 주어진 도메인에서 이름 해석 기능을 가진 이름 서버가 수행되고 있는 호스트의도메인 이름을 나타낸다, CNAME이면 Value 필드는 특정 호스트의 다른 이름(별명)이 표시된다, MX이면 Value 필드에는 주어진 도메인의 메일을 수신하는 메일 서버가 수행되는 호스트의 도메인 이름이 표시된다. `Class` 필드는 NIC외의 다른 기고나이 유용한 레코드 타입을 정의하는 데 사용된다. 널리 사용되는 유일한 Class는 인터넷에서 사용되는 IN이다. `TTL` 필드는 자원 레코드가 얼마 동안 유효한지를 나타낸다. TTL이 경과되면 서버는 자신의 캐시에서 해당 레코드를 지운다.
- 루트 이름 서버는 TLD 이름 서버에 대한 NS를 가지고 있다. 이 NS 레코드는 DNS 계층구조에 있는 .com이나 .edu가 포함된 질의에 응답할 수 있는 서버를 지정한다. 이름을 해당 IP 주소로 변경할 수 있는 A 레코드 또한 가지고 있다.이 두가지 레코드는 루트 이름 서버로부터 TLD 서버 중에서 하나로 가는 포인터를 표시하고 있다. 이 포인터를 따라 서버를 찾으며 찾으려는 이름을 가지고 있는 서버에서 값을 찾아 반환한다.

#### 이름 해석
- 클라이언트는 이름을 포함한 질의를 루트 서버로 보낸다. 루트 서버는 이 이름 전체와 일치하는 레코드가 없으면, 상위 도메인(edu, com등)만 해석할 수 있는 서버로 보낸다. 그 다음 서버에서도 이름 전체와 일치하는 레코드가 없으면 그 다음 도메인만 해석할 수 있는 서버를 찾아서 보내면서 전체 이름과 동일한 값을 가진 서버를 찾는다.
- 클라이언트가 루트 서버의 위치를 아는 방법은 하나 이상의 루트 서버에 대한 이름-주소 매핑은 미리 알려져 있기 때문이다. 어떤 방식으로든 이름 찾기 시스템 자신은 외부에 공개되어 있어야 한다. 그러나 모든 클라이언트가 루트 서버에 대하여 알고 있지 않다. 반대로 각각의 인터넷 호스트에서 수행되는 클라이언트 프로그램은 `지역` 이름 서버의 주소로 초기화되어 있다. 이 지역 이름 서버는 하나 이상의 루트 서버에 대한 자원 레코드를 유지하고 있다. 따라서 이름 해석에는 실제로 지역 서버에 징의하는 과정이 포함된다. 이 지역 서버는 원래의 클라이언트를 대신하여 원격 서버에 질의하는 클라이언트의 역할을 수행한다. 이 모델의 장점은 인터넷 상의 모든 호스트가 현재 루트 서버가 어디에 존재하는지 항상 알고 있지 않아도 된다는 것이다. 두 번째 장점은 지역 서버는 지역 내의 모든 클라리언트에서 발생한 질의에 대한 답변을 볼 수 있다는 것이다. 지역 서버는 이 답변을 캐시에 저장하였다가 다음의 질의에 대하여 네트워크를 통하여 질의를 보내지 않아도 찾을 수도 있다.
- 완전한 도메인 대신에 부분적인 이름을 사용자가 사용한 경우 시스템은 질의를 전송하기전에 호스트가 속해 있는 지역 도메인을 부분적으로 제시된 이름에 첨가하여 보낸다.
- 사용자들이 애플리케이션과 상호 작용하는 과정에서 도메인 이름을 사용한다. 애플리케이션은 도메인 이름을 IP 주소로 변환하기 위해 DNS를 호출한다. IP 데이터그램은 라우터를 통하여 포워딩 된다.  이는 IP 주소가 다른 형태로 변환 되어야 함을 의미한다. 즉, 최종 목적지 주소로부터 다음 홉의 주소로 변환된다는 뜻이다. IP 다음 홉 주소를 그 기계의 물리적 주소로 변환하기 위해 ARP를 이용한다. 다음 홉이 최종 목적지일 수도 중간 라우터 일 수도 있다. 물리적 네트워크로 전송되는 프레임은 헤더에 이 물리적 주소를 포함한다.

### 네트워크 관리
- 네트워크 상의 여러 노드에 잇는 각종 정보를 읽고 때로는 쓰기 위해서 프로토콜이 필요하다. 이런 목적으로 개발된 프로토콜이 `SNMP`이다.
- SNMP는 기본적으로 두 가지 종류의 메시지 GET, SET을 지원하는 특별한 형식의 요구/응답형 프로토콜이다. GET은 노드로부터 상태 정보를 읽는 데 사용되고, SET은 임의의 노드에 상태 정보를 저장하는 데 사용된다.
- 시스템 관리자는 네트워크에 대한 정보를 관리하는 클라이언트 프로그램과 상호 작용한다. 시스템 관리자가 얻고자 하는 어떤 정보를 선택하면 클라이언트 프로그램은 선택된 노드의 정보를 요구하기 위해 SNMP를 수행한다. 이때 SNMP는 보통 UDP 위에서 동작한다. 선택된 노드에서 수행되는 SNMP 서버 프로그램은 적절한 정보를 찾아 클라이언트 프로그램에게 알려 준다. 그러면 클라이언트 프로그램은 이 정보를 사용자에게 알려준다.
- SNMP는 `MIB`라고 하는 별도의 규격을 사용한다. MIB는 네트워크의 노드로부터 추출할 수 있는 정보를 정의하고 있다.
- 시스템 그룹: 시스템 또는 노드 전체에 대한 변수를 취급하고 있다. 위치, 이름, 동작시간 등의 정보를 포함한다.
- 인터페이스 그룹: 이 그룹의 변수는 노드에 붙어 있는 모든 인터페이스(어뎁터)에 대한 정보를 가지고 있다. 인터페이스의 물리적 주소, 인터페이스를 통과한 패킷 수에 대한 정보도 포함도니다.
- 주소 변환 그룹: ARP에 필요한 정보, 주소 변환 테이블의 내용을 가지고 있다.
- IP 그룹: 이 그룹은 라우팅 테이블, 성공적으로 전달한 데이터그램의 수, 데이터 그램의 재조립에 대한 통계등을 포함해서 IP에 관련된 변수를 정의하고 있다. IP가 버린 데이터그램의 수를 나타내는 변수도 포함된다.
- TCP 그룹: TCP 연결에 관련된 정보를 포함하고 있다. passive 및 active 연결 횟수, 연결 재설정 횟수, 타임아웃 횟수, 디폴토 타임아웃 횟수 설정등의 정보를 포함하고 있다. 각 TCP 연결 정보는 그 연결이 존재하는 동안에만 유지 된다.
- UDP 그룹: UDP 트래픽에 관한 정보로, 주고 받은 UDP 데이터그램의 총 수등을 포함한다.
- 이외에도 ICMP, EGP 및 SNMP 자체에 대한 그룹도 있다.
- ASN.1 BER은 정수와 같은 여러 가지 데이터 유형에 대한 표현 기법을 정의하고 있다. 따라서 MIB가 각 변수의 유형을 정의하면, ASN.1 BER은 이 변수에 대한 값이 네트워크를 통해 전송될 수 있도록 부호화하는 데 사용된다. 첫 번째 문제에 관련해서 ASN.1은 각 객체의 식별 방법을 제공하고 있다. MIB에서는 각 MIB 변수에 전세계적으로 유일한 식별자를 할당하고 있다. 이 식별자는 인터넷 도메인 이름 처름 '.' 표시 방법으로 표시한다. 예를 들어, 1.3.6.1.2.1.4.3은 IP 관련 MIB 변수 `ipInReceives`(해당 노드에서 수신한 IP 데이터그램의 수를 의미)에 대한 유일한 ASN.1 식별자이다. 이 예에서 1.3.6.1.2.1은 MIB DB를 정의하고, 4는 IP 그룹, 3은 이 그룹의 세 번째 변수를 의미한다.
- SNMP 클라이언트는 얻고자 하는 MIB 변수의 ASN.1 식별자를 요구 메시지 속에 넣어 서버에 보낸다. 그러면 서버는 이 식별자를 지역 변수에 매핑시키고, 이 변수의 현재 값을 읽는다. 그리고 그 값을 ASN.1 BER을 사용해서 부호화한 후에 클라이언트에게 전달한다.
- MIB 변수 중에서 많은 변수가 테이블 혹은 구조체이다. 이러한 복잡한 변수 때문에 SNMP의 `GET-NEXT` 동작이 정의되어 있다. 이 동작이 특정 변수 ID에 적용될 경우, 그 변수의 값과 다음 변수의 ID를 돌려주게 된다. 이것은 클라이언트가 테이블이나 구조체의 요소를 전달하는데 유용하다.
