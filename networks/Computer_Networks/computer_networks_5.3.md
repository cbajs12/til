# 종단 간 프로토콜

## 원격 프로시저 호출
- 애플리케이션 프로그램에 의해 사용되는 통신의 가장 보편적인 패턴은 요구/응답 패러다임이며, 메시지 트랜잭션이라고도 한다. 클라이언트는 서버에게 요구 메시지를 보내고 서버는 응답 메시지로 답하며, 클라이언트는 이 응답을 기다리며 정지해 있다.
- 트랜스포트 프로토콜은 요구/응답 패러다임을 더 많이 지원한다. 원격 호스트와 응답에 관련된 요청에서 프로세를 올바르게 확인하는 것이 필요하다. 이러한 것은 기반 네트워크의 모든 한계를 극복하는 것까지 포함한다. 

### RPC 기본사항
- RPC는 실제로 프로토콜 이상이다. 분산 시스템 구성에 널리 사용되는 기법이며, 지역 프로시저 호출의 규정에 기반하고 있기 때문에 인기 있는 기법이다. 여기서 지역 프로시저 호출은 호출이 지역적인지 원거리인지에 관계없이 프로시지로 호출을 하고, 호출이 반환될 때까지 블록되는 애플리케이션 프로그램이다.
- 호출되고 있는 프로시저가 객체지향언어의 원격 객체의 실제 method라면 RPC는 원격 방법 호출(RMI)로 알려진다.
- 지역 프로시저 호출보다 RPC를 복잡하게 하는 문제점이 두가지 있다. 하나는 호출하는 프로세스와 호출당하는 프로세스 사이의 네트워크는 매우 복잡하다는 것과 프로세스를 호출하고, 호출당하는 컴퓨터들은 구조와 데이터 표현 형식에서 중요한 차이점을 가진다는 것이다.
- 따라서 완전한 RPC 기법은 두 가지 주요 구성 요소와 관련이 있다. 하나는 클라이언트와 서버 프로세스 사이에서 보내지는 메시지를 관리하고, 기반 네트워크의 잠재적으로 바람직하지 못한 성질을 다루는 프로토콜과 인자를 클라이언트 시스템으로의 요구 메시지에 포함시키도록 지원하고, 이 메시지를 다시 번역하여 반환값과 마찬가지로 서버 시스템으로의 인자에 포함시키는 프로그래밍 언어와 컴파일러(`스텁 컴파일러`)이다.
- 클라이언트는 프로시저에 대한 지역 클라이언트 스텁을 호출하는데, 그 프로시저가 요구하는 인자를 전달한다. 이 스텁은 인자를 요구 메시지로 변환하고, RPC 프로토콜을 호출하여 서버로 요구 메시지를 전달함으로써 프로시저가 원거리에 잇다는 사실을 감춘다. 서버쪽에서 RPC 프로토콜은 요구 메시지를 서버 스텁으로 전달하는데, 이 서버 스텁은 요구 메시지를 프로시저에 대한 인자로 변환한 뒤에 지역 프로시저를 호출한다. 서버 프로시저가 완료된 후 서버 스텁으로 응답을 리턴한다. 이 리턴값은 응답 메시지에 포함되어 클라이언트로 역전송되는데, 이를 위하여 우선 RPC 프로토콜로 전송된다. 클라이언트 쪽의 RPC 프로토콜은 이 응답 메시지를 클라이언트 스텁으로 전달하고 이 응답 메시지는 리턴값으로 변환되어 클라이언트 프로그램에게 리턴된다.
- RPC는 TCP 같이 특정 표준이라기보다는 프로토콜의 타입이다. 그래서 특정 RPC 프로토콜은 수행하는 기능 안에서 다양하다. 그리고 확실히 믿을 수 있는 바이트 스트림 프로토콜인 TCP와는 다르게 지배적인 하나의 RPC 프로토콜은 없다.

#### RPC 식별자
- RPC 프로토콜은 호출된 프로시저를 단일적으로 구분하기 위한 이름 공간을 제공하고, 각 요청 메시지에 대응하는 응답 메시지를 맞추는 기능을 가져야 한다.
- 설계 선택 중의 하나는 이 이름공간을 평면으로 할 것인지 계층적으로 할 것인지 결정하는 것이다.
- 평면 이름 공간은 각 프로시저에 비구조적 식별자를 정수형처럼 단일적으로 쉽게 할당한다. 그리고 할당된 수는 RPC 요청 메시지의 한 필드에 이동된다. 이는 다른 두 프로시저에 같은 프로시저 넘버를 할당하는 것을 피하기 위해 조정을 필요로 한다.
- 계층적 이름 공간은 파일의 이름을 디렉터리 안에서 단일하게 사용하는 것과 유사하다. 이런 접근은 잠재적으로 프로시저의 이름을 단일적으로 보장하게 한다. RPC의 계층적 이름 공간은 각 계층의 레벨을 나타내는 메시지 요청 형식의 여러 필드의 집합으로 정의해 구현될 수 있다.
- 요청에 대응되는 응답 메시지를 찾기 위해서는 메시지 ID 필드를 사용하여 요청-응답의 쌍을 확인해야 한다. 응답 메시지는 요청메시지와 같은 값의 메시지 ID 필드 집합을 가지고 있다. 클라이언트 RPC 모듈이 이 응답을 받았을 때, 대응되는 요청을 찾기 위해 메시지 ID를 사용한다. 호출자에게 RPC 트랜잭션을 지역 프로시저 호출로 보이기 위해 호출자는 응답메시지를 받을 때까지 중지도니다. 응답을 받았을 때 중지된 호출자는 응답 안에서 요청 넘버에 근거하여 확인되고, 호출자는 중지가 풀리고 값을 반환할 수 있다.
- RPC에서 되풀이되는 문제는 기대되지 않는 응답들을 다루는 것이다. 이러한 문제를 제거하기 위한 방법은 `boot ID`를 사용하는 것이다. 머신의 boot ID는 재부팅될때마다 증가한다. 이 넘버는 머신이 시작되는 동안 디스크에서 읽어와 증가시킨 후 다시 디스크에 쓰이게 된다. 또, 호스트에 의해 보내지는 모든 메시지에 포함된다. 새로운 boot ID가 있으나 이전 메시지 아이디로 이루진 메시지를 받는다면 새로운 메시지로 재구성된다. 메시지 아디이와 boot ID는 각 트랜잭션에 대해 단일 아이디의 형태로 결합한다.

#### 네트워크 한계의 극복
- RPC 프로토콜은 네트워크가 완전한 채널이 아니기 때문에 발생하는 요소를 처리하기 위해 추가적인 기능을 수행한다. 그것은 안정적인 메시지 전달 제공과 단편화와 재조립을 통하여 큰 사이즈의 메시지를 가능하게 하는 것이다.
- RPC 프로토콜은 UDP/IP 같은 기반 프로토콜을 제공하지 않고, 고쳐져야 하는 오류로부터 더 빠르고 효율적으로 회복되기 위해 안정성을 구현해야 할 것이다. RPC는 TCP와 비슷하게 ACK와 타임아웃을 사용하여 안정성을 구현할 수 있다.
- 기본 알고리즘은 클라이언트는 요구 메시지를 보내고 서버는 이 요구 메시지에 대하여 ACK를 보낸다. 그러고 나서 해당 프로시저를 실행한 후 그 서버는 응답 메시지를 보내고 클라이언트는 이 응답 메시지에 대하여 ACK를 보낸다.
- 메시지나 ACK가 손실될 경우를 대비하여, 클라이언트와 서버는 자신이 보낸 메시지의 복사본을 이 메시지에 대한 ACK가 도착할 때까지 저장하게 된다. 또한, 각 클라이언트와 서버는 RETRANSMIT 타이머를 설정하고 이 타이머가 타임아웃되면 해당 메시지를 재전달하게 된다. 또한 재전달 시도 횟수는 이미 서로 약속되어 있다. 각 클라이언트와 서버는 타이머를 재설정하고서 재전달을 시도한다. 지정 시도 횟수만큼 재전달 해도 성공하지 못하면 메시지 전달을 포기한다.
- RPC 프로토콜의 응답 메시지는 긍정 응답이기 때문에 추가적은 응답은 필요없다. 프로토콜이 요청-응답 트랜잭션을 순서대로 만든다고 하면 한 트랜잭션은 다른 트랜잭션이 시작하기 전에 완료되어야 한다. 그러나 이러한 순서는 RPC 수행을 엄격하게 제한한다.
- 이런 상황을 해결하는 방법은 RPC 프로토콜을 위해 가상 채널을 구현하는 것이다. 주어진 채널 안에서 요청/응답 트랜잭션은 순서화된다. 어느 특정시점에 주어진 채널 안에 단하나의 트랜잭션이 수행될 수 있다. 각각의 메시지는 채널 메시지가 속하는 곳을 나타내는 채널 ID 필드를 포함한다. 주어진 채널안에서 요청메시지가 아직 긍정응답을 받지 않았다면 채널 안에서 응답전에 암묵적인 긍정응답을 할 것이다. 
- 애플리케이션은 동시에 여러 응답/요청 트랜잭션을 가지기 원할 때 서버로 여러 채널을 열 수 있다. 
- RPC가 다뤄야 하는 다른 복잡성 문제는 서버가 결과를 생성하기 위해 임의의 긴 시간을 소비하는 경우이다. 더욱 나쁜 상황은 해당 프로세스이든 시스템 자체이든 응답 메시지를 생성하기 전에 crash에 빠지는 경우이다. 즉, 서버가 요구 메시지에 대한 ACK를 보내기는 했는데 아직 응답 메시지를 보내지 못한 시점에서 기능 장애가 발생될 수 있다는 것이다.
- 클라이언트가 속도가 느린 서버와 기능 장애로 완전히 마비된 서버를 구별하도록 하기 위해 RPC의 클라이언트 쪽에서는 주기적으로 정상 체크 메시지를 서버에게 보내고, 이에 대해 서버 쪽은 ACK를 보내 응답하게 된다. 또 다른 방법은 클라이언트가 서버의 상태를 묻지 않더라도 서버가 상태정상 메시지를 보낼 수도 있다. 그러나 클라이언트가 문의하는 방식이 서버 구현의 간편함 때문에 더 선호된다.
- RPC는 `일회 사용`이라는 특성을 포함한다. 이것은 클라이언트가 보내는 모든 요구 메시지에 대해 기껏해야 하나의 사본만 서버에게 전달된다는 것을 의미한다. 프로시저는 서버에서 기껏해야 한번만 호출된다. 기껏해야 한번이라는 것은 네트워크나 서버가 요구 메시지의 하나의 복사본조차도 전달하지 못하는 가능성이 있기 때문이다.
- 일회성 사용의 특징을 구현하기 위해 본래의 요청에 대한 응답을 했을지라도 서버 쪽에서 RPC는 중복요청을 인식하고 이를 무시해야 한다. 따라서 서버는 과거 요청을 확인하기 위한 상태정보를 유지하고 있어야 한다.
- 요청을 확인하는 방법에는 순서번호를 사용하는 방법이 있다. 그래서 서버는 단지 최근의 순서번호만을 기억하고 있으면 된다. 그러나 이런 방법은 현재 요청이 다음 요청이 오기전에 완료되어야 하기 때문에 주어진 서버로 한번에 하나의 요청이 되도록 RPC를 제한할 것이다. 그래서 채널은 서버가 각 채널에 대해 한번에 하나의 요청을 하도록 클라이언트를 제한하지 않고 현재의 순서수를 기억하면서 중복을 인식할수 있도록 해준다.
- 모든 RPC 프로토콜이 이러한 동작을 완벽히 지원하는 것은 아니다. 어떤 것은 `영 이상`규정이라는 클라이언트에서 각 호출은 원격 프로시저를 0회나 그 이상 호출하는 것을 사용한다. 원격 프로시저는 어떤 지역 상태 변수를 변화시킬 수도 있으며, 또는 원격 프로시저가 호출될 때마다 피부로 느낄 수 잇는 부작용을 발생시킬 수도 있다. 반면에 야기된 원격 프로시저가 멱등이라면 (다수의 요청이 하나의 효과를 갖는 것) RPC 매커니즘은 기껏해야 일회 원칙을 유지할 필요가 없다.
- RPC 프로토콜이 메시지 단편화와 재조립을 구현해야 하는 이유는 기반 프로토콜 스택에서 제공하지 않기 때문인 것과 RPC 프로토콜에 의해 더 효율적으로 구현될 수 있기 때문이다.
- RPC가 UDP/IP의 최상단에서 구현되고 단편화와 재조립이 IP에 의한 경우, 특정 시간안에 도착해야하 하는 메시지의 단편화된 일부분의 전송이 실패하게 되면 IP는 그 부분을 무시하고 메시지의 유효성은 없어지게 된다. 결국 RPC 프로토콜은 time-out이 되고 메시지를 재전송할 것이다. 이에 대조적으로 각각의 단편에 ACK와 NACK, 단편화와 재조립을 구현하는 RPC라면, 실패된 단편은 더 빠르게 발견되고 재전송될 것이다. 또한 메시지 전체가 아닌 실패한 단편만 보내게 될것이다.

#### 동기식 프로토콜과 비동기식 프로토콜
- 트랜스포트 계층에서 동기화의 정도는 동기, 비동기의 정도에 관한 어떤 확률 분로를 가진 스펙트럼으로 이해하는 것이 정확하다. 동기화의 정도에 대한 주요한 요인은 메시지를 전달하는 작업이 완료된 후 발신지가 그 작업의 성공 여부 등에 대해서 얼마나 알 수 있는가라고 할 수 있다.
- 즉, 어떠한 애플리케이션이 트랜스포트 계층에서 송신 작업을 했다고 하면, 이 작업이 완료된 후 그 작업의 성공 여부에 관해서 정확히 무엇을 알수 있는지를 말하는 것이다.
- 동기, 비동기의 정도에 관한 확률 분포를 가진 스펙트럼의 한쪽 끝은 완전한 비동기식이라고 할 수 있다. 송신 작업에 사용하는 프로토콜이 100% 비동기 일때 애플리케이션은 송신 작업이 완료되더라도 이 작업의 성공 여부에 대한 그 어떤 종류의 정보도 알지 못한다. 메시지가 상대편에 의해 수신되엇는지의 여부를 알지 못하며, 또한 메시지가 지역 호스트를 성공적으로 떠났는지조차도 확실하게 알지 못한다.
- 이 스펙트럼의 다른 한쪽 끝은 100% 동기식이라고 할 수 있는데 프로토콜이 완전히 동기식이라면 송신 작업은 일반적으로 응답 메시지를 발신지로 알려 주게 된다. 즉, 애플리케이션은 메시지가 상대편에 의해 수신되었는지를 알 수 있으며, 또한 상대편이 응답 메시지를 보내 주었는지를 알 수 있다. 
- 따라서, 동기식 프로토콜은 요구/응답 체계를 구현하는 반면, 비동기식 프로토콜은 수신자로부터의 응답을 기다리지 않고 많은 양의 메시지를 전송할 수 있는 경우 사용된다. 이러한 정의로 RPC 프로토콜은 동기식 프로토콜이라고 할 수 있다.
- 트랜스포트 프로토콜은 메시지가 원격 호스트에 성공적으로 수신될때까지 작업을 완료하지 않고 블록하지만, 그 호스트 상의 수신자가 실제로 메시지를 처리하고 이에 응답하기 전에 작업 완료하도록 송신 작업을 구현할 수 있다. 이것은 신뢰성 있는 데이터그램 프로토콜이라고 한다.

### RPC 구현

#### SunRPC
- 여러 가지 전송 프로토콜로 구현될 수 있다. 엄격한 계층은 전송 프로토콜을 실행하는 것을 어렵게 할 수 있고, 트랜스포트 계층 위에 있기 때문에 RPC는 트랜스포트 계층과 달라져야 한다.
- sunRPC는 원격 프로시저를 확인하기 위해 32비트 프로그램 넘버와 32비트 프로시저 넘버로 두 층의 식별자를 사용한다. 이 프로그램 넘버와 프로시저 넘버는 sunRPC 요청 메시지의 헤더 안에서 전송된다. 여러 프로그램 넘버를 지원할 수 있는 서버는 특정 프로그램의 특정 프로시저를 호출하기 위한 책임이 있다. sunRPC 요청은 같은 프로그램 넘버가 같은 네트워크 안에서 다른 머신에 의해 구현될지라도 실제로 특정 머신에 대해 프로그램과 프로시저를 호출하기 위한 요청을 표현한다.
- IP 주소 같은 서버의 머신 주소는 RPC 주소의 암묵적 세번째 층이다.
- 다른 프로그램 넘버들은 같은 머신에 다른 서버에 속할 수 있다. 다른 서버들은 다른 전송 계층 역다중화키들을 가지고 잘 알려지지 않은 수가 대부분이지만 대신에 동적으로 할당받는다. 그 역다중화 키들은 `전송 선택자`라 불린다. 특정 프로그램에게 정보를 주기 원하는 sunRPC는 대응되는 서버의 확인을 위해 사용되는 전송 선택자를 원격 머신에 단지 한 프로그램에게만 알려진 주소를 할당한다. 그리고 프로그램이 머신 안에 다른 프로그램에 도착하기 위한 전송 선택자를 가지는 클라이언트와 통신을 위한 임무를 다룬다.
- SunRPC 프로그램의 처음 버전은 포트매퍼라고 불렸고 단지 프로토콜 기반으로 UDP와 TCP만 지원을 했다. 이것으로부터 발전된 RPCBIND는 임의의 전송 프로토콜을 지원한다. 각 RPC 서버가 시작하면서 전송 선택자와 프로그램 넘버를 등록하기 위해 그 서버의 홈 머신의 RPCBIND 등록 프로시저를 호출한다. 그 다음 원격 클라이언트는 특정 프로그램 넘버를 위해 전송 선택자를 찾기 위한 RPCBIND 조사 프로시저를 호출할 수 있다.
- 요청 메시지에 대응되는 응답메시지를 일치시키기 위해서 요청과 응답 메시지의 헤더에 트랜잭션 ID(XID) 필드를 포함시켜서 RPC의 결과가 올바른 호출자에게 되돌아 올수 있도록 해야 한다. XID는 하나의 요청과 그에 대응되는 응답에만 사용되는 단일적인 트랜잭션 ID이다. 서버가 성공적으로 요청에 대한 응답을 한 후에는 XID를 기억하지 않는다. 이 때문에 sunRPC는 일회사용의 의미를 보장하지 못한다.
- sunRPC는 전송 프로토콜에 기반에 의존해 있다. sunRPC가 가지는 안정성을 구현하지 않고, 기반 전송이 안정적일 때 안정적이 될 수 있다. 물론, sunRPC를 실행하는 애플리케이션은 sunRPC 레벨 위에 안정성 매커니즘을 구현할지도 모른다.
- 네트워크 MTU보다 큰 요청과 응답 메시지를 보내기 위한 능력은 역시 전송 기반에 의존한다. sunRPC는 안정성과 메시지 사이즈를 위해 전송 기반의 향상을 위해 어떤 시도도 하지 않는다. sunRPC는 많은 다른 전송 프로토콜을 다룰 수 있기 때문에, RPC 프로토콜의 복잡한 설계 없이 상당한 유연성을 가질 수 있다.
- 요청 메시지는 가변적인 길이의 Credentials과 Verifier 필드를 포함한다. 이 두 필드는 서버에게 자신임을 증명하기 위해 클라리언트에 의해 사용된다. 즉, 클라이언트가 서버를 호출하기 위한 권리를 가지고 있음을 나타내는 단서를 주는 것이다.

#### DCE-RPC
- DCE-RPC는 UDP와 TCP를 포함한 여러 전송 프로토콜의 최상단에 구현될 수 있다. DCE-RPC도 sunRPC와 비슷하게 2레벨 번지지정 방식을 정의한다. 
- 전송 프로토콜은 적절한 서버로 디멀티플레스하고 DCE-RPC는 서버에 의해 보내진 특정 프로시저를 신속히 처리한다. 그리고 클라이언트들은 sunRPC의 포토매퍼와 비슷한 `앤드포인트 매핑 서비스`를 특정 서버에 어떻게 도달하는지 알기 위해 사용한다. 그러나 sunRPC와 다르게 일회 사용을 구현한다. DCE-RPC는 다중 호출을 지원하게 sunRPC와 비슷하게 멱등성을 포함하지만 일회 사용은 기본적인 행동이다.
- 클라이언트는 request 메시지를 보내고, 서버는 response 메시지로 응답하며, 클라이언트는 그 응답을 Ack한다. 그러나 서버가 요청 메시지에 ack하기 전에, 클라이언트가 주기적으로 서버에게 ping 메시지를 보낸다. 그때 원격 프로시저가 여전히 진행 중이라는 것을 가리키기 위해 working 메시지로 응답한다.
- 클라이언트는 서버에게 아직 진행중인 이전 호출의 취소를 요청하기 위한 quit 메시지를 보낸다. 서버는 quack 메시지를 가지고 응답한다. 또한 서버는 reject 메시지(호출이 거절 되었다는 것을 의미)를 가지고 request 메시지에 대해 응답한다. 그리고 그것은 nocall 메시지를 가지고 ping 메시지에 대해 응답한다.
- DCE-RPC 안에 각 요청/응답 트랜잭션들은 activity 관점에서 일어난다. acitivity는 두 짝 사이의 논리적인 응답/요청 채널이다. 언제나 단 하나의 메시지 트랜잭션만이 채널 안에서 활동 상태가 될 수 있다.
- 애플리케이션들은 동시에 그들 사이에 여러 응답/요청메시지를 가지기를 원한다면 다중 채널을 열어야 한다. 메시지가 속하는 acitivity는 메시지의 AcitivityId 필드에 의해 확인돈다. 이때 SequenceNum 필드는 같은 동작의 부분으로써 이루어진 호출들을 구분한다. 이것은 sunRPC의 XID와 같은 목적으로 사용된다. sunRPC와 달리 DCE-RPC는 일회 사용 규정을 준수하기 위하여 특별한 동작의 부분으로써 사용된 마지막 순서번호를 유지한다. 서버머신의 재부팅 전후에 보내진 응답을 구별하기 위해 DCE-RPC는 SeverBoot 필드를 머신 boot ID를 얻기 위해 사용한다.
- DCE-RPC는 sunRPC와 달리 RPC 프로토콜에서 단편화와 재조립을 지원한다. RPC의 부분으로 구현된 단편화/재조립 알고리즘은 단편을 잃었을 때 대역폭의 소비를 줄이고 빠른 회복을 할 수 있다.
- FragmentNum 필드는 요청이나 응답 메시지에 의해 만들어진 각각의 단편들을 단일하게 확인하게 된다.
- 각각의 DCE-RPC 프래그먼트는 단일한 프래그먼트번호를 할당받는다. 클라이언트와 서버는 다음과 같이 동작하는 선택적인 ack 전송 메커니즘을 구현한다.
- 첫째, 요청 메시지를 구성하는 각각의 프래그먼트는 단일한 FragementNum와 이 패킷이 호출의 하나의 프래그먼트인지 또는 호출의 마지막 프래그먼트인지를 가리키는 플래그를 포함한다. 하나의 패킷에 적합한 요청 메시지들은 `no_flag` 플래그로 나타낸다. 서버는 `last_frag` 패킷을 받고 그것들의 프래그먼트 번호들 사이에 어떤 누락된 것이 없을 때 완벽한 요청 메시지를 받았다는 것을 알게된다.
- 둘째, 각각의 도착하는 프래그먼트에 대한 응답으로, 서버는 클라이언트에게 Fack 메시지를 보낸다. 이 ack는 서버가 성공적으로 받았던 가장 높은 프래그먼트 번호를 확인한다. 다시 말하면 ack는 TCP에서와 같이 누적되는 것이다. 그러나 추가적으로 서버는 순서 없이 받은 어떤 더 높은 프래그먼트 번호들에 대해서 선택적으로 ack한다. 그것은 순서대로 받은 가장 높은 프래그먼트로부터 에러가 생신 프래그먼트를 확인하기 위하여 bit-vector를 사용한다. 마지막으로 클라이언트는 빠진 프래그먼트들을 재전송하여 응답한다.
- 서버가 프래그먼트 20, 23, 25, 26을 성공적으로 받았다고 한다면, 서버는 순서대로 받은 가장 높은 프래그먼트로서 프래그먼트 20번을 확인하는 Fack과 세번째 (20+3), 다섯째(20+5), 여섯째(20+6) 비트들을 변화시킨 bit-vector(SelAck)들을 가지고 응답한다. 긴 bit-vector를 지원하기 위하여 SelAckLen 필드는 32비트 워드를 사용하고 있다.
- DCE-RPC는 매우 큰 메시지를 지원하기 위해 FragmentNum 필드를 16비트로 사용하고 있는데 이것은 수신자를 과도하게 함으로써, 모든 프래그먼트들이 가능한 한 빠르게 메시지를 구성하는 데는 적절하지 않다. 대신에 DCE-RPC는 TCP와 매우 유사한 흐름제어 알고리즘을 사용한다. 특히, 각가의 Fack 메시지는 수신된 프래그먼트들을 ack할 뿐만 아니라 송신자에게 얼마나 많은 프래그먼트들이 지금 보내지는지를 알려준다. 이것은 바이트가 아닌 프래그먼트 개수를 계산하는 것을 제외하고는 TCP의 AdvertisedWindow 필드와 정확히 같은 역할을 하는 것이 WindowSize 필드의 목적이다. 
- DCE-RPC는 또한 TCP와 유사한 혼잡 제어 메커니즘을 사용한다.
