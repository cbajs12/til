# 혼잡 제어와 자원 할당

## 혼잡 회피 기법
- TCP 전략은 혼잡 상태를 없애기보다는 혼잡 상태가 발생하면 이를 완화시킨다. 실제로 TCP는 혼잡 상태가 일어날 때까지 끊임없이 네트워크 전달량을 늘린다. 그러다 혼잡 상태가 발생하면 이를 해소시켜 다시 혼잡 상태 이전으로 되돌린다. 다시 말해서, TCP는 연결이 가용한 대역폭을 알기 위해서 어느 정도의 패킷 손실은 피할 수 없다.
- 언제 혼잡 상태가 발생할 것인가를 예측하고 호스트가 보내는 패킷이 손실되기 시작하기 바로 전에 보내는 양을 줄이는 전략을 `혼잡 회피`라고 한다.

### DECbit
- 이 방법은 비연결성 네트워크 기반에서 연결성 트랜스포트 프로토콜을 사용하는 DNA에서 개발하였다. 따라서, 이 방법은 TCP와 IP에 적용할 수 있다. 이것은 혼잡 상태를 조절하는 책임을 보다 공평하게 분담한다.
- 각 라우터는 노드를 검사함으로써 언제 종단 노드가 혼잡 상태가 일어날지를 안다. 이것은 라우터에 흐르는 패킷에 혼잡 비트를 설정함으로써 구현할 수 있다. 따라서 DECbit이라고 한다. 목적지 호스트는 이 혼잡 비트를 발신지로 다시 보내는 ACK에 복사한다. 마지막으로 발신지는 혼잡 상태를 없애기 위해서 전달률을 조절한다.
- 한 비트의 혼잡 비트가 패킷의 헤더에 추가된다. 라우터는 패킷이 도착할 때 자기의 평균 길이가 1이나 그 이상일 때 패킷에서 이 비트를 설정한다. 이때 평균 큐 길이는 직전의 busy 시간과 유휴시간, 그리고 현재의 사용 중 시간 사이의 간격을 가지고 구한다.
- 혼잡 비트를 설정하는 기준으로 큐 길이 1을 사용하는 것은 큐에 저장하는 것과 유휴 시간을 늘리는 타협의 기준이 된다.
- 발신지는 얼마나 많은 패킷이 몇몇 라우터에서 혼잡 비트를 설정했는지를 기록한다. 특히 발신지는 TCP에서와 같이 Congestion Window를 관리하고 어느 정도의 패킷에서 이 비트가 설정되었는지를 검사한다. 50% 또는 그 이상의 패킷에서 이 비트가 설정되었다면 발신지는 Congestion Window의 크기를 이전 크기의 0.875로 줄인다. 50%는 최대 성능 분석 곡선에 기반한 임계값으로 선택되었다. 산술적 증가/배수적 감소 기법은 혼잡 제어 기법을 안정하게 만들기 때문에 `1의 크기로 늘리고 0.875배로 줄이는 규칙`을 선택하였다.

### RED
- RED는 각 라우터가 자신의 큐 길이를 감시하고, 혼잡 상태를 발견했을 때 발신지가 Congestion Window를 조절하도록 프로그램되어 있다는 점에서 DECbit와 유사하다.
- RED는 DECbit과 두가지 면에서 다르다. 첫 째는 명시적으로 혼잡 메시지를 보내는 대신에 RED는 패킷을 분실시키는 암시적 방법으로 발신지에게 알려 준다. 따라서 발신지는 연속적으로 타임아웃이 발생되거나 중복된 ACK를 받는다. RED는 TCP와 연동하여 사용할 수 있으며, 타임아웃 또는 중복 ACK와 같은 방법을 사용하여 혼잡 발생 여부를 알리도록 고안되었다.
- 게이트웨이는 실제 패킷 손실이 발생하기 전에 패킷을 손실시켜 발신지가 Congestion Window를 정상적일 때보다 작게 만들도록 한다. 다시 말해서, 라우터는 실제보다 빨리 몇 개의 패킷을 버려서 발신지가 이후에 보다 많은 패킷이 손실되지 않도록 속도를 늦추게 만든다. RED는 패킷을 버리기보다는 표시만 하여 명시적 피드백 방법에 적용할 수 있도록 개선시킬 수 있다.
- 두 번째는 RED가 어떻게 패킷을 버리며, 또한 어떤 패킷을 버릴 것인가를 결정하는 데 있다. FIFO 큐에서 큐가 완전 차기를 기다린 다음에 패킷을 버리기보다는, 큐에 어느 정도 찼을 때 임의의 폐기 확률을 적용하여 패킷을 버리는 방법을 사용할 수 있다. 이것을 `임의의 선행 폐기`라고 한다. RED 알고리즘은 어떻게 큐의 길이를 감시하고 언제 버릴 것인가를 정의한다.
- Floyd와 Jacobson에 의해 제안된 RED 알고리즘은 아래와 같이 수행된다.
- 첫 번째, RED는 TCP가 타임아웃을 계산하는 데 사용하는 방법과 유사한 가중값 평균을 사용하여 평균 큐 길이를 계산한다. 즉, `AvgLen = (1 - Weight) * AvgLen + Weight * SampleLen`이다.  여기서 `0 < Weight < 1`이고 SampleLen은 샘플 측정이 이루어졌을 때 만들어진 큐 길이이다. 거의 모든 소프트웨어에서는 매 시간 게이트웨이에 패킷이 도달할 때마다 큐의 길이를 계산하고 하드웨어에서는 어떤 고정된 샘플 간격에서 계산된다.
- 순간의 값보다 평균 큐 길이의 값을 사용하는 이유는 혼잡의 개념을 더 정확하게 하기 위한 것이다. 인터넷 트래픽의 갑작스런 증가로 인해 큐는 매우 빨리 차게 되고 그리고 다시 비게 된다. 따라서, 큐 길이에 있어서 단기간 변화를 걸러줌으로써 가중값 평균 계산은 오랫동안 지속되는 혼잡을 감지하려고 노력할 것이다. 필터의 지속시간을 결정하는 Weight가 있는 저역 통과 필터로서 평균값을 생각해 볼 수 있다.
- 두 번째, RED는 어떤 행동을 감시하기 위해서 두 개의 큐 길이 임계값을 둔다. MinThreshold와 MaxThreashold이다. 패킷이 게이트웨이에 도달할 때 RED는 다음과 같은 규칙에 의하여 현재의 AvgLen은 두 개의 임계값과 비교한다.

```cpp
	if AvgLen <= MinThreshold
		queue the packet
	if MinThreshold < AvgLen < MaxThreashold
		calculate probablility P
		drop the arriving packet with probability P
```

- 즉, 평균 큐 길이가 하한 임계값보다 작으면 아무런 동작도 이루어 지지 않는 것이고, 상한 임계값보다 크면 패킷은 항상 버려진다. 평균 큐 길이가 두 개의 입계값 사이에 있으면 새로 도착하는 패킷은 확률 P를 가지고 버린다. 두 개의 임계값 사이에서 AvgLen값은 버리는 확률이 서서히 증가하는데, 상한 입계값이 MaxP에 도달해서는 통일된 증가를 한다. 이것의 이론적 근거는 만약 AvgLen이 상한 임계값에 도달해서 서서히 접근이 안되고, 철저한 측정들이 요구되는, 즉 도착하는 모든 패킷을 버리는 것에 있다. 
- 사실 P는 AvnLen과 마지막 패킷이 버린 후 시간이 얼마나 지났는가에 따라 결정되는 함수이다. 구체적으로 `TempP = MaxP * (AvgLen - MinThreshold) / (MaxThreshold - MinThreshold)`, `P = TempP / (1 - count * TempP)`으로 구한다.
- count는 AvgLen이 두 임계값에 존재하는 동안, 패킷들이 손실되지 않고 큐에 저장되는 새로 도착한 패킷의 개수를 의미한다. P는 count가 증가함에 따라 서서히 증가한다. 그러므로 시간에 따라 손실이 증가하게 된다. 이것은 비교적 넓은 간격의 손실보다 더 적은 짧은 간격의 손실을 만든다. 
- 이 P를 계산하는 데 있어서의 여분의 과정들은 RED 없이는 패킷의 손실이 시간에 따라 다발성으로 일어나는 경향을 보인다는 것을 알려준다. 어떤 연결에서 패킷의 도착은 갑자기 몰려서 발생하기 때문에, 이러한 다발성 손실은 단일 접속에서 다중 손실의 원인과 비슷하다. 
- 만약 RED가 AvgLen이 MinThreshold를 초과할 때 패킷의 작은 부분을 폐기한다면, 그 효과는 라우터에 패킷이 도착하는 속도를 감소시킬 윈도우 크기의 감소를 유발시키는 TCP 연결을 거의 야기시키지 않게 된다. 잘 되면 AvgLen은 감소하고 혼잡을 피할 수 있을 것이다. 패킷이 거의 폐기되지 않기 때문에 효율이 높은 동안에는 큐의 길이가 짧게 유지될 수 있다.
- RED는 시간 내 평균적인 큐의 길이에 따라 동작하기 때문에 순간적인 큐의 길이는 AvgLen보다 훨씬 길 수 있다. 이 경우에 만약 패킷이 도착하고 이 패킷을 처리할 수 없을 때 이것은 폐기될 것이다. 이러한 것이 일어나면 RED는 끝부분 폐기 모드에서 작동한다. RED의 목적중 하나는 가능하다면 끝부분 폐기를 막는 것이다.
- RED의 랜덤한 성질은 패킷을 무작위로 버리는데, 특정 흐름의 패킷을 그 흐름이 사용하고 있는 대역폭에 비례하여 무작위로 페기한다. 즉, 패킷이 많아지면 상대적으로 더 많이 버려질 것이기 때문이다. 따라서 정확한 방법이 아닐지라도 RED에 공정한 자원 할당을 이루는 기법이 제공되어야 한다.
- 트래픽이 매우 bursty한 특성이 있다면 Minthreshold는 링크 사용률이 충분히 높은 단계로 유지되도록 매우 큰 값을 가져야 한다. 또한, 두 임계값의 차가 한 RTT에서 계산된 평균 큐 길이의 증가속도보다 커야 한다. MaxThreashold값을 MinThreashold의 두 배로 정하는 것은 합리적 선택이다. 추가로 평균 큐 길이가 높은 부하시에도 두 임계값 사이에 머물기를 기대하기 때문에 MaxThreashold보다 큰 충분한 여유 버퍼 공간이 라우터에게 있어야 한다. 이렇게 되어야 RED가 끝부분 폐기 모드에 들어가지 않고 인터넷 트래픽에 생기는 자연적인 폭발 현상을 흡수할 수 있다.
- RED는 혼잡이 발생된 시간 동안 패킷을 폐기함으로써 TCP 흐름에 정보를 제공한다. 한 라우터가 어떤 TCP 연결에서부터 패킷을 폐기했다고 하면, 즉시 같은 연결로부터 좀더 많은 패킷이 전해지게 된다. 이 패킷이 수신자에게 도착했을 때 이중 ACK를 송신자에게 보내기 시작할 것이다. 송신자가 이중 ACK를 수신하였을 때, 자신의 윈도우 크기를 줄일 것이다. 따라서, 윈도우의 크기를 줄인다는 관점에서 영향을 받은 연결에서 나온 완화책은 그 연결에서 적어도 하나의 round-trip을 할 시간을 지나서 나올 것이다. 어떤 라우터를 통과하는 연결 중 round-trip보다 더 적은 시간 안에 혼잡에 응답할 수 있는 라우터들은 거의 없을 것이다. weight는 평균 round-trip보다 작은시간 단위는 걸러내고 큐 길이의 변화하는 중에서 선택되어야 한다.
- RED는 TCP 흐름에 신호를 보내는 것으로 그들에게 속도를 줄이라고 알려주는 형식으로 동작하기 때문에 이 신호가 무시된다면 `반응하지 않는 흐름 문제`를 나타낸다. 이것은 자신에게 주어진 공평한 분배량보다 더 많은 네트워크 자원을 사용한다. 그리고 TCP의 혼잡 제어가 사용되기 전에는 그럼 흐름들이 많을 경우 혼잡 충돌을 야기시킬 수도 있다.

### 발신지 기반 혼잡 회피
- 이전의 두 혼잡 회피 기법과 달리, 종단 호스트에서 혼잡 상태의 초기 단계를 검출하는 방법이다.
- 이 기술의 일반적인 생각은 약간의 라우터 큐가 증가하면서 곧 혼잡 상태가 일어날 것이라는 네트워크로부터의 신호를 살피는 것이다. 예로, 발신지는 네트워크 라우터의 패킷 큐가 증가할 때 발신지가 전달하는 각각의 연속적인 패킷에 대한 RTT의 증가를 감지할 것이다. 
- 첫 번째 알고리즘은 다음과 같은 관찰을 이용한다. 정상적인 상태에서 Congestion Window는 TCP에서처럼 증가한다. 그러나 두 번의 왕복 지연시간마다 알고리즘은 현재의 RTT가 최소 RTT와 최대 RTT의 평균값보다 큰지를 검사해서, 크다면 1/8까지 Congestion Window를 감소시킨다.
- 두 번째 알고리즘은 첫 번째 알고리즘과 유사한 일을 한다. 현재의 윈도우 크기를 조정하는 방법은 RTT와 윈도우 크기의 변화에 의존한다. 두 번의 왕복지연시간마다 한 번씩 `(CurrentWindow - oldwindow) * (currentRTT - oldRTT)`를 통해 윈도의 크기가 조정된다. 결과가 양수이면, 발신지는 1/8까지 윈도우의 크기를 감소시킨다. 결과가 음수이거나 0이면 발신지는 최대 패킷 크기까지 윈도우의 크기를 증가시킨다. 모든 조정 시기마다 윈도우는 변화한다. 즉, 윈도우 크기는 최적값에 근사한다.
- 네트워크가 혼잡 상태에 근접할 때 보이는 또 다른 변화는 전달률이 일정해진다는 점이다. 세 번째 알고리즘은 이러한 사실을 이용한다. 모든 RTT마다 알고리즘은 한 패킷씩 윈도우 크기를 증가시킨다. 그리고 윈도우 크기가 한 패킷 작을 때 얻었던 처리량과 현재의 처리량을 비교한다. 그 차이가 단지 한 패킷만을 전달했을 때 얻었던 처리량의 반보다 작으면 알고리즘은 윈도우 크기를 한 패킷 감소시킨다. 이러한 알고리즘은 네트워크에서 흐르고 있는 바이트 수를 RTT로 나눔으로써 현재의 처리량을 얻는다.
- 네 번째 기법은 처리량에서의 변화 또는 전달률에서의 변화를 살핀다는 점에서 이전의 알고리즘과 유사하다. 그러나 이 알고리즘이 처리량을 다르게 계산하고, 처리량의 변화를 살펴보는 대신에 측정된 처리량을 기대 처리량과 비교한다는 점에서 세 번째 알고리즘과는 다르다. 이것은 `TCP Vegas`라고 불린다.
- TCP Vegas는 여분의 데이터량을 측정하고 조정한다. 여분의 데이터는 대역폭이 허용하는 전달 데이터량을 초과하는 데이터를 의미한다. TCP Vegas의 목적은 네트워크 상에서 여분의 데이터량을 적정 수준으로 유지하는 것이다. 발신지가 여분의 데이터를 너무 많이 전달하면 지연시간이 늘어나게 되고 혼잡 상태로 될 가능성이 커진다. 또한 너무 적인 여분의 데이터를 전달하면 가용 네트워크 대역폭의 순간적인 증가에 빠르게 반응하지 못할 수도 있다. TCP Vegas에서 혼잡 회피 활동은 폐기된 패킷과 네트워크 상에서 측정된 여분의 데이터량에 따라 다르게 나타난다.
- 이 알고리즘은 주어진 흐름의 BaseRTT가 흐름이 혼잡 상태가 아닐 때 패킷의 RTT가 되도록 정의한다. 실제로 TCP Vegas는 모든 측정된 왕복 지연시간의 최소값으로 BaseRTT 값을 설정한다. 이것은 흐름에서 발생되는 트래픽에 의하여 라우터의 큐가 증가하기 전, 설정 초기에 보내진 처음 패킷의 RTT이다. 연결에서 트래픽이 과잉되지 않는다고 가정하면 기대된 처리량은 `ExpectedRate = CongestionWindow / BaseRTT`이다. Congestion Window는 전달 중에 있는 바이트 수와 같다고 가정한다.
- 또한, TCP Vegas는 현재의 전달률을 계산한다. 이것은 각 패킷에 대해서 전달시간을 기록하고, 패킷을 전송하고 ACK가 돌아올 때까지의 시간 동안 얼마나 많은 바이트가 전송되고 있는지를 기록하고, ACK가 도착할 때마다 각각의 패킷에 대해 RTT를 계산하고 전송된 바이트 수를 RTT로 나누는 과정을 통해 계산된다. 이 계산은 왕복지연시간마다 한 번씩 행해진다.
- 마지막으로, TCP Vegas는 ActualRate와 ExpectedRate를 비교하고 그에 따라 윈도우 크기를 조절한다. `Diff - ExpectedRate - ActualRate`라고 정의하자. `ExpectedRate < ActualRate`라면,  BaseRTT는 가장 최근의 RTT 값으로 설정되기 때문에 Diff는 정의에 의해서 항상 양수이거나 0의 값을 가진다. 또한 두 임계값 a와 b를 정의한다. a와 b는 각각 네트워크 상에서의 최소, 최대 여분의 데이터를 나타낸다. Diff < a일때, TCP Vegas는 다음 RTT 동안 CongestionWindow의 크기를 산술적으로 증가시킨다. 그리고 Diff < b일 때, TCP Vegas는 다음 RTT 동안 CongestionWindow의 크기를 산술적으로 감소시킨다. TCP Vegas는 a < Diff < b일 때 CongestionWinodw의 크기를 그대로 유지한다.
- 기대 처리량과 실제 처리량의 차이가 커질수록 네트워크에서의 혼잡 상태는 증대될 것이다. 이것은 전달률이 감소되어야 함을 의미한다. b 임계값은 실제 처리량의 이러한 감소를 촉진한다. 한편 기대 처리량과 실제 처리량이 너무 근접해 있을 때 사용 가능한 대역폭을 이용하지 못하게 된다. a 임계값은 실제 처리량의 증가를 촉진한다. 이러한 작업을 수행하는 목적은 네트워크에서 여분의 데이터를 a 와 b값 사이에 유지하는 것이다.
- 네트워크의 안정도를 보장하기 위해 기하급수적 감소가 필요하다는 원칙과는 달리 TCP Vegas는 CongetstionWindow를 산술적으로 감소시키는 것으로 보인다. 그러나 TCP Vegas는 타임아웃이 발생할 때, 기하급수적 감소를 사용한다. 산술적 감소는 혼잡 상태가 발생하여 패킷이 폐기되기 전의 CongestionWindow에서 일어난다.
