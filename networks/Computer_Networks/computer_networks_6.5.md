# 혼잡 제어와 자원 할당

## 서비스 품질
- 일단 디지털화되면, 오디오와 비디오 자료는 작은 조각들이 연결된 스트림이 전송되는 것처럼 단지 다른 형태의 데이터가 된다. 이러한 가능성을 실행시키는데 하나의 장애물은 높은 대역폭에 대한 욕구이다. 그러나 최근 코드화의 발전은 오디오와 비디오 애플리케이션에서 대역폭 필요성을 감소시키는 반면 동시에 연결속도는 증가되고 있다.
- 단지 충분한 대역폭을 제공하는 것보다 하나의 네트워크로 오디오와 비디오를 전송하는 것이 중요하다. 그래서 적기의 전달이 매우 중요하다.
- 실시간 애플리케이션의 두드러진 특징은 데이터가 정시에 도달하리라는 네트워크로부터의 확신이 필요하다는 것이다. 반면에, 비실기간 애플리케이션은 데이터가 정확하게 도착하는 것을 보장하기 위해 종단 간 재전송을 사용하는데, 그러한 전략은 데이터의 전송의 적시성을 제공할 수 없다. 실시간 도달은 네트워크 끝에 있는 호스트에서가 아니라, 네트워크 그 자체에 의해서 제공되어야만 한다. 그러므로 네트워크는 여러분의 데이터를 전달하려고 시도하지만 확실성을 제공하지 않고 호스트에 마지막 처리작업을 맡기는, 최대 노력 모델이 실시간 애플리케이션에 적합하지 않다는 결론이 나온다. 
- 다른 서비스 레벨을 제공하는 네트워크는 서비스 품질(QoS)을 지원한다고 말한다.

### 애플리케이션 요구
- 먼저 애플리케이션들은 실시간과 비실시간으로 나눌수 있다. 후자는 데이터 네트워크에서 발견되는 전형적으로 주요한 애플리케이션들이므로 때때로 전형적인 데이터 애플리케이션들이라고 일컬어진다. 또한, 이 애플리케이션들은 게속 지연됨에도 불구하고 점차적으로 확장되기 때문에 비실시간 애플리케이션 클래스에 대한 또 다른 용어는 `탄력성`이다. 이러한 애플리케이션들은 지연이 점차 짧아짐으로써 이익을 얻을 수 있다. 지연이 계속 증가하더라도 이러한 애플리케이션들이 쓸모 없게 되지는 않는다.

#### 실시간 오디오의 예
- 실시간 애플리케이션의 예로써, 데이터는 마이크로폰에서 샘플들을 모아 아날로그에서 디지털로의 전환을 사용하여 샘플들을 디지털화시킴에 의하여 만들어진다. 디지털 샘플들은 패킷에 넣어지게 되는데, 그것은 네트워크로 전달되어 다른 쪽 호스트에서 수신하게 된다. 그러한 데이터는 수신 호스트에서 적당한 속도로 정확히 재생되어야 한다. 그래서 우리는 각 샘플들이 특정한 재생시간을 가진다고 생각할 수 있다. 만일 네트워크에서 지연되거나 버려지게 되어 데이터가 적절한 재생시간 후에 도달한다면, 그 데이터는 근본적으로 쓸모가 없다. 반면 탄력적 애플리케이션에 있어서, 데이터가 정시에 나타난다면 좋겠지만 정시에 나타나지 않아도 여전히 그 데이터를 사용할 수 있다.
- 음성 애플리케이션을 작동시키는 한 방법은 모든 샘플들이 네트워크로 전달되는 데 있어서 정확히 똑같은 시간이 걸리도록 만드는 것이다. 그러나 패킷 교환 방식의 네트워크를 가로지르는 모든 데이터가 정확하게 똑같은 지연을 겪게 되리라고 보장하는 것은 어렵다. 패킷들은 스위치나 라우터에서 큐들을 만나게 되고, 이러한 큐의 길이는 시간이 흐름에 따라 다양해진다. 큐의 길이는 오디오 흐름 내에 있는 각 패킷마다 다르다. 수신자 편에서 이것을 다루는 방식은 적당한 시간에 재생되기를 기다리는 패킷의 저장물을 늘 제공하는 완충 버퍼에 약간의 데이터를 저장해 두는 것이다. 만약 패킷이 약간 지연된다면, 재생시간이 도달할 때까지 버퍼에 있게 된다. 만약 패킷이 오랜 시간 지연된다면, 재생되기 전에 수신자의 버퍼에 매우 오랫동안 머물 필요가 없다. 그래서 모든 패킷의 재생시간에 정확히 재생되도록 보장할 수 있다. 우리는 이러한 재생시점을 `재생점`이라고 부른다. 만약 패킷들이 재생시간 후에 도달할 만큼 오랜 시간 동안 네트워크에서 지연된다면 재생 버퍼가 비게될 것이다.
- 오디오 애플리케이션에 있어서, 데이터를 재생시키는 데 얼마나 많이 지연될 수 있는가에는 한계점들이 있다. 만약 데이터가 일찍 도달한다면, 정확한 재생시간까지 그것을 버퍼에 저장한다. 만약 데이터가 늦게 도달한다면, 그 데이터는 쓸모 없으므로 버려야 한다.

#### 실시간 애플리케이션들의 분류
- 애플리케이션들을 분류시킬 수 있는 첫 번째 특징은 데이터 손실에 대한 묵인이다. 손실은 네트워크의 일반적인 원인들로부터 유발되거나 패킷이 너무 늦게 도달해서 재생될 수 없기 때문에 일어난다. 오디오의 경우, 하나의 손실된 오디오 샘플은 주위의 샘플들로부터 대체될 수 있다. 그러나 로봇제어의 경우에는 손실을 묵인할 수 없는 애플리케이션이 된다. 애플리케이션들이 간헐적인 손실을 묵인할 수 있느냐에 따라 `묵인 또는 비묵인`으로 실시간 애플리케이션들을 분류할 수 있다.
- 두 번째 방식은 그들의 적응성에 의해 결정된다. 예를 들어, 오디오의 경우 패킷이 네트워크를 통해 전달될 때 겪게 되는 지연의 양에 적응할 수 있다. 만약 대부분의 패킷들이 보내어 진 후 특정 지연 시간 이내에 도달한다는 것을 인지한다면, 그 지연시간보다 일찍 도달하는 패킷들을 버퍼링하면서 재생점을 적절하게 설정할 수 있다. 그러나 몇몇 패킷들이 늦게 도달한다면, 그러한 패킷들으 누락시켜야 할 것이다. 하지만 이때, 재생점을 늦게 설정한다면 그러한 패킷들이 누락되지 않을 것이다. 이렇게 재생점을 이동하는 것은 측정된 최신 자료나 네트워크로부터 어떤 확신이 있기 때문이다.
- 재생점을 조절할 수 있는 애플리케이션들을 `지연 적응` 애플리케이션이라고 한다. 적응 애플리케이션들의 또 다른 종류는 `속도 적응` 애플리케이션들이 있다. 예를 들어, 많은 비디오 부호화 알고리즘들은 품질과 비트 속도 간에 상관관계가 있다. 만약 네트워크가 어떤 대역폭을 지원할 수 있다면, 그에 따라 부호화 인자들을 적절하게 설정할 수 있다. 만약 대역폭에 더욱 여유가 있다면, 품질 향상을 위해 매개변수들을 변화시킬 수 있다.

#### QoS 지원 방법
- 어떠한 애플리케이션이라도 만족해 줄 수 있는 보다 풍부한 서비스 모델을 위하여, 여러 개의 클래스들을 제시하도록 한다. 각각의 클래스들은 특정 집합의 애플리케이션들의 요구를 만족하게 된다.
- 미시적 접근법: 개개의 애플리케이션이나 흐름에 QoS를 지원
- 거시적 접근법: 대규모 데이터 클래스들이나 통합된 트래픽에 QoS를 제공
- 미시적 접근법에는 IETF에서 개발하고 RSVP와 연관이 있는 QoS 구조인 통합 서비스가 있다. ATM의 QoS 방법도 이 범주에 들어간다. 거시적 접근법에는 차별화된 서비스 Qos 매커니즘이 있다.

### 통합 서비스
- 통합 서비스 워킹 그룹은 애플리케이션들의 요구에 부합하도록 고안된 여러 서비스 클래스들의 규격을 만들었다. 또한 통합 서비스 워킹 그룹은 이러한 서비스 클래스들을 사용하여 예약하기 위해 RSVP를 어떻게 사용할 수 있는지를 정의하였다.

#### 서비스 클래스
- 서비스 클래스 중의 하나는 비허용 애플리케이션들을 위해 설계되었다. 이러한 애플리케이션들은 하나의 패킷도 결코 늦게 도달해서는 안된다는 것을 요구한다. 네트워크는 패킷이 겪게 될 최대한의 지연이 어떤 규정된 값이 되어야 한다. 애플리케이션은 어떤 패킷도 재생시간 후에 도달하지 않도록 하기 위해서 재생점을 조절할 수 있다. 일찍 도달한 패킷들은 버퍼링에 의하여 늘 다루어진다. 이러한 서비스는 `보장된` 서비스로 언급된다.
- 허용되고 적응적인 애플리케이션들의 요구에 부합하기 위해 `통제된 로드(load)`라는 서비스를 결정했다. 이 서비스의 목표는 전반적으로 네트워크가 과중하게 적재되었을지라도 그러한 서비스를 요구하는 애플리케이션에 대해 가볍게 로드된 네트워크를 에뮬레이트하는 것이다. 이렇게 하기 위한 기술은 통제된 로드 트래픽과 다른 트래픽을 분리하기 위해 WFQ와 같은 큐잉 메커니즘을 사용하거나 통제된 로드 트래픽의 모든 양을 다소 낮게 로드되는 링크에 한정시키기 위해 수락제어의 형태를 사용하는 것이다.

#### 메커니즘의 개요
- 최대 노력 서비스의 경우에 패킷이 네트워크를 통해 전달되기만을 바라는 반면에, 실시간 서비스는 이보다 많은 것을 네트워크에 요구할 수 있다. 어떠한 서비스를 사용하라와 같은 질적인 정보나 최대한 얼마의 지연이 필요하다와 같은 양적인 정보를 네트워크에 준다. 또한, 낮은 대역폭 애플리케이션이 높은 대역폭 애플리케이션보다 더욱 작은 수의 네트워크 자원을 요구하기 때문에 무엇을 보낼 것인지에 관한 내용을 네트워크에 말할 필요가 있다. 네트워크에 제공하는 일련의 정보를 `flowspec`이라고 한다.
- 특정한 서비스를 네트워크에 요구할 때, 네트워크는 그러한 서비스를 실질적으로 제공할 수 있는지를 결정할 필요가 있다. 이러한 결정 과정을 수락 제어라고 부른다.
- 네트워크 사용자들과 네트워크의 구성요소들이 서비스에 대한 요구들, flowspec 그리고 수락제어 결정과 같은 정보를 교환할 수 있는 기법이 필요하다. 이것을 `signalling`이라 한다. 그러나 이 단어는 여러 의미를 가지므로, 이러한 과정을 `자원 예약`이라 하고, 이것은 자원 예약 프로토콜을 사용함으로써 달성된다.
- 흐름과 요구가 기술되고 수락 제어 결정이 내려졌을 때, 네트워크 스위치와 라우터들은 흐름의 요구들에 부합할 필요가 있다. 이러한 요구들에 부합하는 주요한 부분은 패킷들이 스위치와 라우터 내에서 큐에 저장되어 전송을 위해 조정되는 방식을 유지하는 것이다. 이러한 과정이 `패킷 스케줄링`이다.

#### Flowspec
- Flowspec에는 두 개의 분리할 수 있는 부분들이 있다. 흐름의 트래픽 특징들을 묘사하는 부분(TSpec)과 네트워크로부터 요구되는 서비스를 묘사하는 부분(RSpec)이다.
- 대역폭은 지속적으로 변하는 양이다. 장기간의 평균적인 대역폭을 아는 것은 충분하지 않다. 만약 압축 비디오처럼 다양한 비트 속도 애플리케이션이라면 비트들은 때때로 평균 속도보다 빠르게 보내질 것이다. 그러면 데이터가 스위치에 도달하는 속도는 증가될 것이다. 이렇게 도달한 데이터는 링크에 보내지기 전에 큐에 있게 될 것이다. 이러한 조건이 오랫동안 지속되면 큐도 더욱 길어질 것이다. 적어도 데이터가 큐에 잇는 동안 목적지에 전달되는 것이 아니라 지연된다. 만약 패킷들이 너무 오랫동안 지연되면, 요구되었던 서비스는 제공되지 않을 것이다. 게다가 큐 길이가 길어지면 어떤 지점에서 버퍼 공간을 다 써버릴 것이고 패킷들은 폐기될 것이다. 
- 자원들의 대역폭이 시간의 흐름에 따라 어떻게 변하는 가에 대해 알필요가 있다. 자원들의 대역폭 특징을 묘사하는 한 방식에 `token bucket` 필터라는 것이 있다. 이 필터는 토큰의 속도(r)와 버킷의 깊이(B) 두 개의 요소에 의하여 묘사된다. 
- 바이트를 보내기 위해서는 토큰을 가지고 있어야만 한다. n 길이의 패킷을 보내기 위해서 n개의 토큰이 필요하다. 초기에 토큰이 없이 출발하여 초마다 r 속도로 토큰이 생성된다. 그리고 버킷에는 오직 B개의 토큰만 축적할 수 있다. 이것이 의미하는 것은 원하는 만큼 빠르게 네트워크에 한꺼번에 B바이트들을 보낼 수 있지만, 상당히 장기간에 걸쳐서 생각하면 초마다 r바이트 이상을 보낼 수 없다는 것이다. 이 정보는 서비스에 대한 새로운 요구를 수용할 수 있는지 파악하려고 할 때 수락 제어 동작에 유용하다.

#### 수락 제어
- 어떤 새 흐름이 특별한 서비스 수준을 제공받기를 원할 때, 수락 제어는 흐름의 TSpec과 RSpec을 살펴보고 이전에 허용된 흐름이 요구했던 서비스보다 나쁜 서비스를 받는 일이 없도록 하면서, 현재 유용한 자원들을 서비스가 보내는 트래픽 양에 할당할 수 있는지를 결정하는 것이다. 만약 새 흐름이 그러한 서비스를 수용할 수 있다면 흐름은 허용되고, 그렇지 않다면 거부된다.
- 수락 제어는 요구된 서비스의 형태와 라우터에 사용된 큐의 서비스 원칙에 매우 의존한다. 보장된 서비스에 있어서, 명확한 결정을 위해 좋은 연산법을 사용할 필요가 있다. 만약 각 라우터에 WFQ가 사용된다면 결정은 상당히 간단하다. 통제된 로드 서비스에 있어서, 결정은 이 클래스안에서 이러한 TSpec를 가진 흐름을 허용한 마지막 시기에 그 클래스에 대한 지연은 허용된 범위를 초과했다 그러나 거부하는 것이 낫다거나 현재 지연들은 범위 내에 있으므로 또 다른 흐름을 허용할 수 있다와 같은 발견적 방법에 기초를 둔다.
- 수락 제어는 감시와 혼동하면 안된다. 수락 제어는 새흐름을 수용할 것인지를 결정하는 것이다. 감시는 흐름이 예약에 사용되었던 TSpec에 일치 여부를 파악하기 위해 패킷 단위로 적용되는 기능이다. 만약 한 흐름이 그것의 TSpec에 일치하지 않는다면, 다른 흐름들에 제공되는 서비스를 방해할 것이다. 그러므로 이러한 흐름에는 어떤 수정 조치가 취해져야만 한다. 수정 조치를 위한 방법들은 다른 패킷들을 방해하는 것을 멈추게 하는 선택이 되어야 한다. 그러나 만약 패킷들이 다른 흐름들의 서비스를 방해한다면 다른 선택이 검토되어야 한다.

#### 예약 프로토콜
- 연결지향의 네트워크들이 스위치 내에 필요한 가상 회선을 설정하기 위해 어떤 형태의 설정 프로토콜이 필요한 반면에, 인터넷과 같은 비연결성 네트워크들은 어떤 프로토콜도 가지지 않는다. 그러나 실시간 서비스를 원한다면, 네트워크에 많은 정보를 제공해야 한다. 자원 예약 프로토콜(RSVP)는 연결지향적인 네트워크에 대한 관습적인 시그널링 프로토콜들과 근본적으로 다르다.
- RSVP에 잠재된 가정중 하나는 견고성을 손상시키지 않는다는 것이다. 비연경성 네트워크들이 네트워크 자체에 저장된 상태에 의존하지 않기 때문에, 종단 간 연결이 유지되는 동안에 라우터는 붕괴되었다가 재설정되고 링크의 대역폭을 변화시키는 것이 가능하다. RSVP는 라우터 내에 소프트 상태의 개념을 사용함으로써 이러한 견고함을 유지하려고 한다. 소프트 상태는 더이상 필요치 않은 때 정확하게 제거되지 않는다. 대신에 만약 정기적으로 갱신되지 않는 다면 얼마의 시간 후에 소멸된다.
- RSVP의 또 다른 특징은 단일 흐름만큼 효과적으로 멀티캐스트 흐름들을 지원하는 것을 목표로 하고 있다. 송신자들보다 더욱 많은 수신자들을 가지고 있다. 또한 수신자들은 다양한 요구를 가진다. 송신자들이 잠재적인 많은 수신자들을 쫓아가는 것보다 수신자들이 그들 요구를 쫓아가도록 허용하는 것이 더욱 의미있다. 이것은 RSVP에 의하여 채택된 `수신자 지향`의 접근법을 나타낸다. 대조적으로 연결지향의 네트워크들은 자원 예약이 송신자의 책임인데, 이것은 마치 송신자가 네트워크의 자원을 할당하도록 하는 것과 같다.
- RSVP의 소프트 상태와 수신자 지향의 특징은 좋은 이점을 가지고 있다. 하나의 이점은 수신자에게 제공되는 자원 할당의 수준을 증가시키거나 감소시키는 것이 매우 간단하다는 것이다. 각 수신자는 소프트 상태를 유지하기 위해 새로운 메시지들을 정기적으로 보내기 때문에, 새로운 자원을 요구하는 새 예약을 보내기가 쉽다. 호스트에 고장이 생길 경우, 그러한 호스트에 의하여 각 흐름에 할당되는 자원들은 자연스럽게 복구될 것이다.
- 수신자가 예약을 만들 수 있기 전에 일어나야 하는 두 가지 것이 있다. 첫 번째, 수신자는 송신자가 적당한 예약을 만들 수 있기 위해서 무슨 트래픽을 보낼 것인지를 알 필요가 있다. 말하자면 송신자의 TSpec을 알아야한다. 두 번째, 패킷들이 송신자에서부터 수신자에까지 어떤 경로를 따라가는 지를 알 필요가 있다. 따라서 그 경로에 있는 각 라우터에 자원 예약을 설정할 수 있다. 이러한 요구들 모두 송신자에서부터 수신자에까지 TSpec을 포함한 메시지를 보냄으로써 해결할 수 있다. 명백하게, 이 메시지는 수신자에게까지 TSpec을 전달한다. 발생할 또 다른 것은, 각 라우터는 메시지가 지나감에 따라 이 메시지(PATH 메시지)를 들여다본다는 것이다. 그리고 이것은 경로상에 있는 각 라우터에게 예약을 전달하기 위해서, 수신자로부터 송신자에게까지 예약을 하는 데 사용될 역경로를 알려준다.
- PATH 메시지를 받은 후에, 수신자는 RESV 메시지 내에 있는 멀티캐스트 트리를 따라 예약을 특정 방향으로 되돌려 보낸다. 이 메시지는 송신자의 TSpec과 수신자 요구들을 묘사하는 RSpec을 포함한다. 경로상의 라우터는 예약 요구를 보고 그것을 만족시키기 위해 필요한 자원들을 할당시키려고 노력한다. 만약 예약이 만들어질 수 있다면, RESV 요구는 다음 라우터에까지 나아가게 된다. 만약 예약이 만들어 질수 없다면, 에러 메시지가 요구를 보내는 송신자에게 되돌아 간다. 만약 모든 것이 잘 진행된다면, 정확한 예약이 송신자와 수신자 사이에 있는 모든 라우터에서 이루어진다. 수신자가 예약을 유지하기를 원하는 동안 특정 시간마다 RESV 메시지를 보낸다.
- 라우터나 링크가 잘못되었을 때, 라우팅 프로토콜은 실패에 적응하고 송신자로부터 수신자에게까지 새로운 경로를 생성할 수 있다. 경로 메시지는 일정 시간마다 반복해서 보내지고, 만약 라우터가 그것의 라우팅 테이블에서 변화가 발견되면 곧 보낸다. 그래서 새 라우터가 안정화된 후에 첫 번째 경로 메시지는 새 경로를 통해 수신자에게 도달될 것이다. 수신자의 다음 RESV 메시지는 새 경로를 따라서 새 경로에 새 예약을 설정할 것이다. 그리하여 더 이상 경로에 존재하지 않는 라우터는 RESV 메시지를 전달하는 것을 멈출 것이고, 이러한 예약들은 복구된다. 라우팅의 변화가 지나치게 빈번하지 않는 한, 토폴로지 안에서 RSVP는 경로 변화를 상당히 잘 처리할 수 있다.
- 그룹과 다수의 수신자에게 다수의 송신자가 보내는 경우가 있을 수 있다. 먼저 한 명의 송신자에 대한 다수의 수신자가 있는 경우를 다룬다. RESV 메시지가 멀티캐스트 트리를 따라 몇몇 다른 수신자들의 예약이 이미 설정되어 있는 트리의 한 부분을 거칠 것이다. 이것은 이 지점의 위쪽에 예약된 자원들이 양쪽 수신자들을 만족시키기에 적합한 경우다. 합병점의 아래에 있는 모든 수신자들의 요구를 부합시키기 위해 예약들은 합병될 수 있다.
- 만약 트리에 다양한 송신자들이 잇다면, 수신자들은 모든 송신자들로부터 TSpec을 모아서 모든 송신자들로부터 트래픽을 축적할 만큼 큰 예약을 만들어야 한다. 그러나 TSpec이 추가되어야 한다는 것을 의미하지는 않는다. 모든 송신자 TSpec으로부터 정확한 전체적인 TSpec을 계산하는 것은 애플리케이션의 특성에 따라 달라진다. RSVP는 다양한 선택을 하기 위해 다양한 예약 스타일을 가지고 있다.

#### 패킷 분류와 조정
- 패킷을 조정하는 과정의 첫 번째는 패킷 내에 있는 다섯 필드(시작 주소, 목적지 주소, 프로토콜 번호, 시작 포트, 목적지 포트)를 조사함에 의하여 이루어진다. 이 정보에 토대를 둔채, 패킷은 분류될 수 있다. 예를 들어 통제된 로드로 분류되거나, 다른 모든 흐름과 분리시켜서 다루어야 하는 하나의 보장된 흐름의 부분이 될 수도 있다. 간단히 말하면 패킷 헤더의 흐름 특징 정보로부터 패킷이 큐에서 어떻게 다루어지는지를 결정하는 하나의 분류 ID로 매핑하는 문제이다. 보장된 흐름들에 있어서 이것은 일대일 매핑이지만, 다른 서비스에 있어서는 다수 대 일의 매핑이 된다.
- 라우터의 FIFO 큐는 단순한 장점이 있지만 다양한 서비스와 각 서비스에서 요구하느 다양한 지연 수준을 지원하기에는 부적절하다.
- 패킷 스케줄링의 세부사항들은 서비스 모델에서 구체적으로 규정될 필요는 없다. 대신에 패킷 스케줄링의 세부사항들은 구현자들이 서비스 모델을 효과적으로 실현시키기 위한 작업에 속한다. 보장된 서비스 클래스에 있어서, 각 흐름은 종단 간 지연시간을 일정치 이하로 보장하는 WFQ 기법을 사용하는데, 이 기법은 각 흐름별로 별도의 큐를 마련하여 사용한다. 통제된 로드에 있어서는 더욱 간단한 방법이 사용된다. 통제된 로드 클래스에 허용된 모든 트래픽의 양을 하나의 흐름으로 취급하여 이 전체에 대해 가중치를 주어 취급하면 된다. 하나의 라우터에 많은 다양한 서비스들이 동시에 제공되고, 이러한 서비스들은 각각 다른 스케줄링 방법이 요구되는 경우에는 더욱 어렵게 된다. 따라서 다양한 서비스 간의 자원 할당을 처리하기 위하여 전체적인 큐관리 알고리즘도 필요하다.

#### 확장성 문제
- 통합 서비스 구조와 RSVP가 최대 노력 서비스 모델인 IP의 성능 향상에 큰 기여를 한 반면에, 많은 인터넷 서비스 제공자들은 이것이 사용하기에 적당한 모델이 아니라고 느꼈다. 이러한 이유 중의 하나는 IP의 기본적인 목표들 중 확장성과 연관이 있다.
- 최대 노력 서비스 모델에 있어서, 인터넷 내의 라우터는 그들을 통해 지나가는 각각의 흐름들에 관한 상태를 거의 저장하지 않는다. 인터넷이 성장함에 따라, 라우터가 그러한 성장과 일치하기 위하여 해야 할 것은 초마다 더욱 많은 비트를 옮기는 더욱 큰 라우팅 테이블을 다루는 것이다. 그러나 RSVP는 라우터를 통해 지나가는 모든 흐름에 대해 예약 정보를 관리해야 한다. 
- 이러한 예약들 각각은 메모리에서 때때로 읽어야 하는 어떤 상태 정보가 필요하다. 라우터는 각각의 흐름에 대해 패킷을 분류하고 감시하고 저장해야한다. 수락 제어 결정은 그러한 흐름이 예약을 요구할 때마다 행해져야 한다. 오랜 시간동안 한 흐름이 큰 예약을 독점하지 않도록 하기 위해 예약한 자원을 반환시킬 어떤 방법들이 필요하다.

### 차별화된 서비스
- 통합 서비스 구조가 개개의 흐름에 자원들을 할당하는 반면에, 차별화된 서비스는 트래픽 클래스의 그룹 단위로 자원들을 할당한다. 차별화된 서비스의 어떤 제안된 접근법은 단지 트래픽을 두가지 분류로 나눈다. 
- IETF의 차별화된 서비스를 운용하는 그룹은 표시된 패킷들에 적용되는 라우터의 행위들을 표준화시켰다. 이러한 행위들은 `PHB`이라고 한다. 이것은 종단 간 서비스보다 개개의 라우터들이 행위를 규정하는 것을 나타낸다. 하나 이상의 새로운 행위 때문에, 어떤 행위를 적용할 것인지를 라우터들에게 말하기 위해 패킷 헤더에 1비트보다 더욱 많은 비트에 대한 욕구가 있다. IETF는 IP 헤더 중에서 사용되지 않은 TOS 바이트를 사용하기로 결심하고 그것을 다시 규정하였다. 이 바이트 중 6비트를 `DSCP`라 한다. 각 DSCP는 한 패킷에 적용되는 특정한 PHB를 식별하는 6비트 값이다.

#### EF PHB
- 간단한 PHB 중 하나는 `EF`이다. EF로 표시된 패킷들은 라우터에 의하여 최소한의 지연과 손실을 가지도록 취급된다. 라우터가 모든 EF 패킷들에 대해 이것을 보장할 수 있는 유일한 방식은 라우터에 EF 패킷들의 도착 속도가 라우터가 EF 패킷들을 처리할 수 있는 속도보다 적은 속도로 엄격히 제한되어야 한다. 그렇게 해야 때때로 routing update와 같은 제어 패킷들을 보낼 시간을 가질 수 있다.
- EF 패킷들의 속도 제한은 관리 지역의 경계에 있는 라우터들이 그 지역 내에 유입되는 EF 패킷의 허용치를 규정함으로써 달성된다. 비록 보수적이지만 단순한 접근법은 그지역에 들어가는 모든 EF 패킷들의 속도 합계가 그 지역내에 있는 가장 느린 링크의 대역폭보다 적다는 것을 지키면 가능하다. 모든 EF 패킷들이 가장 느린 링크에 모여드는 최악의 경우에도, 이러한 접근법은 패킷이 과잉 적재되지 않고 정확한 서비스를 제공할 수 있다는 것을 확신시켜 줄 것이다.
- EF에 대한 구현 전략이 있다. 하나는 EF 패킷들에게는 모든 다른 패킷들에 비해 확실히 우선권을 주는 것이다 .또 다른 방법은 WFQ를 사용하고 모든 EF 패킷들에게는 빨리 전송될 수 있도록 높은 비중을 두는 방법이다. 이것은 우선권을 엄격히 적용하는 것보다 이점을 가지고 있다. 비록 EF 패킷 트래픽이 초과될지라도, 이들은 비 EF패킷들과 같이 취급될 수 있다. 이것은 EF 패킷들이 구체적인 서비스를 명확하게 얻을 수 없다는 것을 의미하고, EF 트래픽의 초과된 load의 경우에 트래픽이 폐기하는 것을 막을 수 있다는 것을 의미한다.

#### AF PHB
- AF는 IN/OUT을 가진 RED(RIO)나 가중된 RED로 알려진 방법에 근원을 두고 있다. 이 방법은 기본적은 RED 알고리즘을 개선한 것이다.
- 평균적인 큐의 길이가 아주 낮은 경우에는 OUT으로 표시된 패킷들만 RED 알고리즘에 의해 버려진다. 만약 정체가 더욱 심해진다면, OUT 패킷의 폐기율이 더욱 높아진다. 그리고 만약 평균 큐 길이가 Min(IN)을 초과한다면, IN 패킷도 폐기하기 시작한다.
- 패킷의 두 가지 분류를 IN/OUT이라 부르는 이유는 패킷들이 표시되는 방식으로부터 유래된다. 패킷의 이런 표시를 관리구역 경계에 있는 라우터에 의하여 수행될 수 있다. 이 라우터가 네트워크 서비스 제공자와 그 네트워크 고객 사이의 경계지역에 있는 것으로 생각할 수 있다. 경계 라우터는 고객으로부터 도달하는 패킷들을 프로필의 IN/OUT으로 정확하게 표시할 수 있다. 고객이 보장하는 속도보다 낮게 보내는 동안 모든 패킷들은 IN으로 표시하고 이것을 초과한다면 OUT으로 표시된다.
- 경계점에 있는 profile meter와 서비스 제공자 네트워크의 모든 라우터 내에 있는 RIO 기능의 결합은 프로필 내에 있는 패킷들은 확실히 전달될 수 있다는 확신을 준다. 특히, 프로필을 설정하여 비용을 지불하지 않은 고객들이 보낸 패킷들은 OUT 패킷이되고 RIO 메커니즘은 IN 패킷들이 거의 폐기되지 않을 만큼 충분히 낮게 혼잡상태를 유지하는 경우가 된다. 분명히, RIO 알고리즘은 IN 패킷을 폐기시키는 정도로 링크에 혼잡이 오지 않을 만큼 네트워크에 충분한 대역폭이 있는 경우이다.
- RED처럼 RIO 같은 메커니즘의 효율성은 어느 정도 매개변수의 정확한 선택이 달려 있고, RIO를 위해 설정해야 할 매개변수가 상당히 있다.
- RIO의 한가지 흥미 있는 속성은 IN과 OUT 패킷들의 전달 순서가 바뀌지 않는다는 것이다. 예를 들면, TCP 연결이 profile meter를 통해 패킷들을 보내어 몇몇 패킷들이 IN으로 표시되는 반면 다른 패킷들은 OUT으로 표시된다면, 그러한 패킷들은 라우터의 큐에서 다양한 폐기 확률을 받을 것이다. 그러나 그들은 보내졌던 것과 똑같은 순서로 수신자에게 전달될 것이다. 이것은 TCP 구현에서 매우 중요한 점이다. 비록 그들이 무질서에 대처하도록 고안되었다 할지라도, 패킷들이 질서정연하게 도달하는 것은 아주 중요하다. 빠른 재전송과 같은 알고리즘들은 무질서가 일어났을 때, 그릇되게 반응할 수 있다는 것을 주목하라.
- RIO의 개념은 두 가지 이상의 폐기 가능성 곡선을 제공하는 것을 보편화시킬 수 있고, Weighted RED(WRED)로 알려진 접근법 뒤에 숨겨진 개념이다. 이 경우에, DSCP 필드의 값은 몇몇 폐기 가능성 곡선들 중에서 하나를 선택하는 데에 사용된다. 그래서 여러 가지 다양한 서비스들이 제공될 수 있다.
- 차별화된 서비스를 제공하기 위한 세번째 방식은 WFQ 스케줄러가 패킷을 어떤 큐에 넣을지를 결정하기위해 DSCP 값을 사용하는 것이다. 매우 단순한 경우로서, 한 DSCP 값은 최대 노력 모델의 큐를 나타내기 위해 사용하고, 두 번째 DSCP 값은 프리미엄의 큐를 선택하기 위해 사용한다. 프리미엄 패킷들이 최대 노력 패킷들 보다 더운 나은 서비스를 받기 위해 프리미엄 큐에 대한 비중을 높일 필요가 있다. 이것은 제공된 부하에서 프리미엄 패킷들이 차지하는 비율에 의존한다. 예를 들어 프리미엄 큐에 가중치 1을 주고 최대 노력 큐에 가중치 4를 준다면 프리미엄 패킷들에 유용한 대역폭은 `프리미엄 B = 프리미엄 W / 프리미엄 W + 최대노력 W` = 1/(1+4) = 0.2 이다.
- 말하자면, 링크 대역폭의 20%를 프리미엄 패킷들을 위해 예약하고 있다. 따라서, 프리미엄 트래픽의 제공된 부하가 평균적으로 링크 대역의 10%라면, 프리미엄 트래픽은 매우 가벼운 네트워크 부하에서 동작하는 것처럼 동작할 것이다. 서비스 품질은 매우 좋을 것이다. 특히 WFQ는 프리미엄 패킷들이 도착하자마자 전송하려고 시도하므로, 프리미엄 범주의 트래픽이 겪게 되는 지연은 낮게 유지될 수 있다. 한편, 프리미엄 트래픽의 부하가 30%라면, 매우 과부하된 네트워크 처럼 동작할 것이다. 소위 최대 노력 패킷들보다 더욱 높은 지연이 프리미엄 패킷에 일어날 수 있다. 그래서 제공된 부하의 수준을 인지하고 조심스럽게 가중치를 설정하는 것이 이러한 서비스에서 중요하다. 그러나 안전한 접근법은 프리미엄 큐의 가중치를 설정함에 있어 매우 보수적으로 접근하라는 점이다. 만약 이 가중치가 예상되었던 부하에 비해 매우 높게 설정되었다면, 그것은 상당한 오류를 발생시키고, 프리미엄으로 예약되었지만 프리미엄 패킷들에 의하여 사용되지 않는 대역폭을 최대 노력 트래픽이 사용하는 것을 막지 않는다.
- WRED에서처럼, 두 가지 이상의 범주를 다양한 DSCP로 나타내기 위해, WFQ에 기반을 둔 접근법을 일반화시킬 수 있다. 더욱이, 큐 선택자의 개념을 폐기 정책과 결합시켜 생각할 수 있다. 예를 들어, 12개 DSCP와 다양한 가중치를 가진 4개의 큐를 가질 수 있다. 그 큐는 각각의 폐기 정책을 가지고 있다. 이것이 IETF가 AF 서비스에 적용하는 개념이다.

### 방정식 기반 혼잡 제어
- TCP는 ACK와 타임아웃 이벤트에 반응하여 송신자의 CongestionWindow를 조정한다. 이러한 접근법의 강점은 네트워크 라우터들로부터의 도움을 필요로 하지 않는다는 것이다. 이 방법은 전적으로 호스트 기반 정책이다. 이러한 정책이 QoS 메커니즘을 보완할 수 있는데, 그 이유는 첫째 QoS 메커니즘이 널리 사용되기 전에 현재의 애플리케이션들이 호스트 기반의 솔루션을 이용할 수 있기 때문이고, 둘째 DiffServ가 완전히 보급되었다 하더라도 라우트 큐들이 과잉 예약되면 실시간 애플리케이션들이 그에 합당한 반응을 보이도록 할 수 있기 때문이다.
- TCP의 혼잡 제어 장점을 받아들이고 싶지만, TCP는 신뢰성 프로토콜이라서, 실시간 애플리케이션은 재전송으로 야기되는 지연을 감당할 수 없다. 하지만 UDP와 같은 신뢰성이 없는 프로토콜에 TCP와 비슷한 혼잡 제어 기능을 가미할수 있다. 이것은 `UDP 1CC`이다.
- 이것은 실시간 스트림과 TCP 스트림 간에 공평한 경쟁을 유발시키기 때문이다. 반대로 UDP를 이용하고 있는 비디오 애플리케이션들은 아무런 혼잡 제어도 사용하고 있지 않으며, 그 결과로 혼잡으로 정체되고 있는 TCP의 대역폭을 강점하게 된다. 이에 반해서 TCP의 혼잡 제어 알고리즘은 실시간 애플리케이션에 부적합하다. 이 의미는 애플리케이션의 송신율은 지속적으로 올라갔다 내려갔다를 반복한다는 것이다. 이와 대조적으로 실시간 애플리케이션은 장시간 동안 기복이 없는 전송을 유지할 때 가장 잘 작동하게 된다.
- 두 곳에서 장점을 뽑기 위해서 TCP-우호적인 혼잡 제어 알고리즘들이 제안되었다. 이런 알고리즘들은 두 가지 목표가 있다. 하나는 Congestion Window를 천천히 작동시키는 것이다. 이것은 각각의 패킷을 기준으로 삼는 것보다는 상대적으로 긴 시간 동안 행해지면서 적응되도록 한다. 이와 같은 방법은 전송을 기복이 없게 만들어 준다. 두 번째 목표는 TCP에 우호적이도록 하는 것인데, TCP 흐름들과의 공평한 경쟁을 의미한다. 이런 속성은 TCP의 움직임을 모델링한 방정식을 따르도록 함으로써 전송 흐름들을 제어한다. 그렇기 때문에 이러한 접근법은 때때로 `방정식 기반 혼잡 제어`라 한다.
- 이 방정식은 TCP에 우호적이기 위해서는 전송률이 왕복시간(RTT)과 손실률(p)의 제곱근에 반비례하여야 한다는 것이다. 이것에 바탕으로 혼잡 제어를 구현하고자 한다면, 수신자는 송신자에게 정기적으로 손실률을 통보해야만 한다. 그러면 송신자는 이러한 방정식과 같은 관계를 유지하기 위해서 송신률을 올리거나 내리도록 조치를 취하게 된다. 당연히 유효 속도의 변화에 대처해야 하는 것은 애플리케이션의 몫이다.
