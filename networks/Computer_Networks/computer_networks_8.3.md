# 네트워크 보안

## 인증 프로토콜
- 프로토콜의 보안을 위하여 모든 메시지에 인증인자를 추가하고 기밀성을 위하여 메시지를 암호화하는 것이 해야할 모든 일인 것 처럼 보일 수 있다.
- 그러나 문제가 간단하지 않은 두 가지 이유가 있다. 첫째, 재생 공격 문제이다. 재생 공격이란 적대자가 이전에 이미 전송되었던 메시지의 사본을 다시 전송하는 것이다. 이는 원본 메시지가 정당하게 다시 생성된 것은 아니지만 메시지가 생성된 후 그 내용이 변경된 것은 아니므로 그것의 인증인자는 여전히 유효하다. 이런 공격의 변종으로 지연재생 공격이 있다. 이 공격은 적대자가 단지 메시지를 중간에 가로채서 나중에 응답하는 방식으로 지연시켜서 그 응답이 적절하지 않은 시간에 도착하도록 하는 공격이다. 이 메시지는 일견 원본처럼 보이지만 적시에 도착한 것은 아니다. 원본성과 적시성은 무결성의 한 측면이다. 이를 보장하기 위하여 대부분의 경우 꽤 복잡한 전후방 프로토콜이 필요하다.
- 또 다른 문제는 세션 키를 어떻게 설정하는가이다. 세션 키는 즉시 생성하여 하나의 세션에만 사용되는 대칭 키 암호방식의 키이다. 여기에도 복잡한 프로토콜이 요구된다.
- 이 두 문제가 공통적으로 가지고 있는 것이 인증이다. 일반적으로 인증 프로토콜은 인증과 동시에 세션 키도 생성된다. 이 프로토콜은 서로를 인증하고, 사용할 새로운 대칭 키를 설정함으로써 종료한다. 프로토콜은 특정 시점에는 새로운 세션 키 없이 각각에 통신자에 대한 인증만을 수행하고, 세션 키는 그들이 추후에 교환할 메시지를 인증하는 데 사용된다. 일반적으로 세션 키 설정 프로토콜은 인증을 수행한다.

### 원본성과 적시성 기술
- 인증인자만으로는 원본이 아니거나 적시에 도착하지 않은 메시지를 검출하지 못한다. 한 가지 해결방안은 메시지에 타임스탬프를 포함하는 방안이다. 타임스탬프 자체가 변경되지 않았다고 증명되어야 하는 대상이므로 이것도 인증인자에 의해 보호되어야 한다. 타임스탬프 방식의 단점은 분산 시계 동기화를 필요로 한다는 것이다. 시스템들이 동기화에 의존하고 있으므로 시계 동기화 자체가 보안 상의 위협으로부터 보호되어야 한다. 이는 일반적인 시계 동기화 문제에 부가적으로 요구되는 기능이다. 다른 문제는 분산된 시계들은 일정한 수준으로만, 일정한 오차의 한계가 있는 수준으로만 동기화된다는 것이다. 따라서 타임스탬프 방식에 의한 시간 무결성은 오직 동기화의 수준으로만 제공될 수 있다.
- 다른 방안에서는 nonce(한 번만 사용되는 무작위 수)를 메시지에 포함시킨다. 참여자는 nonce가 이전에 사용된 적이 있는지를 검사하여 재생 공격을 탐지할 수 있다. 이 방식에서는 과거 nonce의 기록을 유지해야하고, 너무 많은 기록이 축적될 수도 있다. 하나의 해결책은 타임스탬프와 nonce를 조합하여 nonce가 일정한 기간 동안에만 유일성이 보장되도록 하는 것이다. 이 기법은 낮은 수준의 시계 동기화를 요구하므로 nonce의 유일성에 대한 보장을 관리 가능한 수준으로 만들어 준다.
- 타임스탬프와 nonce의 단점에 대한 다른 해법은 그들 모두나 그중 하나를 응답 요청 프로토콜에서 사용하는 것이다. 타임스탬프를 사용한다고 할 때, 응답 요청 프로토콜에서 alice는 bob에게 타임스탬프를 보내면서 bob에게 이 타임스탬프를 암호화하여 응답 메시지로 보내거나, 이 타임스탬프를 디지털로 서명하여 응답 메시지로 보내라고 요청한다. 암호화된 타임스탬프는 인증인자와 유사하고, 부가적으로 적시성도 검증할 수 있다. alice는 bob으로부터의 응답에 포함된 타임스탬프의 적시성을 쉽게 검증할 수 있다. 이 타임스탬프ㅌ는 alice 자신의 시계로부터 나온 것이므로 분산 시계 동기화는 필요하지 않다. 이 대신 nonce를 사용 한다고 하면, alice는 응답이 아직 도착하지 않은 nonce에 대한 기록만을 관리하면 된다. 응답을 기다리고 있는 시간은 그리 길지 않으며, 인식하지 못할 nonce를 가지고 응답이라고 하는 것은 모두 가짜이다.
- 응답 요청의 매력은 이것 없이는 복잡하게 되었을 문제를 해결한 것 외에도 적시성과 인증을 결합했다는 것이다. 결국 이전에 본적이 없는 타임스탬프나 nonce를 암호화하는 데 필요한 키는 오직 bob만이 알고있다(대칭 키의 경우 alice 포함).

### 공개 키 인증 프로토콜
- 앞으로의 두 프로토콜은 PKI와 같은 기법을 사용하여 alice와 bob의 공개 키가 상호간에 사전분배되었다고 가정한다. 여기에는 alice가 bob에게 보내는 첫 메시지에 인증서를 포함하여 보내는 경우와 bob이 alice의 첫 메시지를 받고 나서 alice에 대한 인증서를 검색하는 경우도 포함된다.
- 첫 번째 프로토콜은 alice와 bob의 시계가 동기화되는 것에 기반을 두고 있다. alice는 bob에게 평문으로 된 타임스탬프와 자신의 본인 증명과 자신의 디지털 서명이 포함된 메시지를 보낸다. bob은 이 디지털 서명을 이용하여 메시지를 인증하고 타임스탬프를 이용하여 이 메시지가 새로운 것인지를 검증한다. bob은 평문으로 된 타임스탬프와 본인 증명, 그리고 기밀성을 위하여 alice의 공개 키를 이용하여 암호화한 새로운 세션 키를 포함하는 메시지를 만들고 이 메시지 전체에 디지털 서명을 한 후 alice에게 다시 보낸다. alice는 메시지의 인증과 이 메시지가 새로운 것인지를 검사하여 새로운 세션 키가 신뢰할 수 있는 것인지를 판단한다. 불완전한 시계 동기화 문제를 처리하기 위하여 타임스탬프는 nonce와 함께 사용되기도 한다.
- 두 번째  프로토콜은 유사하기는 하지만 시계 동기화에 기반을 두고 있지 않다. 이 프로토콜에서도 alice는 자신의 본인 증명을 포함하는 디지털 서명된 메시지를 bob에게 보낸다. 그들의 시계가 동기화되어 있지 않으므로 bob은 메시지가 새로운 것인지를 확신하지 못한다. bob은 alice의 원래 타임스탬프, 그리고 자신의 새로운 타임스탬프, 그의 본인 증명을 포함하는 디지털 서명된 메시지를 돌려 보내 준다. alice는 자신의 현재 시간과 자신이 보낸 메시지에서 유래된 타임스탬프를 비교하여 bob의 응답이 새로운 것인지를 검증할 수 있다. alice는 다시 bob의 타임스탬프와 bob의 공개 키를 사용하여 암호화한 새로운 세션 키를 포함하는 디지털 서명된 메시지를 bob에게 보낸다. 이제 bob은 타임스탬프가 자신의 시계에서 유래되었으므로 메시지가 새로운 것임을 검증할 수 있고, 새로운 세션 키도 신뢰할 수 있다는 것을 알게 된다. 타임스탬프는 자체가 근본적으로 편리한 nonce이지만 이 프로토콜에서는 nonce를 별도로 사용하고 있다.

### 대칭 키 인증 프로토콜
- 상대적으로 작인 시스템에서만 각 개체의 쌍에 대응하는 대칭 키를 사전분배하는 것이 가능하다. 그러나 대규모 시스템의 경우를 생각해보면, 이 시스템에서는 오직 KDC와 공유하는 마스터 키만을 보유한다. 이 경우 대칭 키 기반 인증 프로토콜에는 alice, bob, KDC가 관여한다. 인증 프로토콜의 최종 결과물은 KDC의 관여 없이 alice와 bob이 직접 통신하는 데 사용하기 위하여 양자가 공유하는 세션 키이다.
- Needham-Schroeder 인증 프로토콜에서는 KDC는 alice의 첫 메시지를 인증하지 않으며 bob과는 전혀 통신하지 않는다. 그 대신 KDC는 alice와 bob의 마스터 키에 대한 정보를 이용하여 응답 메시지를 만들어, 이 메시지가 alice가 아닌 사람에게는 해독할 수 없도록 한다. 이 메시지에는 alice와 bob이 스스로 인증 프로토콜의 나머지 부분을 수행하는 데 필요한 정보를 포함하고 있다.
- 처음의 두 메시지에 들어 있는 nonce는 KDC의 응답이 새로운 것인지를 검증하는 데 사용된다. 두 번째와 세 번째 메시지에는 새로운 세션 키와 alice의 신원이 bob의 마스터 키로 암호화되어 포함된다. 이는 공개 키 인증서의 대칭 키 버전의 일종이다. 실제로 이것은 KDC에 의해 서명된 문장으로 '이 세션 키는 alice와 bob이 소유한다'라는 내용이 들어 있다. 마지막 두 개의 메시지에 포함된 nonce는 bob이 세 번째 메시지가 새로운 메시지인지를 검증하려는 의도였지만 이 논리에는 허점이 있다.

#### Kerberos
- 이 시스템은 Needham-Schroeder 인증 프로토콜을 기반으로 하는 인증 시스템으로 클라이언트-서버 환경에 특화된 시스템이다.
- Kerberos의 클라이언트는 인간 사용자이며 사용자들은 패스워트에 의해 인증된다. KDC와 공유되는 alice의 마스터 키는 그녀의 패스워드로부터 도출된다. 따라서 패스워드를 알면 키를 계산해 낼 수 있다. Kerberos에서는 누구나 물리적으로 클라이언트 기계에 접근할 수 있다고 가정한다. 따라서 alice의 패스워드나 마스터 키가 네트워크뿐 아니라 로그인한 어떤 시스템에도 노출되는 시간을 최소화하는 것이 아주 중요하다. Kerberos는 이를 수행하기 위하여  Needham-Schroeder의 도움을 받는다.  Needham-Schroeder에서 alice가 패스워드를 사용하는 시간은 KDC로부터 온 메시지를 해독할 때뿐이다. Kerberos의 클라이언트 쪽 소프트웨어는 KDC의 응답이 도착할 때까지 기다렸다가 alice에게 패스워드를 입력하라고 요청한다. 패스워드로 마스터 키를 계산하고 KDC의 응답을 해독한 다음 패스워드와 마스터 키에 관한 모든 정보를 바로 삭제하여 노출을 최소화한다. 사용자가 볼 수 있는 Kerberos의 유일한 흔적은 사용자가 패스워드를 입력하라고 요청하는 동안뿐이다.
- Needham-Schroeder에서 alice에게 보낸 KDC의 응답은 두 가지 역할을 한다. alice에게 그녀의 신원을 검증하는 수단을 제공하고(alice만이 이 응답을 해독할 수 있다), 그녀에게 bob에게 제시할 수 있는 일종의 대칭 키 인증서 혹은 '티켓'을 제공한다. 여기에는 bob의 마스터 키로 암호화된 세션 키와 alice의 신원이 포함되어 있다. Kerberos에서는 이 두 가지 기능이 분리되어 있다. 신뢰성 있는 서버를 인증 서버(AS)라 하고, 이 서버는 alice에게 그녀의 신원을 검증하기 위하여 사용하는 정보를 제공하는 첫 번째 역할을 수행한다. 두 번째 신뢰할 수 있는 서버는 티켓 제공 서버(TGS)이다. TGS는 KDC의 두 번째 역할을 담당하는데, bob에게 제시할 티켓을 alice에게 응답해 준다. 이 기법의 매력은 alice가 bob뿐만 아니라 여러 개의 서버와 통신해야할 필요가 있는 경우 다시 AS로 돌아가지 않고 TGS에서 각 서버를 위한 티켓들을 얻을 수 있다는 점이다.
- Kerberos를 고려한 클라이언트-서버 애플리케이션 도메인에서 시계 동기화의 수준을 가정하는 것은 자연스러운 것이다. 이 가정이 Kerberos가 Needham-Schroeder의 nonce 대신에 타임스탬프나 유효기간을 사용하도록 허용하고 Needham-Schroeder의 보안 약점을 제거해 준다. Kerberos는 SHA-1과 MD5와 같은 해시 그리고 AES, 3DES, DES와 같은 대칭 키 암호기법을 포함한 다양한 암호작성 알고리즘 선택을 지원한다.

### Diffie-Hellman 키 합의
- Diffie-Hellman 키 합의 프로토콜은 사전분배 키 없이 세션 키를 설정해 준다. alice와 bob 사이에서 교환되는 메시지는 도청이 가능한 사람에게 노출될 수는 있으나 도청자가 alice와 bob사이에 설정이 완료된 세션 키는 알 수는 없다. 반면에 Diffie-Hellman은 참여자를 인증해 주지는 않는다. 누구와 통신하고 있는지에 대한 보장 없이 안전하게 통신하는 경우는 거의 없으므로 일반적으로 Diffie-Hellman은 인증을 제공하는 다른 기법과 함께 사용된다.
- 프로토콜은 p와 q 두 개의 매개변수를 가진다. 이들은 공개되어 있으며 특정 시스템 내의 모든 사용자가 사용한다. 매개변수 p는 반드시 소수(prime number)여야 한다. x mon p는 x를 p로 나눈 나머지를 의미하므로 mod p는 0 에서 p-1 사이의 값을 가진다. 이는 곱셉에 대한 그룹을 형성한다. 매개변수 g(generator)는 반드시 p의 `primitive root`이어야 한다. primitive root란 1에서 p-1사이의 모든 수 n에 대하여 `n=g^k mod p`가 되는 임의의 수가 k가 존재해야 하는 것을 말한다. 
- 예를 들어 p가 소수인 5이면 g가 2가 될 수 있다. `1=2^0 mod p, 2=2^1 mod p, 3=2^2 mod p, 4=2^3 mod p`이기 때문이다.
- alice와 bob이 공유 대칭 키를 사용하기로 했다고 하면, alice, bob 그리고 다른 모두가 p와 q 값을 이미 알고 있다. alice는 임의의 개인 값 a를 생성하고 bob은 임의의 개인 값 b를 생성한다. a와 b 모두 (1 - (p-1)) 정수의 집합에서 도출된다. alice의 공개 값은 `g^a mod p`로 계산하고, bob의 공개 값은 `g^b mod p`으로 계산한다. 그리고 그들은 자신들의 공개 값을 교환한다. 그리고 alice는 `g^ab mod p = (g^b mod p)^a mod p`를 계산한다. 또한, bob은 `g^ba mod p = (g^a mod p)^b mod p`를 계산한다. 이제 alice와 bob은 그들의 공유 대칭 키로서 `g^ab mod p`값을 가진다.
- 도청자도 p와 q 그리고 두 개의 공개 값 g^a mod p와 g^b mod p 값을 알 수 있다. 그러나 도청자가 a와 b값을 유추해야만 결과적으로 키를 계산해 낼 수 있다. 그러나 이 정보에서 a와 b를 도출하는 것이 충분히 큰 수의 p, a, b에 대해서는 계산상 불가능하다. 이 문제는 이산 로그 문제로 알려져 있다.
- 한편 Diffie-Hellman에는 인증이 결여되어 있다. 이 단점을 이용한 공격이 `중간자 공격`이다. melle가 메시지를 가로챌 수 있는 적대자라 하면 melle는 p와 q가 공개되어 있으므로 이들 값을 알고 있다. 그리고 melle는 alice와 bob이 각각 사용할 무작위 개인 값 c와 d를 생성할 수 있다. alice와 bob이 그들의 공개 값을 상대방에게 전달할 때, melle는 이를 가로채어 자신의 공개 값을 대신 보낸다. 그 결과 alice와 bob은 그들의 값 대신 melle와 키를 공유하게 된다는 사실을 알아채지 못한다.
- 고정 Diffie-Hellman이라 불리는 Diffie-Hellman의 다른 변종은 한 참여자나 혹은 양 참여자의 인증을 지원한다. 이는 공개 키 인증서와 유사한 인증서에 기반을 두고 있으나 공개 키 대신에 개체의 Diffie-Hellman 공개 매개변수를 사용한다. 예를 들어, 인증서에는 alice의 Diffie-Hellman 매개변수들은 p, q와 g^a mod p라고 정의되어 있다(a는 alice만 알고 있다). 이런 인증서는 bob에게 Diffie-Hellman의 상대 참여자가 alice라는 것을 확신시켜 준다. 다른 참여자는 a값을 알지 못하므로 비밀 키를 계산할 수 없다. 양 참여자가 Diffie-Hellman 매개변수에 대응하는 인증서를 가지고 있다면 양자는 서로를 인증할 수 있다. 한쪽만 인증서를 가진 경우에는 한쪽만 인증될 수 있다. 이는 특정한 상황에서 유용하다. 예를 들면, 한쪽이 웹 서버이고 다른 쪽이 임의의 클라이언트라면 클라이언트는 웹 서버를 인증하고 기밀성을 위하여 세션 키를 설정한 다음에 그 웹 서버로 메시지를 전달하는 경우이다.
