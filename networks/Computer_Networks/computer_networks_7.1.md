# 종단 간 데이터

## 프리젠테이션 형식화
- 애플리케이션 프로그램이 사용하는 형태에서 네트워크로 전송하는 데 적합한 형태로, 또는 그 역방향으로 바꾸는 것을 `프리젠테이션 형식화`라고 한다. 송신 프로그램은 전송 데이터를 내부 사용 형식으로부터 네트워크로 전송 가능한 형태의 메시지로 바꾼다. 즉, 데이터를 메시지로 `인코드`하는 것이다. 수신 측에서는 이렇게 도착하는 메시지를 애플리케이션이 처리할 수 있는 형식으로 바꾼다. 즉, 메시지를 `디코드`하는 것이다. 인코딩은 종종 `인자 마셜링`이라고 하며, 디코딩은 `언마셜링`이라 한다. 이 용어는 RPC에서 온 것인데, 클라이언트는 자신이 일련의 인자를 가지고 프로시저를 실행한다고 생각하지만, 이런 인자들은 네트워크 메시지를 형성하도록 적절하고도 효과적인 방법으로 합쳐지고 정렬되는 것이다.
- 컴퓨터마다 데이터를 다른 방식으로 표현한다. 예를 들어, 어떤 컴퓨터는 부동 소수를 IEEE 표준 754 포맷으로 나타내는 반면, 다른 컴퓨터는 고유의 비표준 포맷을 사용할 수 있다. 정소와 같이 단순한 것에서도 상이한 구조에서는 다른 크기를 사용한다. 또한 `big-endian`과 `little-endian` 문제도 있다. 또한 애플리케이션 프로그램이 상이한 언어로 쓰이며, 비록 한가지 언어를 사용해도 하나 이상의 컴파일러가 사용될 수 있다. 예를 들면, 컴파일러가 구조체를 구성할 때 필드 사이에 얼마만큼 패딩을 넣는가 등의 자신들이 메모리에 구조체를 늘어놓는 방식에서도 차이가 있다.

### 분류법

#### 데이터 유형
- 일반적으로는 인코딩 과정이 지원하는 데이터 종류를 세 가지 계층으로 분류할 수 있다.
- 가장 낮은 계층에서 인코딩 시스템은 몇 종류의 `기본유형(base type)`을 지원하는데, 일반적으로 기본 유형에는 정수, 부동 소수점, 문자가 포함된다. 이 시스템은 또한 `서수적 표현(ordinal types)` 형태와 불리언 형태도 지원한다. 기본 유형이 있다는 의미는 인코딩 과정에서 각각의 기본 유형을 한 표현 방식에서 다른 표현 방식으로 변환할 수 있어야 한다는 것이다.
- 다음 계층은 `플랫타입(flat type)`으로 구조체와 배열이 있다. 문제는 애플리케이션 프로그램을 컴파일할 때 사용되는 컴파일러가 필드들을 워드의 경계에 정렬되도록 하기 위해 때때로 구조체를 이루는 필드 사이에 패딩을 끼워 넣는다는 것이다. 인코딩 시스템은 일반적으로 구조체를 패킹하여 패딩이 없도록 만든다.
- 가장 높은 계층에서, 인코딩 시스템은 `복합유형(포인터를 사용한 타입)`을 다루어야 할 수도 있다. 즉, 한 프로그램이 보내려는 자료구조체가 한 가지 구조체에만 담겨 있지 않을 수 있으며, 대신에 한 구조체로부터 다른 것으로 향하는 포인터를 포함할 수도 있다는 것이다. 데이터 인코더는 반드시 네트워크를 통해 데이터 전송을 위한 자료 구조를 미리 준비해 두어야 한다. 그 이유는 포인터가 메모리 주소로 표현이 되며, 이전의 기계 상에 있던 구조체의 메모리 값이 다른 기계로 옮겨졌을 때도 이전의 기계와 동일한 메모리 주소 상에 위치하는 것은 아니기 때문이다.
- 데이터 타입 시스템이 얼마나 복잡한가에 따라, 인코딩 작업은 대개 기본 유형의 변환, 구조체 정돈, 복잡 자료구조의 선형화를 포함하게 되며, 이 모든 것은 네트워크 상으로 전송 가능한 일련의 메시지를 만들어 내기 위한 것이다.

#### 변환 전략
- 일단 타입 시스템이 확립되면, 다음 문제는 인코딩이 어떤 변환 전략을 사용할 것인가에 대한 문제를 해결해야 한다. `규범적 중재 유형`과 `수신 측 교정 방식`이라는 두 가지 옵션이 있다.
- 규범적 중재 유형의 개념은 각 유형에 대한 외부 표현 방식을 정해 놓는 것이다. 송신 호스트는 데이터를 보내기 전에 자체 내부 표현 방식을 이 외부 표현 방식으로 바꾸며, 수신 측은 데이터를 받을 때 이 외부 표현 방식을 자체 지역 표현 방식으로 바꾼다. 예를 들어, 정수의 외부 표현 방식으로 빅 엔디안 형식을 사용한다면, 송신 호스트는 자기가 보내는 각 정수를 빅 엔디안 형식으로 바꾸어야 하며, 수신 호스트는 자신이 사용하는 표현 방식이 무엇이든 빅 엔디안으로 된 정수를 자신의 내부 표현 방식으로 바꾸어야 한다.
- 수신 측 교정 방식은 송신 측에서 데이터를 자신의 교유한 내부 형태로 보낸다. 송신 측은 기본 유형을 변환하지 않지만, 보다 복잡한 자료구조체는 대개 정돈 하고 선형화한다. 수신 측은 그 데이터를 송신 측이 보낸 형태에서 자신의 지역 형태로 바꾸는 데에 대한 책임을 지게 된다. 이 전략의 문제점은 모든 호스트가 모든 다른 구조의 기게에서 오는 데이터를 변환시킬 준비가 되어 있어야 한다는 것이다. 네트워킹에서 이것은 `N-대-N 해결 방식`으로 알려져 있다. N개의 구조를 갖는 컴퓨터 각각은 모든 N개의 구조를 변환시킬 수 있어야만 한다. 여기에 비해, 규범적 중재 유형은 각 호스트가 자체 표현 방식과 외부 표현 방식 사이에 어떻게 변환하는가만 알면 된다. 그러나 이러한 것은 절대적인 것은 아니며 N의 크지 않고, 동일한 종류의 기계가 서로 데이터를 주고 받을 때는 굳이 변환을 안하여도 된다.

#### 태그
- 인코딩의 세 번째 문제는 수신 메시지 속의 데이터 종류를 수신 측에서 어떻게 아는가이다. 여기에는 태그 방법과 태그 하지 않는 방법이 있다.
- 태그란 메시지에 포함되는 일종의 추가적인 정보로, 수신측에서 메시지를 디코드하는 데 도움을 주는 것이다. 메시지에 포함될 수 있는 태그에는 여러 가지 가능한 것이 있다. 예를 들면, 각 데이터 항목은 타입 태그가 보충될 수 있다. 타입 태그는 뒤이어 나오는 숫자가 정수인지, 부동 소수인지, 또는 다른 것인지를 명시하게 된다. 다른 예로는 길이와 구조 태그가 있다. 각각의 태그는 자료의 크가나 자료구조 명시등에 사용된다.
- 태그 사용하지 않는 경우 수신 측이 데이터의 디코드 방식을 알고 있다는 가정 하에 프로그램을 작성하는 것이다. 예를 들어, 정수 두 개와 부동 소수 한 개를 인자로 하는 원격 프로시저를 수행한다면, 이런 원격 프로시저가 받은 데이터에 대해 태그를 검사할 필요없이, 메시지가 정수 두 개와 부동 소수 한 개를 담고 있다고 가정하고 여기에 따라 디코드하면 되는 것이다. 대부분의 경우에 동작하나, 길이가 일정치 않은 배열을 보내는 경우 동작하지 않는다. 이 경우에 길이 태그를 사용한다.
- 태그 없는 방식이라는 것은 프리젠테이션 형식화가 종단 간에 적용된다는 것을 의미한다. 데이터에 태그가 없다면 어떤 중간 에이전트도 메시지를 해석하는 것이 불가능하다.

#### 스텁
- 스텁이란 인코딩을 수행하는 코드로서, 일반적으로 RPC를 지원하기 위해 사용한다. 클라이언트 측에서 스텁은 프로시저 인자를 RPC 프로토콜이 전송할 수 있는 메시지로 정렬한다. 서버 측에서 스텁은 원격 프로시저를 부르는 데 사용되는 인자로 활용할 수 있도록 메시지를 여러 개의 변수로 변환한다. 스텁은 인터프리트되거나 컴파일되어 구현할 수 있다.
- 컴파일 기반 방식에서, 각 프로시저는 사양에 맞게 만들어진 클라이언트와 서버 스텁을 갖는다. 스텁을 사람이 직접 작성하는 것도 가능하지만, 일반적으로 스텁 컴파일러가 프로시저의 인터페이스 디스크립션을 기준으로 제작한다. 스텁이 컴파일되기 때문에 대개는 매우 효율적이다. 인터프리트 기반 방식에서는 시스템이 클라이언트 및 서버에 적용되는 일반적인 스텁을 제공하는데, 이것은 프로시저 인터페이스 디스크립션에 따라 정의된 매개변수를 갖는다. 디스크립션의 변경이 쉬우므로, 인터프리트 스텁은 유연하다는 장점을 갖는다.

### 예제

#### XDR
- 함수 포인터가 없는 C 타입 시스템 지원
- 규범적 중재 유형을 정의
- 태그를 쓰지 않음(배열의 길이를 가리키는 경우 제외)
- 컴파일 방식의 스텁 사용
- XDR에서의 정수는 C의 정수를 인코드한 32비트 데이터이다. 이것은 2의 보수 표기법으로 나타나는데, C 정수의 최상위 바이트를 XDR 정수의 첫 바이트에, C 정수의 최하위 바이트를 XDR 정수의 네 번째 바이트에 나타낸다. 즉, XDR은 빅 엔디안 방식을 사용한다. XDR은 부호 있는 정수와 부호 없는 정수 모두를 지원한다.
- XDR은 가변 길이의 배열을 나타낼 때, 우선 배열 원소 개수를 가리키는 부호 없는 정수를 지정하고, 다음에 적절한 유형의 많은 원소를 적는다. XDR은 구조체의 구성 요소를 구조체 안에서 지정 순서대로 인코딩한다. 배열과 구조체 모두에서 각 원소/구성 요소의 크기는 4바이트의 배수로 나타낸다. 크기가 작은 데이터 유형은 0을 채워 4바이트의 배수가 되도록 패딩한다. 문자에 대해서는 바이트당 하나로 인코드한다.
- XDR의 성능은 데이터의 복잡성에 달려 있다. 배열의 변환은 메모리 바운드 연산이다.

#### ASN.1
- ISO 표준으로, 네트워크 상으로 보내지는 데이터의 표현 방식을 정의한다. 이것의 표현 방식에 대한 부분만을 BER이라 한다. ASN.1은 함수 포인터가 없는 C 타입 시스템을 지원하며, 규범적 중재 유형을 정의하고, 타입 태그를 사용한다. 스텁은 인터프리트되거나 컴파일될 수 있다.
- 각 데이터 항목을 `<tag, length, value>`로 표현한다. 다중 바이트 태그의 정의를 허용하지만, 태그는 일반적으로 8비트 필드이다. length 필드는 value 필드를 만드는 데 얼마나 많은 바이트가 들어가는지를 지정한다. 구조체와 같은 복잡한 데이터 유형은 기본 유형을 중첩시킴으로써 작성될 수 있다. value의 길이가 127바이트 이하이면, length를 한 바이트로 지정한다. value 자체는 정소의 경우 2의 보수 표기법과 빅 엔디안 형태로 나타낸다. 이 타입과 length 태그는 메시지에서 추가 바이트를 차지하며, 이 태그도 인코딩/디코딩 작업이 필요로 한다. 또한 각 데이터값의 길이가 length 필드에 의해 결정되어 그 데이터 길이가 자연적인 바이트 경계에 맞아 떨어지지 않을 수 있다. 이것은 인코딩/디코딩 작업을 어렵게 한다.
- value가 128바이트 이상이면, length를 지정하기 위하여 여러 바이트를 사용한다. 

#### NDR
- 수신 측 교정 방식을 사용한다. 이것은 각 메시지 앞에 구조 태그를 삽입해 수행하는데, 각 데이터 항목에는 태그를 사용하지 않는다. NDR은 스텁을 만들기 위해 컴파일러를 사용한다. 이 컴파일러는 IDL로 쓰여진 프로그램의 설명을 받아들이며, 필요한 스텁을 만든다.

### Markup Languages
- Markup 언어는 데이터 양 끝에 태그가 붙는다. 데이터는 텍스트로 표현되고, 데이터에 관한 정보를 표현하기 위해 텍스트 태그는 데이터와 함께 쓰인다. HTML에서는 텍스트 태그가 단지 텍스트가 어떻게 보일지를 나타낸다. 혹은 다른 markup 언어에서는 데이터의 타입과 주로를 표현한다.
- XML는 구조와 다른 종류의 데이터를 위한 다른 markup 언어를 정의하기 위한 구조와 문법적인 기반이다. XML은 HTML과 같은 markup 언어를 정의하기 위해 사용된다. XML은 데이터와 텍스트 태그를 함께 사용하기 위한 기본적인 문법을 정의한다. 하지만 특정 markup 언어의 설계자는 자신이 설계한 텍스트 태그를 이름을 붙이고 정의해야만 한다.
- XML은 사용자에게 태그/값 쌍의 중첩된 구조가 가능하게 한다. 이것은 XDR, ASN.1, NDR의 복합 형식 표현 기능과 유사하지만, 프로글매도 처리 가능하고 인간도 읽을 수 있다. XML 기반의 언어들의 정의는 프로그램의 입력 값으로써 사용할 수 있기 때문에, 파서와 같은 프로그램은 다른 XML 기반의 언어들에 걸쳐 사용될 수 있다.
- 특정 XML 기반 언어의 정의는 스키마에 의해서 정해진다. 스키마는 데이터의 집합을 해석하는 방법에 대해 명세 하는 것이다. XML Schema는 데이터 타입을 제공한다. XML Schema를 사용하여 정의된 개별적 스키마는 XSD이다. XSD는 문법 이상의 의미를 정의한다. XSD는 공유의 데이터 모델을 정의한다. 임의의 XSD를 따르는 문서에서는 XSD에 있는 데이터 모델을 따르는 데이터의 집합을 사용한다. XML은 다른 데이터 표현만큼 압축되어 있지 않다. 또한 상대적으로 분석하는 것이 느리다.

#### XML Namespaces
- XML은 이름 충돌이라는 문제를 풀어야 한다. 이 문제는 XML 스키마와 같은 스키마 언어는 하나의 스키마가 다른 스키마의 한 부분으로 재사용될 수 있는 모듈성을 지원하기 때문에 발생한다.
- 이 문제를 해결하기 위한 XML의 방법은 XML 이름공간이다. 이름공간은 이름들의 집합이다. 각 XML 이름공간은 URI에 의해서 식별된다. markup 이름이 이름공간에서 유일하다면, 그 이름공간에 추가될 수 있다. 이름공간이 전역적으로 유일하고, 이름공간 안에서 정의된 이름은 그 이름공간안에서 유일하기 때문에, 두 개의 조합은 충돌이 일어날 수 없는 전역적으로 유일한 검증된 이름이다.
