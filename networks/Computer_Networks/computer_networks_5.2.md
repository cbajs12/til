# 종단 간 프로토콜

## 신뢰성 있는 바이트 스트림
- 이 서비스는 애플리케이션 프로그램이 데이터를 잃어버리거나 데이터를 재정렬하는 것에 신경 쓰지 않아도 트랜스포트가 책임지고 수행한다.
- 대표적인 프로토콜은 `TCP`이다.
- TCP는 신뢰성 있고 정렬된 바이트 스트림을 보장한다. 이는 전이중 프로토콜이며, 각 TCP 연결이 한 쌍의 양방향인 바이트 스트림을 지원한다는 것을 의미한다. 또한 각 바이트 스트림에 대해서 송신자가 얼마나 많은 양의 데이터를 보낼 수 있는가를 수신자가 제한할 수 있도록 하는 흐름제어 기법을 포함하고 있다. 또한, UDP와 마찬가지로, 한 호스트 상의 여러 애플리케이션이 동시에 여러 상대와 대화할 수 있게 해 주는 역다중화 기법을 지원한다.
- 또한, TCP는 혼잡제어 기법을 사용하고 있는데, 이 기법의 기본 발상은 TCP가 데이터를 보내는 전달 속도를 제한하는 방식인데, 송신자는 수신자의 수신속도보다 더 빨리 전달하지 못하도록 관리하는 것이다. 이는 곧 네트워크의 과부하를 막아준다.
- 흐름제어와 혼잡제어의 차이: 흐름 제어는 송신자가 수신자의 수신보다 더 빨리 전달하지 못하는 것이고, 혼잡제어는 과다한 데이터가 네트워크로 유입되어 링크나 교환기가 과부화되는 것을 막는 것이다. 흐름 제어는 종단 간의 문제이며, 혼잡 제어는 종단 호스트와 네트워크의 상호 작용 방식에 관한 문제이다.

### 종단 간 쟁점
- TCP의 핵심은 슬라이딩 윈도우 알고리즘이다.
- TCP는 인터넷 상의 임의의 두 호스트에서 동작하는 프로세스 간의 논리적 연결을 지원한다. 이는 접속된 두 종단이 데이터를 상호 교환하는 것을 허가할 때 TCP가 명시적인 연결 성립 절차를 필요로 한다는 것을 의미한다. 또한, TCP는 명확한 연결 해제 절차를 가진다.
- TCP 연결은 매우 가변적인 왕복지연시간을 가질수 있다. 이는 슬라이딩 윈도우 알고리즘이 재전송을 시작할 때 시간제한 기법이 적용되어야 한다는 것을 의미한다.
- TCP를 통하는 패킷들은 인터넷을 경유할 때 재정렬될수도 있다. 이러한 정렬되지 않은 패킷들은 슬라이딩 윈도우 알고리즘이 패킷의 순서를 이용하여 재정렬할 수 있어서 문제가 되지 않지만, 문제가 있는 것은 패킷들이 얼마만큼 정렬되지 않고 오는가와 패킷들이 목적지에 얼마나 늦게 도착하는가이다. 최악의 경우에는 패킷들이 IP의 TTL까지 지연이 발생할 것이고, TTL이 지나면 버려진다. 이렇기 때문에 TCP의 각 패킷은 최대한의 유효시간을 가지고 있다.
- 어느 한 호스트도 동시에 수많은 TCP 접속을 잠재적으로 지원할 수 있다는 점은 TCP로 하여금 접속 지원을 위해서 상대방이 어떤 자원을 가지고 있는지 다른 한쪽이 알 수 있는 매커니즘을 포함해야한다. 이것이 흐름제어이다.
- TCP 접속에서 송신자는 목적지에 도달하기 위해 어떤 링크를 통과할 것인지 미리 알지 못한다.
- x.25 네트워크는 홉 기반 위에서 네트워크 내의 슬라이딩 윈도우 프로토콜을 이용한다. 발신지 호스트와 목적지 호스트 간의 경로를 따르는 각 노드가 신뢰성 있고 질서정연하게 메시지를 전달하면 종단 간 서비스도 신뢰성 있고 정렬된 전달이 보장된다는 것이다. 그러나 홉 기반인 이 기법은 가정의 결과가 반드시 종단 간 보장을 의미하는 것은 아니다. 대조적으로 TCP는 신뢰성 있고 정렬된 전달을 제공하기 위해 종단 간 기반위에서 슬라이딩 윈도우 알고리즘을 사용한다.

### 세그먼트 형식
- TCP는 바이트 기반의 프로토콜이다. 즉, 송신자는 TCP 연결에 바이트를 쓰고, 수신자는 TCP 연결로부터 바이트를 읽는 방식을 의미한다.
- TCP가 애플리케이션 프로세스에게 바이트 스트림 형태로 서비스를 제공한다 할지라도 TCP 자체가 인터넷 상에서 각각의 바이트를 전송하는 것은 아니다. 대신에 발신지 호스트의 TCP는 송신 프로세스로부터 적당한 크기의 패킷으로 채워진 바이트를 버퍼에 채운다. 목적지 호스트상의 TCP는 수신 버퍼에 있는 패킷의 내용을 비우고, 수신 프로세스는 패킷의 여분을 수신 버퍼로부터 읽게된다.
- 단순 TCP 연결은 양방향의 바이트 스트림 흐름을 지원한다.
- 각 TCP 동료가 바이트 스트림의 세그먼트를 운반하기 때문에, TCP 동료들 사이에 교환되는 패킷을 `세그먼트`라고 한다.

#### 세그먼트 헤더
- srcPort, DstProt 필드는 UDP에서와 같이 발신지와 목적지 포트를 지정한다. 발신지와 목적지 IP주소, 그리고 이 두필드는 각 TCP 연결의 유일한 식별을 위해 결합시킨다. 따라서, TCP의 demux 키는 `<srcPort, srcIPaddr, dstPort, dstIPadder>`의 조합으로 이루어진다. 두 개의 특정한 포트 사이의 TCP 연결은 데이터를 주고받기 위해 사용되고, 해제된 이후 다시 두 번째 연결에서 같은 포트의 쌍이 사용될 수 있다. 이러한 상황을 연결에 대한 두 개의 다른 `분신`이라고 부른다.
- Acknowlegment, SequenceNum, AdevertisedWindow 필드는 모두 TCP의 슬라이딩 윈도우 알고리즘에 관여한다. 왜냐하면 TCP는 바이트 중심의 프로토콜이고, 각각의 데이터 바이트는 순서번호를 가지기 때문이다. 
- SequenceNum 필드는 세그먼트에서 운반되는 데이터의 첫바이트를 위하여 순서번호를 가진다. 
- Acknowlegment, AdevertisedWindow 필드는 다른 방향으로 진행하는 데이터의 흐름에 대한 정보를 운반한다. 
- 6비트의 Flag 필드는 TCP 송수신자 사이에 통제 정보를 중계하기 위해 사용된다. 이 플래그는 SYN, FIN, RESET, PUSH, URG, ACK를 포함한다. 
- SYN과 FIN 플래그는 각각 TCP 연결을 설정하고 해제할 때 사용된다. 
- ACK 플래그는 어느 시간에 Acknowlegment 필드가 타당한지를 결정하게 되는데, 수신자가 주의를 기울여야 함을 의미한다. 
- URG 플래그는 이 세그먼트가 긴급한 데이터를 포함한다는 것을 나타낸다. 이 플래그가 설정되었을때 UrgPtr 필드는 이 세그먼트에서 포함된 긴급하지 않은 데이터가 어디에서부터 시작하는지를 가리킨다. 
- PUSH 플래그는 송신자가 push 연산을 요구했다는 것을 나타낸다. push 연산을 요구한 사실을 수신 프로세스에게 공지하여야 한다는 것을 TCP의 수신자에게 알릴 경우에 설정된다. 
- RESET 플래그는 혼동상태를 의미하는데, 예를 들면 수신자가 기대하지 않았던 세그먼트를 받게되어 그 연결을 해제하려는 경우가 있다.
- Checksum 필드는 UDP에서 쓰인것과 똑같은 방법으로 사용된다. IP 헤더의 발신지 주소, 목적지 주소와 IP 헤더 필드와 같은 길이로 구성된 TCP 헤더, TCP 데이터와 의사헤더에 의해 계산된다. TCP 헤더가 가변 길이기 때문에, HdrLen 필드는 32비트 워드의 헤더 길이를 포함한다. 패킷의 시작으로부터 데이터의 시작까지 오프셋을 측정하기 때문에 Offset 필드라고도 한다.

### 연결 설정과 해제
- TCP 연결은 클라이언트가 서버에게 능동적 열기를 함으로써 시작된다. 서버는 초기에 수동적 열기를 수행했기 때문에, 양 송수신자는 연결을 설정하기 위해 메시지를 교환한다. 
- 이 연결 설정 단계가 끝난 후에 송수신자가 데이터를 전달하기 시작한다. 마찬가지로, 연결에 참여하는 송수신자는 데이터를 전달하자마자 연결의 한 방향을 닫는다. 이는 TCP가 연결 설정 및 해제 메시지의 순환을 초기화시킨다. 
- 연결 설정이 한쪽은 수동적 열기 다른쪽은 능동적 열기를 하는 것처럼 비대칭적인 반면 연결 해제는 각각이 독립적으로 해제하는 대칭형이다. 
- 한쪽이 더이상 데이터를 송신할 것이 없다는 것을 의미하는 폐쇄 상태가 된다, 그러나 다른 한쪽은 연결 설정의 반을 보존하고 데이터를 계속 송신하는 것이 가능하다.

#### 3단계 핸드셰이크
- 연결을 설정하고 해제하기 위해 TCP에 의하여 사용된 알고리즘은 3단계 핸드셰이크이다.
- 3단계 핸드셰이크는 클라이언트와 서버 사이에 3개의 메시지 교환으로 이루어진다.
- 기본 아이디어는 두 참여자가 매개변수 집합을 통해 일종의 약속을 한다는 것이다. TCP 연결 설정의 경우, 두 참여자가 그들 각각의 바이트 스트림에 대해 사용하고자 하는 시작 순서번호가 매개변수가 된다. 일반적으로 그 매개변수는 상대방이 알고 싶어하는 정보를 알아내기 위해서 사용된다.
- 클라이언트는 (Flags = SYN, SequenceNum = x)를 사용하려는 초기 순서번호 상태에 있는 서버에게 세그먼트를 보낸다. 그러면 서버는 클라이언트가 보낸 순서번호(Flags=ACK, Acknowlegment = x+1)에 대하여 ACK할 수 있고, 이때 자신의 순서번호의 시작(Flags = SYN, SequenceNum = y)을 나타낼 수 있는 하나의 세그먼트를 보내게 된다. 이것을 받은 클라이언트는 서버로부터 받은 순서번호(Flags=ACK, Acknowlegment = y+1)에 대한 ACK를 보낸다. 각 송수신자가 이전에 보낸 순서번호보다 큰 순서번호에 대하여 ACK를 하는 이유는 Acknowlegment 필드가 `받기 원하는 다음 순서번호`에 대하여 실제로 식별할 수 있기 때문이다. 이렇게 함으로써 이전의 모든 순서번호에 대해 암시적으로 ACK하는 것이 된다. 
- 타이머는 송수신자의 처음 두 세그먼트에 맞추어져 있다. 그리고 기대되는 ACK가 수신되지 않았다면 해당 세그먼트는 재전송된다.
- TCP는 연결된 송수신자에서 초기의 순서번호를 임의로 선택하는 것이 필요하다. 동일한 순서번호를 재사용하고 있는 이미 연결된 송수신자를 보호하기 위해서이다.

#### 상태전이 도표
- 슬라이딩 윈도우 알고리즘의 동작과 같이 연결된 상태에서 모든 동작은 ESTABLISHED 상태에 포함된다.
- 모든 연결은 CLOSED 상태에서 시작한다. 
- 상태전이를 시작하게 하는 두 종류의 이벤트는 동료로부터 세그먼 도착과 자신의 프로세스가 TCP 연산을 호출하는 것이 있다.
- 3단계 핸드세이크의 세 번째 전달할 ACK를 서버로 보내다가 잃어버렸을 경우에도 연결은 제대로 동작한다. 즉, 클아이너트 쪽이 이미 ESTABLISHED 상태에 있기 때문에 프로세스는 서버로 데이터를 보낼수 있다. 이런 데이터 세그먼트는 ACK 플래그가 설정된 상태가 되고, Acknowlegment 필드에 올바른 값을 갖기 때문에, 서버는 첫 번째 데이터 세그먼트가 도착했을때 ESTABLISHED 상태로 이동할 것이다. 비록 한 번이나 그 이상의 이전 세그먼트를 포함한 같은 순서번호가 반복된다고 해도 모든 세그먼트는 그것을 전한다는 사실이 TCP에서 실질적으로 중요한 사항이 된다.
- 프로세스가 TCP 상에서 송신 동작을 호출할 때마다, 수동적인 송신자나 수신자 중 하나가 연결의 양쪽 종단을 식별할 수 있게 하고, 능동적인 연결을 설정하는 대신 다른 쪽에서의 접속을 기다리는 변화를 허용할 수 있다. 
- 세그먼트를 다른쪽으로 보내는 것에 해당하는 대부분의 상태는 기대했던 응답이 발생되지 않는다면, 결국 세그먼트를 재정송하는 시간제한 기법을 사용하려고 한다. 만약 여러번 재시도 후에도 기대되는 응답이 도착하지 않는다면 TCP는 포기하고 CLOSED 상태가 된다.
- 연결의 송수신자 프로세스는 각 송수신자 연결의 절반을 독립적으로 닫아야 한다. 이러한 사실은 한쪽이 close 연산을 호출하고, 다른쪽이 호출하는 가능성뿐만 아니라, 양쪽이 동시에 close 연산을 호출하는 가능성도 존재한다.
- 연결 해제에서의 핵심사항은 IP 데이터그램이 인터넷에서 남아 있을 최대 시간의 두배의 대기가 있을때까지 연결은 CLOSED 상태로 이동할 수 없다. 이유로는 연결의 한쪽이 다른 쪽의 FIN 세그먼트에 대한 응답으로 ACK를 보내는 동안, ACK를 보낸 쪽은 ACK가 성공적으로 전달되었는지 알 수가 없다. 결과적으로 다른 쪽은 FIN 세그먼트를 재전송해야하고, 두 번째 보낸 FIN 세그먼트는 네트워크상에서 지연될 수 있다. 
- 연결이 대기 없이 즉시 CLOSED 상태로 전이하는 것이 허락되면 이전 연결의 송수신자가 늦게 온 FIN 세그먼트를 받고 나중에 설정된 연결을 종료할 수 있다.

### 슬라이딩 윈도우
- 슬라이딩 윈도우는 데이터를 신뢰성 있게 전달하고, 전달되는 순서대로 도착함을 보장하며, 송신자와 수신자 간의 흐름을 제어한다.
- 고정된 크기의 슬라이딩 윈도우를 갖지 않는 대신 수신자는 송신자에게 윈도우의 크기를 알려준다. 이는 TCP 헤더의 AdevertisedWindow 필드를 사용함으로써 이루어진다. 이후 송신자는 AdevertisedWindow에 규정된 바이트 이상의 확인받지 못한 데이터를 전달하지 않도록 제한된다. 수신자는 데이터를 버퍼링하기 위해 연결에 할당받은 메모리 용량에 근거하여 적절한 AdevertisedWindow 값을 선택한다. 핵심은 수신자의 버퍼 용량 이상으로 송신자가 전달하지 못하도록 하는 것이다.

#### 신뢰성 있고 순서를 유지하는 전달
- 송신자의 TCP는 송신 버퍼를 유지한다. 이 버퍼는 송신 애플리케이션 프로그램에 의하여 전달되었으나 아직 전달되지 않은 데이터 뿐만 아니라, 실제로 전달되었으나 아직 수신하였다는 신호를 받지 못한 데이터도 저장한다.
- 수신자에게서 TCP는 수신 버퍼를 유지한다. 이 버퍼는 순서대로 도착하였으나 애플리케이션 프로그램에 의해 아직 읽혀지지 않은 데이터와 순서가 뒤바뀌어 수신된 데이터를 가진다.
- 송신자는 LastByteAcked, LastByteSent, LastByteWritten의 세 개의 버퍼를 가르키는 포인터를 사용한다.
- `LastByteAcked <= LastByteSent`라는 것은, 수신자는 아직 수신하지 못한 바이트에 대해 받았다는 신호를 보낼 수 없기 때문이다.
- `LastByteAcked  <= LastByteWritten`라는 것은, 이는 TCP가 프로세스에 의해 버퍼에 쓰지 않은 바이트를 송신할 수 없기 때문이다.
- LastByteAcked의 이전 바이트는 이미 올바르게 받았다는 신호를 받은 것이다. 그러므로 버퍼에 저장될 필요 없다.
- LastByteWritten의 다음 바이트는 아직 생성되지 않은 바이트이다.
- 수신자에게는 송신자와 유사한 포인터의 집합이 유지된다. LastByteRead, NextByteExpected, LastByteRcvd 이다.
- `LastByteRead < NextByteExpected`인 것은 어떤 한 바이트의 데이터는 이전의 바이트가 모두 수신된 후에 수신될 때까지 애플리케이션 프로그램에 읽힐 수 없기 때문이다. NextByteExpected는 이 기준을 만족시키는 마지막 바이트의 다음 바이트를 지시한다.
- 데이터가 순서대로 도착한다면 NextByteExpected가 NextByteExpected의 다음 바이트를 가리킬 것이고, 데이터가 순서대로 도착하지 않는다면 NextByteExpected는 데이터 내의 첫 번째 갭의 시작을 가르킬 것이므로, `NextByteExpected <= LastByteRcvd +1`는 성립할 것이다.
- LastByteRead의 이전에 있는 바이트들은 프로세스에 의하여 읽혔으므로 버퍼될 필요가 없고 LastByteRcvd의 이후의 올 바이트는 아직 도착하지 않은 것이다.

#### 흐름제어
- TCP의 흐름제어는 송신자와 수신자의 프로세스가 자신의 버퍼를 채우고 비운다는 사실을 이용하였다.
- 송수신자의 버퍼를 MaxSendBuffer와 MaxRcvBuffer로 나타내며 유한한 크기를 가진다. 버퍼링되는 바이트의 수만을 고려하고 버퍼링된 바이트가 어디에 저장되어 있는지는 고려하지 않는다.
- 슬라이딩 윈도우 프로토콜에서 윈도우 크기는 수신자가 올바르게 수신하였다는 신호를 기다릴 필요 없이 송신할 수 있는 데이터의 크기를 의미한다. 따라서 수신자는 자신이 저장할 수 있는 데이터 양만큼 윈도우를 송신자에게 알림으로써 송신자를 구속시킨다. 
- 수신자의 TCP는 버퍼가 오버플로우되는 것을 막기 위하여 `LastByteRcvd - LastByteRead <= MaxRcvBuffer`를 유지한다. 따라서 수신자는 자신의 버퍼에 남은 공간을 표시하는 윈도우 크기(`AdevertisedWindow  = MaxRcvBuffer - (NextByteExpected - 1) - LastByteRead` )를 송신자에게 알린다.
- 데이터가 도착함에 따라 수신자는 이전 바이트 역시 올바로 수신되었을 때에 한하여 윈도우 크기를 송신자에게 알린다. 또한, LastByteRcvd는 오른쪽으로 이동하며, 이는 송신자에게 알렸던 윈도우 크기가 줄어드는 것을 의미한다. 윈도우 크기가 줄어드는가 아닌가의 여부는 수신자의 프로세스가 얼마나 데이터를 처리하는가에 달려있다. 프로세스가 수신되는 속도만큼 데이터를 읽는다면 윈도우 크기는 줄어들지 않을 것이다(`AdevertisedWindow  = MaxRcvBuffer`). 데이터 처리가 늦어진다면, 윈도우 크기는 데이터가 도착할 때 마다 줄어들어 결국 0이 될것이다.
- 송신자의 TCP는 수신자로부터 얻은 윈도우 크기를 반드시 지켜야 한다(`LastByteSent - LastByteAcked <= AdevertisedWindow`). 다르게 표현하면 송신자는 자신이 보낼 수 있는 데이터의 양을 제한하는 효과적인 윈도우 크기를 계산한다(`EffectiveWindow = AdevertisedWindow - (LastByteSent - LastByteAcked)`).
- EffectiveWindow는 송신자가 데이터를 송신하기 전에 반드시 0보다 큰 값을 가져야 한다.
- 송신자는 송신버퍼가 오버플로우되지 않는 다는 사실을 확신하여야 한다(`LastByteWritten - LastByteAcked <= MaxSendBuffer`)
- 송신 프로세스가 TCP에 y개 바이트를 쓰려고 하지만 `(LastByteWritten - LastByteAcked) + y > MaxSendBuffer`라면, TCP는 송신 프로세스를 블록시키고 더 이상 데이터를 생성하지 않을 것이다.
- 윈도우 크기가 0이라는 것인 이전에 보낸 데이터가 올바르게 수신되었다는 신호를 받아도 송신자는 어떤 데이터도 보낼수 없다는 것이다. 이것은 송신 버퍼를 모두 채움으로써 TCP가 송신 프로세스를 블록시킨다.
- TCP는 항상 수신한 데이터에 대한 응답으로 신호를 보내는데, 이 신호에는 AdevertisedWindow와 Acknowlegment 필드에 대한 최근 값이 포함되어 있다. 
- 수신자의 TCP는 데이터를 포함하지 않는 세그먼트는 송신하지 않는다. 즉, 수신된 데이터에 대한 응답으로만 세그먼트를 보낸다.
- 상대방의 윈도우 크기가 0이라고 알렸을 경우, 송신자는 계속하여 1바이트의 크기를 가진 데이터를 전달한다. 이 데이터가 수신자에 의하여 받아들여지지 않을 것임을 송신자는 알지만, 이 1바이트 세그먼트에 대해 최근의 윈도우 크기를 포함한 응답을 야기시키므로 계속 시도된다. 결국, 1바이트 세그먼트 중의 하나에 의하여 0이 아닌 윈도우 크기를 알려주는 응답이 결과로 돌아온다.
- 수신자는 송신자로부터 온 세그먼트에 대해 응답하지만 자기 자신은 스스로 어떤 행위도 먼저 시작하지 않는다.

#### 중복으로부터의 보호
- TCP의 SequenceNum 필드는 32비트이고, AdevertisedWindow 필드는 16비트이다. 이것은 TCP 순서번호의 최대 크기가 윈도우 크기의 두 배 이상이 되어야 한다는 슬라이딩 윈도우 프로토콜을 쉽게 만족시킴을 의미한다.
- 접속에 사용되는 32비트의 순서번호가 중복될 수 있다. 이러한 현상이 일어나는지의 여부는 얼마나 빨리 데이터가 전송되는가에 달려 있다. 즉, 32비트 순서번호 공간이 얼마나 빨리 채워지는가 하는 것이다.
- 32비트 순서번호 공간은 현재 사용중인 네트워크에는 적합하지만, 인터넷 백본으로 광범위하게 설치되어질 링크의 경우에는 몇몇의 서버들은 기가비트의 이더넷 환경을 지원하기 때문에 32비트의 길이는 충분하지 못한다.

#### 파이프에 항상 가득 차도록 유지
- 16피트 AdevertisedWindow 필드에 대한 타당성은 송신자가 항상 파이프를 가득 채우도록 허용할 수 있을만큼 충분해야 한다는 것이다. 수신자는 AdevertisedWindow 필드가 허용하는 것만큼의 윈도우 크기를 알리지 않아도 된다. 즉, 수신자가 AdevertisedWindow를 허용하는 것만큼의 많은 데이터를 처리할 수 있는 버퍼 공간을 가지고 있는 상황에 대해서만 관심을 가지게 된다.
- 이 경우에, AdevertisedWindow 필드가 얼마나 커야 하는 가를 나타내는 것은 네트워크의 대역폭이 아니고 `지연시간과 네트워크의 대역폭을 곱한 값`이다. TCP의 AdevertisedWindow필드는 64KB 크기의 윈도우 밖에 허용하지 못하므로 T3 연결을 처리하기도 부족하다.

### 전송 개시
- 애플리케이션 프로그램들은 TCP가 세그먼트를 전송하기에 충분한 바이트가 쓰였다고 판단할 때까지 스트림에 바이트를 쓰게 된다.
- TCP는 세그먼트 전송 개시를 위한 3가지 메커니즘을 가진다. 
- 첫째, TCP는 최대 세그먼트 크기(MSS)로 불리는 변수를 유지하고 전송 과정에서 MSS 바이트만큼의 데이터가 쌓이면 바로 전송을 개시한다. MSS는 일반적으로 TCP가 Local IP로 세그먼트를 전송할 때 단편이 발생하지 않을 최대 세그먼트 크기로 정해진다. 다시 말하면 MSS는 직접 연결된 네트워크의 MTU에서 TCP와 IP의 헤더만큼의 크기를 뺀 값으로 설정된다.
- 두번째, 송신 프로세스가 정확하게 전송 개시를 요청하는 것이다. 특별하게 TCP는 push 동작을 지원하고 송신 프로세스는 이런 TCP의 push 동작을 사용하여 아직 채워지지 않은 버퍼를 효과적으로 채울 수 있다.
- 세번째, 타임아웃 기법이 있다.

#### 어리석은 윈도우 신드롬
- 송신자가 전송되기 위한 MSS 만큼의 데이터를 가지고 있고 윈도우가 적어도 그 크기만큼 받을 수 있도록 준비되어 있다면 송신자는 완전한 하나의 세그먼트를 전송할 것이다. 하지만 송신자가 전송하기 위한 데이터를 버퍼에 쌓는 중이고 윈도는 닫혀있다고 한다면, 사용할 수 있는 윈도우를 최대한 이용하자는 전략이 `어리석은 윈도우 신드롬`을 일으킨다.
- 즉, 작은 세그먼트들은 한쪽 끝에서 즉시 채워질 것이고 다른 한쪽에서 바로 비워질 것이며 결코 MMS만큼의 크기를 가진 세그먼트로 합해질수 없다는 것이다.
- 어리석은 윈도우 신드롬은 단지 송신자가 작은 세그먼트를 전송하거나 수신자가 작은 크기의 윈도우를 열었을 때 생기는 문제이다.
- 송신자에서 작은 컨테이너가 스트림에 삽입되는 것을 막을 수 없기 때문에 수신자 단에서 이런 작은 윈도우를 합하는 메커니즘이 필요하다. 수신자는 ACK를 늦춤으로써 이것을 가능하게 한다. 그러나 수신자가 하나의 세그먼트가 도착하거나 프로그램이 많은 데이터를 읽기 위해 얼마동안 대기해야 안전한지 알수 없기 때문에 부분적인 해결책일 뿐이다.

#### Nagle's 알고리즘
- TCP 송신자가 전송해야 할 데이터가 있고 MSS보다 작은 윈도우가 열리게 되었다면 송신자는 사용 가능한 데이터를 전송하기 전에 일정 기간 기다려야 하는데 짧으면 어리석은 윈도우 신드롬에 빠질 것이고, 길면 애플리케이션간 상호 작용에 피해를 줄 수가 있어서, 어느정도가 적절한지를 판단해야 한다. 그 해답은 타이머에 있다. 타이머가 해지될 때 전송하면 되는 것이다.
- TCP가 전송해야 할 임의의 데이터를 가지고 있다면 송신자는 결국 ACK를 받게 될 것이다. 이 ACK는 타이머 해지, 많은 데이터에 대한 전송 개시와 같은 일들을 처리하게 된다.
- Nagle's 알고리즘: 만약 윈도우가 MSS 크기로 열리게 도니다면 MSS 크기의 세그먼트를 전송한다. 그리고 현재 전송 중인 세그먼트가 없다면 작은 양의 데이터를 즉시 전송한다. 하지만 전송 중인 데이터가 있다면 송신자는 다음 세그먼트를 전송하기 전에 반드시 ACK를 기다려야 한다. 
- 그러므로 한 번에 1바이트 만을 지속적으로 쓰는 Telnet과 같은 애플리케이션 프로그램은 RTT당 한 세그먼트 비율로 데이터를 전송할 것이다. 어떤 세그먼트는 단지 한 개의 바이트만을 포함할 것이다. 반면에 다른 세그먼트들은 하나의 RTT 시간 내에 사용자가 선언할 수 있는 만큼의 많은 바이트들을 포함할 것이다. 
- 일부의 애플리케이션들만이 사용하기 위해 TCP 연결상에 데이터를 쓰기 위한 지연시간을 수용할 수 없기 때문에 소켓 인터페이스는 `TCP_NODELAY` 옵션으로 이 알고리즘을 사용할지 않할지를 결정한다. 이 옵션의 설정은 데이터가 가능한 빠르게 전송되는 것을 말한다.

### 유연한 재전송
- TCP는 신뢰성 있는 데이터 전달을 보장하므로 시간 내에 ACK를 받지 못한다면 재전송을 해야한다. TCP는 연결의 두 종단 사이에 기대되는 RTT의 함수로 타임아웃을 설정한다.

#### 원래의 알고리즘
- 두 호스트 간의 타임아웃 값을 계산하는 간단한 알고리즘은 RTT의 평균 값을 유지하면서 RTT의 타임아웃 값을 계산하는 것이다. TCP가 데이터를 송신할 때마다 시간을 기록한다. 주어진 세그먼트에 대한 ACK가 도착하면 TCP는 그 시간을 다시 읽은 후, 두 시간차를 계산하여 `SampleRTT`라는 값으로 할당한다. 
- TCP는 이전의 예상값과 현재의 값에 대한 가중값 평균을 EstimateRTT라는 값으로 계산한다. 즉 `EstimateRTT = a * EstimateRTT + (1 - a) * SampleRTT`이며, 매개변수 a는 EstimateRTT를 유연하게 하도록 선택된다.
- 작은 a값은 RTT 변화를 잘 반영하지만, 일시적인 변동에 심하게 영향을 받는다. 반면 큰 a값은 안정적이지만, 순간적인 변화를 즉시 반영하지 못할 것이다.
- TCP는 EstimateRTT를 사용하여 타임아웃 값을 계산한다(`TimeOut = 2 * EstimateRTT`).

#### Kam/Partridge 알고리즘
- 원래의 알고리즘은 큰 결점이 있는데, ACK는 어떤 송신에 대한 신호로 보내진 것이 아니란 것이다. 즉, 어떤 세그먼트가 재전송된 후 송신자에 ACK가 도착할 때마다, 현재의 RTT 값을 계산하기 위해, 이 ACK가 처음에 송신된 데이터에 대한 것인지 재전송에 대한 것인지를 판단할 수 없다. 따라서 정확한 SampleRTT를 계산하기 위하여 ACK가 어떤 송신에 관련된 것인지를 알 필요가 있다.
- 이에 대한 해결법은 TCP가 재전송할 때마다 RTT를 샘플링하는 것이다. 즉, TCP는 단지 재전송이 없었던 세그먼트만을 상대로 SampleRTT를 측정한다. 이것이 `Kam/Partridge 알고리즘`이다.
- Kam/Partridge 알고리즘은 TCP 타임아웃 기법에도 변화를 주었다. TCP는 재전송할 때마다 이전의 EstimateRTT에 근거하여 타임아웃을 설정하지 않고 이전 타임아웃의 두배로 설정한다. 이것은 TCP에서 지수적 백오프 기법을 사용하는 것이다. 이더넷과 동일한 방법이다.
- 이 기법을 사용하는 이유는 혼잡은 세그먼트의 손실을 자주 일으키게 될 것이고, 이것은 TCP 송신자가 타임아웃에 적극적으로 반응하지 않아야 한다는 것이다. 연결에서 타임아웃의 횟수가 많아질수록, 송신자는 더욱 조심스러워질 것이다.

#### Jacobson/Karels 알고리즘
- Kam/Partridge 알고리즘은 인터넷 혼잡에 대한 원인을 고치고 개선을 가져왔으나 혼잡을 제거하지는 못했다.
- 타임아웃은 혼잡과 관련이 큰데, 일찍 타임아웃을 한다면 불필요하게 세그먼트를 재전송할 것이고, 네트워크에 부담을 준다. 또한 정확한 타임아웃 값이 필요한 이유는 타임아웃은 혼잡을 의미하고 혼잡제어 기법을 구동시키기 때문이다.
- 이 알고리즘은 타임아웃 계산이 TCP에만 한정되어 있지 않음을 주목한다. 이는 어느 다른 종단 간 프로토콜에도 사용될 수 있다.
- 원래의 방법에서 문제는 샘플된 RTT의 분산을 고려하지 않는다는 점이다. 샘플간의 변화가 적다면 EstimatedRTT는 더 신뢰성 있을 것이고, 타임아웃을 계산하기 위하여 이 값에 2를 곱할 필요가 없다. 반면, 샘플에 대한 분산이 크다는 것은 타임아웃 값이 EstimateRTT와 거의 같은 값을 가져서는 안된다는 것을 의미한다.
- 새로운 방법에서 송신자는 이전과 같이 새로운 SampleRTT를 측정한다. 그러고 나서, 타임아웃 값을 계산하는 데 샘플값을 이용한다. 식에서 s는 0과 1사이의 값이다.
- `Difference= SampleRTT - EstimateRTT, EstimateRTT = EstimateRTT + (s * Difference), Deviation = Deviation + s(|Difference| - Deviation )` 즉, 평균 RTT와 그 편차를 모두 계산한다.
- TCP는 `TimeOut = u * EstimateRTT + q * Deviation` 계산을 한다. 보통 u는 1, q는 4로 설정한다. 
- 따라서 분산이 작다면 Timeout은 EstimateRTT와 비슷할 것이고, 분산이 크다면 편차값이 계산값을 결정할 것이다.

### 레코드 경계
- TCP는 송신자가 작성한 바이트 수와 수신자가 한 번에 읽는 바이트 수가 반드시 같을 필요는 없다.
- TCP는 레코드 경계를 매 바이트마다 삽입하지 않는다. 이는 송신 메시지와 수신 메시지가 정확히 일치하는 UDP와 같은 메시지 중심 프로토콜과는 대조적이다.
- 송신자가 바이트 스트림에 레코드 경계를 삽입하여, 수신자가 바이트 스트림을 레코드들로 나누는 방법을 알려주는 데 이용될 수 있는 두 가지의 방법이 있다.
- 첫 번째 기법은 TCP 헤더에 UrgPtr 필드와 URG 플래그에 의해 구현되는 긴급 데이터 기능이다. 원래 긴급 데이터 기법은 송신 애플리케이션이 상대방에게 out-of-band 데이터를 보낼 수 있도록 설계되엇다. out-of-band는 정상적인 데이터 흐름으로부터 분리된 데이터를 의미한다. out-of-band 데이터는 UrgPtr 필드를 이용하여 세그먼트 내에 명시되고, 도착하자마자 수신자 프로세스에게 전달된다. 이는 순서번호가 앞선 데이터보다 먼저 송신되어도 마찬가지이다. 그러나 시간이 지남에 따라 이 기능은 사용되지 않고 긴급 데이터를 표시하는 대신, 레코드 표시자와 같은 특수 데이터를 표시하게 되었다. 이러한 용도의 중요성은 송신 프로세스가 수신자에게 효과적으로 신호를 보낼 수 있다는 사실이다.
- 두 번째 기법은 end-of-record 표시를 바이트 스트림에 삽입하는 push 연산이다. 원래 이 기법은 송신자 프로세스가 TCP로 하여금 모아 놓은 모든 데이터를 상대방으로 보내라고 명령할 수 있도록 설계되었다. 그러나 애플리케이션이 수행될 때 송신측에서 데이터가 버퍼링되었는지를 알려야 하기 때문에, push는 레코드 경계를 구현하는데 사용될 수 있다. 선택적으로, 목적지에서의 TCP는 유입되는 세그먼트가 PUSH 플래그가 설정되어 있을 때마다 애플리케이션에게 알려야 하며, 수신측에서 이 기능을 지원한다. 따라서 push연산은 TCP 스트림을 레코드들로 나누기 위하여 사용될 수 있다.
- 애플리케이션 프로그램은 TCP로부터의 도움없이 언제나 데이터 경계를 삽입할 수 있다.

### TCP 확장
- TCP 확장은 가능한 TCP에 영향을 적게 미치도록 설계되었다. 특히 확장성은 TCP 헤더에 추가될 수 있는 옵션으로 구현되었다. 이러한 이유는 호스트들이 옵션 기능을 수행하지 않고도 TCP를 이용하여 통신할 수 있기 때문이다. 그러나 옵션 기능을 수행하는 호스트들은 확장된 기능을 이용할 수 있다. 양측은 TCP 연결시에 옵션 기능 사용을 합의한다.
- 확장성 첫 번째는 TCP의 타임아웃 기법을 향상시키도록 도와준다. TCP는 세그먼트를 전송할 때 시스템 클럭을 읽을 수 있고, 이 시간(32비트 타임스탬프로 간주)을 세그먼트 헤더에 포함시킨다. 수신자는 송신자에게 응답하는 ACK 내에 이 타임스탬프를 돌려주게 되고, 송신자는 현재 시간에서 이 타임스탬프 값을 빼서 RTT를 계산하게 된다. 타임스탬프 옵션은 세그먼트가 전송될 때의 레코드를 TCP가 저장하기 쉬운 장소를 제공하는 것이다. 즉, TCP는 세그먼트 내에 시간을 저장한다. 타임스탬프가 연결의 동일한 쪽에서 쓰거나, 읽혀지기 때문에 양단 간의 클럭 동기화가 필요없다.
- 두 번째는 TCP의 32비트 SequenceNum 필드가 고속 네트워크에서 중복되는 문제점을 해결하기 위하여 32비트 타임스탬프를 사용한다. TCP는 세그먼트를 받아들이거나, 거부할지를 하위 32비트의 SequenceNum 필드와 상위 32비트의 타임스탬프를 가진 64비트 식별자에 기반한다. 타임스탬프는 항상 증가하기 때문에 동일한 순서번호를 가진 두 개의 각기 다른 값으로 나타내는 기능을 충족시킨다. 
- 세 번째는 TCP가 큰 윈도우를 알리게 하고, 따라서 TCP가 고속 네트워크에 의하여 만들어지 질지도 모르는 `지연 * 대역폭`만큼의 파이프를 더 많이 채우도록 한다. 이 확장성은 윈도우를 알리기 위한 `비례 인자`를 정의하는 옵션과 관련이 있다. 즉, 송신자가 ACK를 받지 못하는 바이트가 얼마나 되는지를 나타내는 AdvertisedWindow 필드 내에 나타나는 숫자를 해석하기보다는 두 TCP 양 단이 더 큰 AdvertisedWindow 필드를 셀 수 있는 협상이 가능하게 한다. 즉, 윈도우 scaling 옵션은 각 측에서 얼마나 많은 비트들이 효과적인 윈도우를 계산하기 위하여 TCP의 내용물을 사용하기전에 AdvertisedWindow 필드를 left-shift할 수 있는지를 규정한다.

### 설계 방법의 대안
- TCP는 스트림 기반의 프로토콜이고 RPC는 요구/응답 프로토콜이다. 둘다 트랜스포트 프로토콜의 종류이다.
- 특별한 환경에서는 TCP 혹은 RPC가 효율적인 경우가 존재한다.
