# 종단 간 프로토콜

## 트랜스포트를 위한 리얼타임 애플리케이션
-  애플리케이션이 정보를 전달하는 데 적절한 시간에 도착해야 한다는 요구가 클 경우에 이를 리얼타임이라고 부른다.
-  멀티미디어 애플리케이션은 두가지 클래스로 나눌수 있다. `인터렉티브`와 `스트리밍`이다.
-  RTP는 리얼타임 애플리케이션이 사용하는 프로토콜이다. RTP는 많은 아래 계층 프로토콜 위에서 실행되나, 공통적으로 UDP 위에서 실행된다. UDP 최소의 기능을 제공하며 포트 수에 기반을 두는 기본적인 역다중화는 RTP가 시작하는 점에 필요한 것과 같다. 그래서 RTP에서 포트 수를 새로 만드는 것보다 역다중화 함수를 사용한다.

### 요구사항
- 멀티미디어 프로토콜의 가장 기본적인 요구사항은 비슷한 애플리케이션끼리의 상호 작용을 가능하게 하는 것이다. 이는 즉 애플리케이션들이 서로 같은 보이스 인코딩과 압축 방법을 사용해야 한다는 것이다. 송신자가 수신자에게 어떤 보이스 코딩 방법을 사용할지에 대해 협상하는 프로토콜이 제공되어야 한다.
- RTP가 제공하는 첫 번째 공통된 기능은 코딩 방법의 선택을 전달할 수 있게 하는 것이다. 이는 또한 어떤 종류의 애플리케이션(오디오/ 비디오)인지 구분할 수 있게 한다.
- RTP 요구사항으로 중요한 또 한가지는 데이터 스트림을 받는 쪽에서 받아진 데이터들 간의 시간적인 관계를 아는 것이 가능해야 한다. 네트워크를 통해 전송되는 데이터 스트림에서 발생하는 지터 값을 부드럽게 하기 위하여 리얼타임 애플리케이션은 받은 데이터를 `플레이백 버퍼`에 저장하는 게 필요하다. 받는 쪽에서 적당한 시간에 재생하는 것을 가능하게 하기 위하여 데이터의 타임스탬프가 필요하다.
- 단 하나의 미디어 스트림의 타이밍은 다양한 미디어를 동기화하는 문제를 가진다. 
- 또 다른 중요한 기능은 패킷 손실의 표시이다. 지연값과 관련이 많은 애플리케이션은 TCP와 같이 신뢰성 있는 수송을 이용할 수 없다. 왜냐하면 손실을 수정하기 위한 데이터의 재전송으로 인해 패킷이 너무 늦게 도착할 수 있기 때문이다. 따라서 애플리케이션이 손실되는 패킷을 다룰 수 있어야 한다. 이것의 첫 시작은 손실되고 잇다는 사실을 알아야 한다는 것이다.
- 일반적으로 멀티미디어 애플리케이션은 TCP 상에서 돌아가지 않기 때문에 TCP의 특징인 혼잡 제거도 불가능하다. 그러나 많은 멀티미디어 애플리케이션은 혼잡에 대해 응답이 가능하다. 예를 들어, 오디오/비디오 코딩 알고리즘의 매개변수들을 고침으로써 소비되는 대역폭을 줄일 수 있다. 이 일을 명확히 하기 위해서, 수신자가 송신자에게 손실이 발생하는 것을 통지하여 송신자가 코딩 매개변수를 조정할 수 있게 한다.
- 멀티미디어 애플리케이션들의 또 다른 공통도니 함수는 프레임의 경계를 표시하는 것이다. 이 문맥 안에서의 프레임은 애플리케이션 특성이다. 예를 들어, 어떤 종류의 패킷 한 묶음이 어떠한 단일 프레임에 해당한다고 비디오 애플리케이션에게 알려 주는 것이 도움이 될 수 있다.
- 프로토콜에 포함시킬 마지막 기능은 IP 주소보다 더 사용하기 쉬운 송신자 확인 방법이다. 이러한 애플리케이션 프로토콜은 문자열과 데이터 스트림 간의 연결을 지원해야 한다.
- 추가적 요구사항으로는 각 패킷 안에 추가적인 비트를 추가하여 긴 형태의 헤더로 보내지 않음으로 능률적인 대역폭을 사용할 수 있도록 해야한다. 그 이유는 멀티미디어 데이터의 가장 공통적인 타입인 오디오 패킷은 샘플에 패킷들이 채워지는 시간을 줄이기 위하여 크기가 작아야 하기 때문이다. 긴 오디오 패킷은 패킷화하는데 긴 지연을 발생시킨다. 
- 이것이 ATM 셀의 길이를 선택하는 데에 하나의 요인이 되었다는 것을 생각해 낼 수 있다. 데이터 패킷 자체는 짧으나 긴 헤더에 의해 상대적으로 많은 양의 링크 대역폭이 사용된다. 따라서 유용한 데이터를 위한 유효한 수용량을 감소시킨다.

###  RTP 세부사항
- RTP라는 프로토콜은 IETF에서 개발하여 널리 쓰이고 있다. RTP 표준은 실제로는 RTP와 리얼타임 트랜스포트 컨트롤 프로토콜(RTPC)의 쌍으로 이루어져 있다. 
- RTP는 멀티미디어 데이터를 교환하는 데 쓰이고, RTPC는 특정 데이터 흐름과 관련된 컨트롤 정보를 주기적으로 보내는 데 쓰인다. UDP 상에서 돌아갈 때 RTP 데이터 스트림과 관련된 RTCP 컨트롤 스트림은 트랜스포트 단의 연속된 포트를 사용한다. RTP 데이터는 짝수의 포트번호를 사용하고 RTCP 컨트롤 정보는 이 보다는 큰 홀수의 포트번호를 사용한다.
- RTP가 다양한 종류의 애플리케이션을 지원하기 위해 설계되었기 때문에, 새로운 애플리케이션을 개발할때 RTP 프로토콜 자체를 반복적으로 수정할 필요 없게 RTP는 유연한 메커니즘을 제공한다. 
- 오디오와 같은 각각의 애플리케이션 종류마다 RTP는 `프로파일`과 하나 이상의 `포맷`을 정의한다. 프로파일은 해당 애플리케이션 클래스를 위한 RTP 헤더 내의 공통된 항목에 대한 정보를 제공한다. 포맷 명세는 RTP 헤더 뒤에 나오는 데이터를 어떻게 해석해야 하는지 설명한다.

#### 헤더 포맷
- RTP 헤더의 첫 12바이트는 항상 존재하나 그 안의 소스 구분자는 특정 환경에서만 쓰인다. 이것의 뒤에는 헤더 옵션으로 확장될 수 있다. 그 후에는 애플리케이션에 의해 결정되는 포맷인 RTP 페이로드가 있다. 이것의 목적은 다른 종류의 많은 애플리케이션에 의해 쓰이는 필드만을 포함하는 것이다. 왜냐하면 하나의 애플리케이션에만 특정되는 것들은 그 애플리케이션만을 위한 RTP 페이로드에 넣는게 효율적이기 때문이다.
- RTP 헤더의 처음 2비트는 버전 구분자이다. 다른 비트는 RTP 페이로드가 어떠한 이유로 추가되었을 경우 설정되는 패딩(p) 비트이다. 예를 들어, RTP 데이터에 암호 알고리즘에 의해 필요한 특정 크기의 블록이 추가될 수 있다. 이러한 경우에 RTP 헤더, 데이터 및 패딩의 전체 길이는 UDP 헤더와 같이 아래 계층 프로토콜의 헤더에 의해 전달되어지고 패딩의 마지막 바이트에는 몇 바이트가 무시되어야 하는지 포함한다. 이러한 방법의 패딩은 RTP 헤더 안의 길이 필드가 필요없게 된다. 따라서 헤더를 짧게 유지하는 목표를 이룰수 있다. 패딩이 없는 일반적인 경우에는 길이는 아래 계층 프로토콜에서 추론된다.
- 확장(x) 비트는 특정 애플리케이션을 위해 정의되었고 메인 헤더 뒤에 나오는 헤더의 확장된 부분을 가리킨다. 이러한 부분은 특정 애플리케이션을 위해 페이로드 포맷의 일부분에 페이로드에 특정한 헤더를 정의할 수 있기 때문에 잘 쓰이지 않는다.
- 확장 비트 다음 4비트에는 기여 소스가 헤드 안에 잇다면 그것의 수를 세는 필드가 있다. 기여하는 소스(CSRC)는 다수의 RTP 스트림이 믹서를 통할 때에만 쓰인다. 믹서는 많은 소스로부터 데이터를 받아서 하나의 스트림으로 보내는 툴의 대역폭 요구사항을 줄이는데 쓰인다.
- 프레임을 가리키는 것은 마커 비트에 의해 제공된다. 패킷 안에 어떤 종류의 멀티미디어 데이터가 있는지를 표시하는 7비트의 페이로드 타입 필드가 있다. 이 비트를 애플리케이션이 사용하는 한 가지 경우는 네트워크의 리소스의 가능성이나 애플리케이션 품질에 대한 정보에 기반을 두어 한 가지 코딩 기법에서 다른 기법으로 스위칭할 경우이다. 마커 비트와 페이로드 타입의 정확한 사용법은 애플리케이션 프로파일에 의해 결정된다.
- 일반적으로 페이로드 타입은 데이터를 다른 애플리케이션으로 또는 한가지 애플리케이션안에서 다른 스트림으로 역다중화하는 키로 사용되지 않는다. 왜냐하면 역다중화는 전형적으로 UDP와 같은 아래 계층에서 제공된다. 따라서 전형적으로 RTP를 이용하는 두 개의 미디어 스트림은 다른 UDP 포트 번호를 사용한다.
- RTP 스트림을 받는 쪽에서 손실되거나 순서가 뒤바뀐 패킷을 찾을 수 있게 순서 번호가 사용된다. 단순히 송신자가 전송되는 각 패킷의 순서번호를 하나씩 증가시킨다. 재전송을 통해 손실을 바로 잡고 윈도우 크기를 줄일 수도 있는 혼잡 표시를 통해 손실을 분석하는 TCP와는 반대로 RTP는 손실된 패킷을 감지했을 때 아무 일도 하지 않는다. 오히려 이러한 결정은 애플리케이션에 많이 의존하기 때문에 패킷이 손실되었을때 어떤 일을 해야 하는 지는 애플리케이션이 한다.
- 타임스탬프 필드의 기능은 수신자가 샘플들을 적절한 인터벌로 재생하고 다른 종류의 미디어 스트림을 동기화하는 것을 가능하게 한다. 왜나하면 RTP 자체로는 측정되는 타임의 유닛을 구체화하지 않고 다른 종류의 애플리케이션은 다른 타이밍 정밀도를 요구하기 때문이다. 대신 타임스탬프는 단지 틱의 수이며, 틱 사이의 시간은 사용하는 인코딩에 의존적이다. 클럭 정밀도는 애플리케이션의 RTP 프로파일이나 페이로드 포맷에 구체화된 세부사항의 하나이다. 
- 패킷 안에 있는 타임스탬프 값은 패킷 안의 샘플이 처음으로 만들어진 시간을 말한다. 타임스탬프는 시각을 반영하지 않고 단지 타임스탬프들 간의 차이만이 관련이 있다.
- 동기화 소스(SSRC)는 32비트로 이루어져 있고 RTP 스트림의 하나의 소스를 단독적으로 구분한다. 소스 구분자를 소스의 네트워크나 트랜스포트 주소외의 것으로 사용하여 RTP는 낮은 계층 프로토콜로부터의 독립을 보장한다. 그리고 하나의 노드에 여러 소스들을 가능하게 하고 그 소스들을 구분 가능하게 한다. 하나의 노드가 오디오/비디오 같이 다른 미디어 스트림을 발생시키면 RTCP 메커니즘이 인터미디어 동기화를 가능하게 하므로 각각의 스트림에 같은 SSRC를 사용할 필요가 없다.

### 컨트롤 프로토콜
- RTCP는 멀티미디어 애플리케이션을 위한 데이터 스트림과 관련된 컨트롤 스트림을 제공한다. 이 컨트롤 스트림은 애플리케이션과 네트워크의 성능에 대한 피드백으로 하고, 같은 송신자로부터 나온 다른 미디어 스트림들을 서로 관련짓고 동기화하는 방법을 제공한다. 마지막으로 사용자 인터페이스로 송신자의 신원을 나르는 방법을 제공한다.
- 성능에 대한 피드백 기능은 속도에 적응 가능한 애플리케이션에 유용할 수 있다. 혼잡을 줄이기 위하여 더욱 강한 압축 방법을 사용하거나 혼잡이 적을 경우에는 더 질좋은 스트림을 보내는 데 성능 데이터를 사용할 수 있다. 또한 이는 네트워크 문제를 진단하는 데 유용할 수 있다.
- RTP의 소스 ID 동기화로 동기화 기능을 제공할수 없다. 한 가지 노드에서 다수의 소스는 각기 다른 SSRC 값을 가질 수 있다. 게다가 같은 노드에서 오디오/ 비디오 스트림이 같은 SSRC 값을 가져야 한다는 요구사항이 없다. SSRC 값들 간에 충돌이 일어날 수 있기 때문에 스트림의 SSRC 값을 바꾸는 것은 필요하다. 이러한 문제를 다루기 위해 RTCP는 `발신자에게 부여된 기준 이름(CNAME)`을 사용한다. 그리고 RTP 메커니즘을 이용하는 송신자에 의해 사용될지 모르는 다양한 SSRC 값과 연관 짓는다.
- 단순히 두 스트림을 연관 짓는 게 인터미디어 동기화에서의 한가지 문제이다. 왜냐하면 다른 스트림은 완전히 다른 클럭 정밀도와 다른 양의 부정확성 또는 드리프트를 갖기 때문에 스트림들을 정확하게 동기화 시키는 방법이 필요하다. RTCP에서 이 문제를 다룬다.
- RTCP는 다른 종류의 패킷들을 다음을 포함하여 정의한다. 송신자 레포트는 액티브한 송신자들이 세션에 전송과 수신의 통계를 보고할 수 있게 한다, 수신자 레포트는 송신자가 아닌 수신자들은 수신 수치를 보고하는 데 사용한다, 소스 설명서는 CNAME과 다른 송신자의 정보를 가지고 있다, 애플리케이션에 특정한 컨트롤 패킷
- 이러한 다른 종류의 RTCP 패킷은 앞에서 설명된 전형적인 낮은 계층 프로토콜인 UDP에서 보내진다. 몇가지 RTCP 패킷은 하나의 낮은 레벨 프로토콜인 PDU 안에 포장될 수 있다. 적어도 두 개의 RTCP 패킷이 모든 낮은 레벌의 PDU 안에서 보내져야 한다. 이들 중에 하나가 레포트 패킷이다. 다른 하나는 소스 설명서 패킷이다. 다른 패킷들은 낮은 계층 프로토콜에 의해 부여된 제한 크기까지 포함될 수 있을 것이다.
- 멀티미디어 그룹의 모든 멤버들이 정기적인 컨트롤 트래픽을 보내는 것에 대한 잠재적인 문제점이 존재한다. 이것을 통제하지 않는 한 컨트롤 트래픽은 잠재적으로 대역폭을 상당히 소비할 것이다. 
- RTCP는 참가자의 수가 증가하는 만큼 참가자의 주파수를 축소하는 메커니즘 세트가 있다. 이 법칙의 목표는 RTCP의 전체 트래픽의 양이 RTP 데이터 트래픽 중에 전형적으로 5%정도의 작은 퍼센트를 차지하도록 제한을 두는 것이다. 이 목표를 달성하기 위해서는 사용해야 하는 데이터 대역폭의 크기와 참가자들의 수를 알아야 한다. 데이터 대역폭의 크기는 RTP 밖의 기능인 세션관리에서 알 수 있고, 참가자들의 수는 다른 참가자들의 RTCP 레포트로부터 알 수 있다. RTCP 레포트가 아주 느린 속도로 보내질 수 있기 때문에 현재의 참가자들의 수를 대략적으로 밖에 알 수 없으나 이는 충분하다.
- 대부분의 참가자들이 활동 중인 송신자의 레포트를 받기를 원한다는 가정 하에 활동 중인 송신자들에게 더 많은 RTCP 대역폭을 할당하는 것을 권장한다. 참가자가 RTCP에서 얼마큼의 대역폭을 쓸 수 있는지 정해졌다면 그는 적절한 속도로 정기적인 레포트를 보내는 것을 설정한다. 수신자 레포트는 송신자 레포트에 송신자에 대한 추가적인 정보가 있다는 것만을 제외하고 송신자 레포트와 같다. 두 종류의 레포트에는 최근 레포트를 보내는 기간 안에 모든 소스가 보낸 데이터에 대한 정보가 있다.
- 송신자 레포트가 가지고 있는 추가적인 정보는 레포트가 만들어진 실제적인 시간 정보를 가지는 타임스탬프, 레포트가 만들어진 시간에 대응하는 RTP 타임스탬프, 전송이 시작된후 송신자가 보낸 패킷의 수와 바이트의 합이다. 두 타임스탬프는 다른 미디어 스트림을 동기화시키는 데 사용된다. 이들 스트림이 RTP 데이터 스트림 안에서 다른 클럭 정밀도를 가지더라도 시간정보를  RTP 타임스탬프로 바꾸는 기능이 있으므로 가능하다.
- 송신자와 수신자 레포트는 둘다 마지막 레포트 다음으로 받은 소스에 대한 데이터 블록을 가지고 있다. 각 블록은 소스와 관련된 다음의 통계들을 가지고 있다. 소스의 SSRC, 마지막 레포트가 보내진 뒤로 이 소스에서 보내진 데이터 패킷 중 손실된 조각 수, 소스로부터 처음 들은 뒤로부터 손실된 패킷의 총 갯수, 이 소스로부터 받은 가장 큰 순서번호, 소스의 예상되는 도착 간격 지터, 이 소스가 RTCP를 통해 받은 마지막 실제 타임스탬프, 이 소스가 RTCP를 통해 받은 마지막 송신자 레포트 떄부터의 지연
- 이러한 정보를 받은 이는 세션의 상태에 대한 몯느 것들을 알 수 있다. 특히 다른 수신자들이 자신보다 더 좋은 질로 받고 있는지 알게 되며 이를 통해 자원 예약과 주의해야 할 네트워크의 문제에 대해 알 수 있게 된다. 그리고 송신자가 많은 수신자들이 많은 패킷을 손실하고 있다는 것을 알게 되면 그는 보내는 속도를 줄이거나 손실에 강한 코딩 기법을 써야한다.
- RTCP에서 소스 설명 패킷에는 최소한 송신자의 SSRC와 CNAME이 들어있다. CNAME은 미디어 스트림을 발생시키는 모든 애플리케이션이 동기화를 필요로 할 수 있다는 것에서 유래된다. CNAME의 가장 일반적인 형태는 `user@host`이고 여기서 host는 송신 기계의 전체 주소 도메인 이름이다. 이 표현에서 쓰이는 많고 다양한 바이트들은 SSRC의 형식에는 맞지 않는다. 왜냐하면 SSRC는 모든 패킷과 함께 리얼 타임으로 처리되어야 하기 때문이다. CNAME이 주기적인 RTCP 메시지 안의 SSRC 값에 제한하여 SSRC의 형식이 간결하고 효율적이게 된다. 사용자의 실제 이름과 이메일 주소와 같은 아이템들이 소스 설명 패킷에 포함될 수 있다.
