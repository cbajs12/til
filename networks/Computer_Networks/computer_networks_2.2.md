# 직접 링크 네트워크
- 링크 계층 프로토콜에 관한 것들이다.

## 프레이밍
- 노드가 프레임을 교환할 수 있도록 해주는 것은 네트워크 어댑터이다.
- 노드는 자신의 어댑터에게 메모리로부터 프레임을 전송하라고 명령한다.
- 프레임이 어디서 시작하고 끝나는지를 알아내는 것이 어댑터가 해결해야 할 중요문제다.

### 바이트 중심 프로토콜
- 각 프레임을 비트의 묶음이 아닌 바이트의 묶음으로 간주하는 방법
- BISYNC, PPP등이 있다.
- 두 프레임 형식 모두 전송 오류를 감지하는데 CRC 필드를 사용한다.

#### BISYNC
- 어디서 프레임이 시작하고 끝나는지를 표시하기 위해 보초 문자라고 불리는 것을 사용한다. (보초 문자 방식)
- 프레임의 시작은 SYN문자를 보내는 것으로 표시된다. 다음으로 데이터 부분은 STX, ETX사이에 둘러싸인다. 그리고 SOH는 STX필드와 같은 목적으로 사용된다.
- 문제점은 프레임의 데이터 부분에 ETX문자가 나올수 있다. 이 문제를 프레임 몸체에 ETX 문자가 나올때마다 DLE 문자를 앞에 붙여 확장된다(c의 문자안에 따옴표올때 `\`를 쓰는 것과 같다) 

#### PPP
- Flag 필드의 텍스트 시작을 나타내는 특수문자는 `01111110`이다.
- Protocol 필드는 역다중화에 사용되며, IP같은 상위 수준 프로토콜을 식별한다.
- Address, Control필드는 대개 디폴트값을 가진다, Payload의 길이는 변동이 있지만 디폴트값은 1500바이트이다.
- Checksum필드는 CRC의 한 종류이며 2 또는 4바이트이다.
- PPP 형식은 몇몇 필드의 길이들이 고정되어 있지 않고 협상에 의하여 조절된다.
- LCP는 제어 메시지를 PPP 프레임으로 포장하여 보내지는데, 이때 PPP 프레임의 Protocol 필드는 LCP 식별자를 가진다. LCP는 제어 메시지 안에 있는 정보를 토대로 PPP의 프레임 형식을 조정한다.

#### DDCMP
- 프레임에 포함된 바이트 수를 프레임 헤더의 한 필드로 포함
- COUNT 필드는 프레임 몸체에 포함되어 있는 바이트 수를 규정
- 문제점은 전송 오류가 COUNT 필드를 변질 시킬수있다. 이럴때 오류 감지 필드를 사용하여 프레임이 잘못되었다는 것을 결정한다. (프레이밍 오류)

### 비트 중심 프로토콜
- 프레임을 단순히 비트의 묶음으로 간주한다.
- SDLC, HDLC등이 있다.

#### HDLC
- 시작과 끝 모두를 특정한 비트 순서인 `01111110`으로 나타낸다. 이 비트 순서는 링크가 유휴 상태일때 송신자와 수신자가 클럭을 동기화하기 위해서도 교환된다. 이 경우, 보초 방식을 사용한다.
- 이 특정 순서가 프레임 몸체의 어떤 곳에서도 나오게 된다면, 바이트 중심의 DLE 문자와 같은 비트 삽입 방식을 한다.
- 비트 삽입: 송신자가 메시지에서 5개의 1을 연속하여 보낸 경우 다음 비트를 보내기 전에 0을 삽입하여 전송한다. 수신자는 5개의 1이 도착한후 다음 비트가 0이면 제거하고 1이면 프레임 끝을 나타내거나 오류가 발생한 것이다. 이 경우에는 그 다음 비트를 보고 구분할 수 있다. 다음 비트가 0이면 프레임 끝 표시의 경우이다. 1이면 오류가 발생한 것으로 모든 프레임을 버린다.

### 클럭 기반 프레이밍
- 보초값의 확장방법과 비트 삽입 방법 모두 프레임의 길이가 payload로 전송되는 데이터에 의하여 결정된다.
- SONET 링크가 있다.
- SONET의 각 바이트는 NRZ를 사용하여 인코딩 된다. 그러나 수신자가 송신자의 클럭을 복구할 수 있도록 데이터 바이트는 스크램블된다.
- 스크램블 : 전송할 데이터와 알려진 비트 패턴을 사용하여 XOR을 계산함으로써 수행
- STS-N은 N개의 STS-1 프레임으로 구성된다고 생각하면 된다.

#### STS-1 (SONET 링크 중 하나)
- 프레임은 각각이 90바이트인 9개의 행으로 배열되어 있으며, 각 행의 처음 3바이트는 오버헤드, 나머지는 데이터가 사용한다.
- 오버헤드의 처음 2바이트는 특정 비트 양식을 포함하여 프레임의 시작점을 알린다. 그러나 이 비트양식이 데이터 부분에서 나올수있기 때문에 수신자는 특정 비트 패턴을 일정하게 검사한다. 프레임의 크기가 정해져 있기 때문에 특정 패턴이 시간적으로 정확한 위치에서 나오면 동기화가 이루어졌다고 판단한다.

## 오류 검출
- 순회 중복 검사(CRC)는 전송 오류를 검출하는 데 가장 많이 사용하는  기술
- 모든 오류 검출 방법이 가진 기본적인 개념은 오류가 발생했는지를 결정하는데 사용될 수 있는 중복 정보를 프레임에 추가하는 것. 추가로 보내는 비트들은 메시지에 새로운 정보를 추가하는 것이 아닌 알고리즘을 통하여 기존 메시지에서 제작하는 것이다. 
- 송신자와 수신자가 같은 알고리즘으로 메시지에서 같은 오류 검출 코드를 추출해야 하는 것이다.
- 체크섬: 코드를 생성하는 알고리즘이 덧셈에 기초를 하고 있는 경우에 부르는 오류 검출 코드
- 오류 검출에 따른 대처는 두가지가 있다. 검출만 한다면 메시지를 버리고 송신자에게 또 다른 복사본을 요청한다. 또다른 방법은 오류를 수정하는 것인데 오류를 수정하려면 항상 많은 중복 비트를 보내야 한다. 그래서 오류 수정은 오류 발생 확률 높거나(무선), 재전송 비용이 클때(위성) 많이 사용한다.

### 2차원 패리티
- 단순 패리티는 7비트 코드에서 한 바이트에 있는 1의 비트에 패리티 비트를 추가한다. 홀수 패리티에서는 바이트에 있는 1의 개수를 홀수, 짝수 패리트는 바이트에 있는 1의 개수를 짝수로 한다.
- 프레임에 포함된 바이트를 뛰어넘어 각 비트 위치에 대해 유사한 계산을 한다. 각 바이트에 대한 패리티 비트에 덧붙여, 이 결과를 전체 프레임에 대한 별도의 패리티 바이트로 설정한다.
- 예를 들어, 2차원 짝수 패리티는 6바이트 프레임의 경우, 각 바이트의 패리티 비트를 총합 짝수개의 1을 가져야 한다.

### 체크섬 알고리즘
- 링크 레벨에서 사용되지 않는 알고리즘이다.
- 전송되는 모든 데이터를 워드 단위로 더하고, 그합의 결과를 전송하는 것이다. 수신자는 수신 데이터에 대해 같은 계산을 하고 체크섬과 비교를 한다.
- 이것은 1의 보수 연산을 통한 덧셈 계산을 하므로 약한 보호를 제공하지만 소프트웨어로 구현하기 간단하여 종단간의 프로트콜에서 마지막 방어선 역할을 한다.

### CRC
- CRC의 이론적 근거는 유한 필드라는 수학 영역에 뿌리를 둔다.
- n차 다항식으로 표현되는 식에 n+1 비트의 메시지가 각 항의 상수가 되는 것이다. (`1110 이면, 1*x3+1*x2+1*x+0`) 
- CRC는 송신자와 수신자가 제수 다항식 C(x)에 서로 동의 하여야 한다. (예로, C(3) = x3+x2+x1)
- 송신자가 n+1 비트의 길이 메시지 M(x) 전송시에, 실제로 전송되는 것은 n+1에 k비트를 더한 것이 보내진다.
- 수신자는 모듈로 연산을 통하여 수신된 메시지로 부터 오류를 검출한다.
- 링크 계층 프로토콜에서는 이미 지정된 6개의 C(x)가 사용된다. CRC-32, CRC-CCITT등이 존재한다.
- CRC 알고리즘은 시프트 레지스터로 간단하게 구현될수 있다.
