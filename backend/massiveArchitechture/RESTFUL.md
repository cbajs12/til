## REST 아키텍쳐

### 기본
- Idempotent(멱등성): 여러번 수행해도 결과가 같은 경우
- Stateless(상태 유지하지 않음)가 특징중 하나, 클라이언트의 컨텍스트(Http 세션)를 서버쪽에 유지하지 않는다는 의미(상태 정보를 저장하지 않는다)
- HTTP의 리소스들을 웹 캐시 서버 등에  캐싱(HTTP 프로토콜 표준에서 사용하는 Last-Modified / E-Tag를 이용)
- REST 서버는 API를 제공하고 제공된 API를 이용해서 비즈니스 로직 처리 및 저장 책임, 클라이언트는 사용자 인증이나 컨텍스트(세션, 로그인 정보)를 관리하고 책임지는 역할

### 디자인
- REST API를 URI만 보고도 직관적으로 이해할수 있어야 한다. URI 리소스명은 동사보다는 명사를 사용
- 에러 처리는 HTTP 응답 코드를 사용한후 응답 Body에 에러에 대한 자세한 내용을 서술하는 것, 응답코드는 5 ~ 8개 정도를 사용한다.
- 에러 메세지에 에러 스택 정보를 출력하는 것은 내부적인 코드 구조와 프레임 워크 구조를 노출하기 때문에 위험하다.
- HAProxy등의 Reverse Proxy를 이용해서 외부에 노출되는  URL 변경 없이 내부적으로 URL을 각각의 리소스와 맵핑하도록 한다.
- 리소스에 대한 응답 메시지에 대해서 굳이 모든 필드를 포함하지 않고 필도를 제한하는 것은 전체 응답의 양을 줄여서 네트워크 대역폭을 절약하고, 파싱을 간략화할수 있다.

### 문제점
- 기존의 전통적인 RDBS에 적용하기 쉽지 않다, 리소스에 대한 고유한 키를 부여하는 것에 여러가지 에러 사항이 있다. 이에 대한 대안으로 대체키를 사용한다. 의미없는 고유한 값을 키로 잡아 DB테이블에 AK라는 필드로 잡아서 사용하는 방법

### 보안
- 네트워크 레벨 암호화:  중간에서 네트워크 통신을 낚아채는 것을 네트워크 프로토콜단에서 처리하는 것, 일반적으로 HTTPS기반의 보안 프로토콜 사용
- 메시지 무결성: 메시지가 중간에 변조가 되지 않게 방지하는 것, 메시지에 대한 서명(Signature)을 생성해서 메시지와 같이 보내고 검증하는 방식
- 메시지 본문 암호화: 전체 메시지를 암호화, 특정 필드만 암호화하는 방법등이 있다.

#### 인증
- API 키 방식: 특정 사용자만 알 수 있는 일종의 문자열, API 키를 발급받고 API를 호출할때 API키를 메시지 안에 넣어 호출

##### API 토큰 방식
- 사용자 인증 후에 그 사용자가 API 호출에 사용할 기간이 유효한 API 토큰을 발급해서 API 토큰으로 사용자를 인증하는 방식
- HTTP Basic Auth: 문자열을 Base64 인코딩을 해서 'Authorization'이라는 이름의 헤더로 서버에 전송하여 인증을 요청, 중간에 패킷을 가로채서 디코딩될 위험이 있기 때문에 HTTPS 프로토콜을 사용해야 한다.
- Digest Access Authrentication: 클라이언트가 인증을 요청할 때 클라이언트가 서버로부터 nonce이라는 일종의 난수 값을 받고, ID와 비밀번호를 이 난수 값을 이용해서 해시화하여 서버로 전송하는 방식, MD5 해시는 사전공격(해시된 값과 원래 값을 저장해 두고 해시 값으로 원본 매시지를 검색하는 방식)에 취약하다. SHA-1이상의 해시 알고리즘을 사용하도록 권장
- 클라이언트 인증 추가: API 토큰을 발급받을때, Client ID, Secret을 이용하여 클라이언트 앱을 인증하고 사용자를 인증하여 API 액세스 토큰을 발급
- 제3자 인증(OAuth 2.0) 방식: 서비스가 API 서비스 제공자들이 가진 사용자 데이터를 통하여 인증을 하는 시스템, 이 인증을 사용하는 서비스는 사용자 데이터에 대한 내용을 받지는 못한다. access_token은 랜덤 문자열로, 토큰 자체에는 특별한 정보를 가지고 있지 않은 일반적인 스트링 형태, 이를 이용하여 서버 입장에서 사용자와 연관된 권한을 구별하여 허용해주는 구조
- IP 화이트 리스트를 이용한 터널링: 특정 API URL에 들어오는 IP 주소를 화이트 리스트로 유지하는 방법, 서버간의 통신에 많이 사용, API 서버 앞단에 웹 서버를 배치하여서 사용
- Mutual SSL: 클라이언트에도 인증서를 놓고 양방향으로 SSL을 제공하면서 API호출에 대한 인증을 클라이언트의 인증서를 이용하는 방식

##### JWT 방식
- Claim 기반 토큰의 개념: 토큰안에 서비스를 호출한 사용자에 대한 추가 정보를 넣는 방식, 토큰을 생성하는 단계에서는 생성된 토큰을 별도로 서버에서 유지할 필요가 없으며 토큰을 사용하는 API 서버 입장에서는 API 요청 검증하기 위해서 토큰을 가지고 사용자 정보를 별도로 계정 시스템등에서 조회할 필요가 없다.
- JSON Claim을 Base64로 인코딩하여 HTTP 헤더에 쉽게 넣을수 있고 파싱과 사용이 쉽다.
- 메시지 무결성을 보장하는 방법중 많이 사용되는 것이 서명이나 HMAC 사용하는 방식
- HMAC방식: 원본 메시지에서 해시 값을 추출하고, 이를 비밀 키를 이용해서 복호화시켜 토큰의 뒤에 붙인다.
- 문제점: 데이터가 많아질수록 토큰의 길이가 길어지면 서 네트워크 대역폭 낭비가 심하다, 한번 발급된 토큰 값을 수정과 폐기가 불가능하여 만료 시간을 명시해야 한다, Claim에 대한 정보를 암호화하지 않아서 정보 누출의 가능성이 있다.

#### 권한 인가
- 클라이언트에 의한 권한처리: 사용자 로그인 정보를 보고 사용자 권한을 조회하고 API를 호출하는 방식
- 게이트웨이에 의한 권한처리: 자바스크립트만으로 권한 할 경우 디버거로 코드수정이 가능하기 때문에 권한 처리 로직을 우회할 수도 있고, API 포맷만 안다면 직접 API를 서버로 호출하여 권한 인가 없이 API를 사용할 수 있다. 그렇기 때문에, API 호출이 들어오면 API 토큰 관리 정보를 이용해 Access Token을 사용자 정보와 권한 정보로 변환하고 접근하고자 하는 API에 대해서 권한 인가를 처리한다. API 별로 API에 접근하고자 하는 필요한 권한을 확인해야 한다. 그러나 API에 따라서 권한인증에 필요한 정보가 HTTP 헤더등에 들어가 있는 경우 일일이 메시지 포맷에 따라 별도의 권한 통제 로직을 게이트웨이 단에서 구현해야 하는 것과 권한 통제를 위해 HTTP 메시지 전체를 일일이 파싱해야 하는 오버로드가 발생
- 서버에 의한 권한처리: API 서버의 비즈니스 로직 단에서 권한 처리를 하는 방식, 각 비즈니스 로직에서 API 메시지를 각각 파싱하기 때문에 API 별로 권한 인가 로직을 구현하기 용이, 권한 인가에 필요한 필드들을 API Gateway에서 변환해서 API 서버로 전달해줌으로써 구현을 간략하게 할수 있다.

##### 네트워크 레벨 암호화
- REST API 보안방법은 HTTPS 보안 프로토콜을 사용하는 방법, 이것만 사용하더라도 메시지 자체를 암호화해서 전송
- 그러나 HTTPS를 사용하더라도 메시지를 낚아채거나 변조하는(중간자 공격)을 당할수 있다. 해커가 API와 클라이언트 사이에 끼어들어 중간에서 인증서를 탈취하여 HTTPS SSL 서버를 만들고 메시지를 변조한다. 이러한 방지 방법은 공인된 인증서를 사용하고 인증서를 확인하는 것이다.

##### 메시지 본문 암호화
- 특정 필드만 애플리케이션 단에서 암호화 하는 방법
- 비대칭 키 알고리즘: 암호화를 하는 키와 암호를 푸는 복호화 키가 다른 경우로, 암호화 하는 키를 공개키, 암호화 푸는 키를 비밀 키라한다. RSA알고리즘이 대표적이고, HTTPS도 이를 사용한다.
- 대칭키 알고리즘: 암호화와 복호화 키가 같은 알고리즘, API 클라이언트와 서버가 같은 키를 알고 있어야 한다. AES256등이 있다.

##### 메시지 무결성 보장
- 서버에서 API 호출을 받았을때 이 호출이 신뢰할 수 있는 호출인지 아닌지를 구별하는 방법을 말한다, 일반적으로 HMAC 방식을 사용, 그러나 메시지를 변경하지 않고 해커가 같은 요청을 반복해서 보낸다면 메시지를 변조하지 않았다는 것으로 서버는 이를 유효한 호출로 인식할 수 있다. 이를 방지하기 위하여 timestamp를 메시지에 해시값과 같이 포함하여 보낸다.
- HMAC을 구현할때 SHA-1 256bit을 널리 사용한다.
- 최소한 API 보안에서는 HTTPS를 이용한 네트워크 보안과 함께 API토큰의 인증 방식을 반드시 사용해야한다.

#### 자바스크립트 클라이언트 지원
- SPA(Single Page Application): 서버와의 통신을 자바스크립트가 직접 XMLHttpRequest 객체를 이용해서 API 호출을 바로 하는 형태
- CORS: HTTP 접근 제어

##### 동일 출처 정책
- 웹 브라우저에서 동작하는 프로그래밍 언어에서 웹 브라우저에서 동작하는 프로그램은 해당 프로그램이 로딩된 위치에 있는 리소스만 접근할수 있다는 정책 해결
- 앞단에 Reverse Proxy를 넣어서 전체 URL을 같게 만들어 주는 방법이 있다.
- 특정 사이트에 대한 접근 허용 방식: API 서버의 설정에서 모든 소스에서 들어오는 API 호출을 허용하도록 하는 것 (ex; Access-Control-Allow-Origin: site.com)
- Pre-flight를 이용한 세세한 CORS 통제: REST 리소스당 섬세한 통제가 필요한 경우 이것을 이용할수 있다. REST 리소스를 호출하기 전에 웹 브라우저가 HTTP OPTIONS 요청을 보내면 해당 REST 리소스에 대해서 가능한 CORS 정보를 보내준다. 웹 브라우저에서는 XMLHttpRequest를 특정 URL로 요청하기 전에 먼저 HTTP OPTIONS를 호출한다. 그러면 서버는 해당 URL에 접근할 수 있는 Origin URL과 HTTP 메서드를 반환해준다. 이러한 CORS 설정은 API 호출 코드에서 직접 구현할 수 있지만 로드벨런서 역할 하는 Reverse Proxy에서 설정에서 처리 가능하다.

##### 자바스크립트 클라이언트를 위한 Access Token 인증 처리
- 자바스크립트 클라이언트는 모바일 앱이나 서버와 같은 다른 API 클라이언트와 비교해서 API Access Token을 안전하게 저장할 방법이 없어 추가 관리 방식이 필요
- API Access Token을 서버에서 발급하여 반환할때, 보안쿠키에 넣어서 반환 한다, HTTPS를 통해서만 가능하고, HTTP_ONLY라는 옵션을 쿠키에 추가하면 자바스크립트를 통해서 읽거나 조작할수 없다.
- API Access Token을 해당 세션에서만 유효하도록 한다. 특정 IP와 시간내에서만 유효하도록 하는것, API가 호출될 때마다 IP와 클라이언트의 Origin을 확인하고, Access Token이 유효시간내이면 유효시간을 연장
