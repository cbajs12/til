## 대용량 서비스 레퍼런스 아키텍처

### 시스템 구조
- 사상적으로 SOA를 기반으로 한다.
- 클라이언트는 API를 사용하여 서버 플랫폼과 통신하여 비즈니스 로직을 처리한다.
- 서버쪽에서는 트랜잭션을 3계층(Access, Business, Persistent layer)을 거쳐 처리한다.
- Access layer: 외부로부터 들어오는 사용자 요청에 대해서 관문 역할하며, 외부 시스템과 연동 역할을 한다.
- Business layer: 사용자 요청에 대해서 비즈니스 로직을 처리하여 응답을 보낸다.
- Persistent layer: 비즈니스 로직에 의해 처리되는 또는 처리된 데이터를 저장하는 역할을 한다.
- Analaysis layer: 시스템에 대한 관리와 운용을 맡은 OAM과 로그 등의 분석을 하는 층

#### Access layer
- 사용자 요청에 대해서 사용자 인증과 권한 인증을 수행하여 비즈니스 로직으로 전달하는 역할을 한다.

##### 웹 캐시
- 웹에서 사용되는 정적인 자원, 자바스크립트등을 캐싱한다.
- 캐시 계층이 있는 것만으로 전체 시스템의 부하를 많이 줄일 수 있다.
- 서비스 지역이 넓을 경우 CDN(Contents Delivery Network)을 이용하는 게 좋다.
- CDN: 분산 웹 캐시 서비스로 세계 여러 곳에 웹 캐시 서버를 배치해놓고 서비스를 하기 때문에 콘텐츠에 대한 로딩 타임을 크게 줄일 수 있다.

##### Reverse Proxy
- 웹 서버의 역할을 하면서 정적 콘텐츠에대한 서비스를 제공하고, 필요에 따라서 HTTP 요청에 대한 인증 역할을 수행한다. HTTP 헤더 내용을 보고 요청을 뒤로 넘길지를 판단한다.
- 인증을 Reverse Proxy나 ESB에서 처리하는 경우에는 HTTP 요청을 기반으로 인증처리 한다. 개별 비즈니스 컴포넌트에서 인증 처리를 할 때에는 분산형 인증 처리가 되기 때문에 하나의 비즈니스 컴포넌트에서 인증한 정보를 다른 비즈니스 컴포넌트에서도 인증이 되었음을 인지할 수 있어야 한다. 이때 SSO(Single Sign On) 기술을 사용한다.
- 뒷단 비즈니스 로직을 처리하는 컴포넌트로 라우팅하는 역할을 한다. 여러개의 인스턴스에 요청을 밸런싱하는 역할을 수행한다.
- Aphache, Nginx, HAProxy같은 것들이 존재한다.

##### API Gateway
- API Gateway 솔루션 혹은 ESB(Enterprise Service Bus)를 사용하는 방법도 있다.
- API Gateway는 REST API 기반의 API를 처리할 수 있도록 최적화되어 있고 ESB에 비해 군더더기가 적다.
- ESB: API Gateway기능을 포함하면서 레거시 시스템이나 다른 프로토콜을 커버할 수 있는 장점이 있다.
- API 키에 대한 발급에서부터 업데이트 파기까지의 생명 주기를 관리한다.
- 단일 엔드 포인트에서 여러 개의 API 서버들로 부하를 분산해주는 역할을 한다, API 서버의 장애를 감지하여 살아있는 서버에만 부하를 보낼수 있다.
- API에 대한 로그 처리나 인증처리 기능들과 같은 API 공통 기능들을 Gateway단에서 통합하여 관리할수 있다.
- 다수의 엔드 포인트(URL)로 API를 제공할 수 있다. 뒷단의 API서버가 두 종류더라도 여러가지의 클라이언트에서의 URL을 지원할수 있다.
- 개발자 포털: API를 외부로 서비스할때 개발자와 소통할 수 있는 인터페이스. 포털은 API 접속 토큰 발급, API 모니터링, API 매뉴얼, API 테스트 베드 제공을 한다.
- 변환 로직: HTTP 프로토콜 기반의 API를 TCP기반의 프로토콜로 변환하거나 JSON 메시지를 XML로 변환한다거나 메시지 교환 패턴(MEP)의 변환을 할수 있다.
- 서비스 버스: API Gateway를 버스 형태로 배치하여 모든 API통신을 이 버스를 통함으로써 통신 토폴로지를 단순화 할수 있다.
- MashUp: 여러개의 API를 묶어서 새로운 API를 만드는 기능, 이 기능이 복잡할때는 Orchestration 계층을 API 서버 단에서 하나 더 두어서 작업하는 것이 API Gateway 성능을 떨어트리지 않는 방법이다.
- Qos 컨트롤: API에 대한 호출을 통제할수 있다. API키별로 호출 횟수를 제한 하거나 특정 사용자에게서 들어온 API 요청을 우선순위로 처리하는 등의 컨트롤이 가능하다.

##### 계정 관리
- IDM(identity management System): 여러 시스템에서 공통된 계정 체계를 사용하고자 만든 독립된 공통 컴포넌트
- 사용자 관리, 계정 생명주기 관리, 로그인 정보관리, 사용자 정보관리, 사용자 역할관리, 계정 정보 프로비저닝(정보가 변경되었을시 변경 정보를 상대 시스템에 전달하는 기능), 접근 제어, 사용자 인증/권한 처리, SSO(SAML, OAuth 2.0), 계정 정보 페더레이션(여러 개의 다른 시스템에 대한 계정을 연결해주는 작업), 타 서비스 연동, 감사(사용자의 시스템 접근 기록)와 리포팅(표나 그래프로 통계 자료를 보여줌)등의 기능들을 가진다.
- 개별 분산 모델: 각각의 독립된 서비스가 다른 계정 체계를 사용하는 경우
- 중앙 집중형 모델: 모든 서비스가 중앙 집중화된 계정 관리 시스템을 사용하는 경우
- 페더레이션 모델: 각 시스템이 별도의 계정 시스템을 사용하지만, 페더레이션을 통하여 계정 간을 연동하여 사용자가 하나의 통합된 계정으로 전체 시스템에 접근하는 구조

##### 시스템 연동
- 대외 시스템 연계 또는 대내 시스템 간의 연동을 수행하는 시스템
- 대내 거래 통합은 내부 시스템 간의 업무를 통합하는 패턴으로 이루어진다.
- 대외 거래 통합은 기업간의 거래를 정의한다.
- 배치 거래는 대용량 데이터를 송신 시스템에서 수신 시스템으로 전송하는 요건, 다른 업부 시스템 간의 거래 정보를 맞추기 위한 배치 거래와 데이터를 분석하여 리포트를 뽑아내는 업무로 나뉜다.
- 인터페이스는 Inbound, Mediation, Outbound가 있다.
- Inbound: 송신 시스템과 연동하여 요청 받고 응답을 송신 시스템에 보낸다. 어댑터(메시지를 읽어들이는 진입점)와 메시지 변환(다른 메시지 형태를 공통적인 데이터 구조로 변형한다)로 구성된다.
- Mediation: 입력된 메시지를 가공하고 중계하는 부분. 라우팅(메시지를 내용에 따라 적절한 수신 시스템으로 라우팅한다), 맵핑(입력된 전문을 수신 시스템에서 요구하는 형태로 매핑하는 작업), MEP로 구성된다.
- Outbound: 처리가 끝난 메시지를 수신 시스템 플랫폼의 네이티브 메시지 형태로 변환 하여 수신 시스템에 전달
- 거래 로그: 송수신 내용을 확인하고 시스템 장애시 시스템과 거래 내용을 맞춰 이를 복구하는데 사용. Logstash등과 같은 로그 수집 브로커를 이용해서 파일이나 RDBMS등 여러 종류 인프라에 거래 로그를 수집할 수 있다.
- 장애에 대한 처리 정책을 Fault-Policy라 하고 인터페이스마다 정의하여 장애를 처리할 수 있도록 한다. 장애가 발견되면 Error-Hosipital에 모아 정책에 따라 처리한다.