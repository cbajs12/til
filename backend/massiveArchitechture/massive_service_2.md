# 대용량 서비스 레퍼런스 아키텍쳐

## Business layer
- 클라이언트로부터 요청을 받아서 DB나 파일에 데이터를 쓰거나 읽어서 비즈니스 로직에 따라서 처리한다.

### 동기 요청 처리
- 요청/응답 형식의 처리로, 일반적인 REST API 서버이다.
- 응답을 받을 때까지 클라이언트가 기다리는 호출 형태를 동기식 호출이라고 한다.
- 애플리케이션 서버를 이용한 API 서버들이 동기 요청 처리에 대당한다 그러나 문제들이 있어서 애플리케이션 서버 플랫폼을 이원화하는 경우가 많다

#### 생산성 문제
- 단순한 CRUD API를 만들어 내려면 많은 시간이 소요된다.
- 자바플랫폼의 경우 여러개의 DB를 묶어서 단일 트랜잭션으로 처리하는 분산 트랜잭션은 XA라는 규격으로 지원해서 복잡한 트랜잭션 관리가 가능하고 여러 프레임워크를 조합하여 복잡한 비즈니스 로직을 구현할 수 있다.

#### 용량 문제
- JEE나 자바 스프링 기반 애플리케이션들은 내부적으로 스레드풀 구조를 사용한다.
- 스레드 풀 구조는 클라이언트의 요청이 오면 스레드를 미리 만들어 놓은 스레드 풀에서 꺼내서 요청을 처리한다. 물리적으로 스레드 풀이 생성할수 있는 스레드 수는 한계가 있다. 즉, 동시에 처리할 수 있는 요청 수에 한계가 있다.
- IO의 효율에서도 클라이언트 요청에 할당된 스레드는 IO작업이 있을경우, IO 응답 대기 상태에서는 스레드 점유하면서 아무 일도 하지않는 비효율성이 발생한다.
- IO상 성능 저하가 있을수 있기 때문에 싱글 스레드 기반의 비동기 서버를 사용하기도 한다. 하나의 스레드만 사용하여 여러 클라이언트에게서 오는 요청을 처리하다가 IO 작업이 있을경우 비동기 IO 방식으로 IO요청을 던지고 다른 작업을 하다가 IO 작업이 끝나면 이벤트를 받아서 처리하는 구조이다.
- 싱글 스레드의 문제점은 CPU를 점유하고 무엇인가 작업을 하고 있을 때는 다른 요청을 처리하지 못한다는 것이다. CPU 사용량이 많은 로직에는 적절치 못하다

#### 하이브리드 플랫폼 활용
- 비즈니스 로직이 복잡한 경우 복잡하고 중요한 API는 자바로 개발하고 일반적인 API들은 스크립트 언어를 이용해서 개발하는 경우가 많다.

#### SN 아키텍처
- 애플리케이션 서버 기반의 동기처리 아키텍처에서 고민해야할 사항에는 확장성과 안정성을 보장하기 위한 SN 아키텍처가 있다.
- 분산 처리 시스템을 구성하는 여러 개의 노드가 서로 종속성을 가지지 않고 독립적으로 작동하는 아키텍처이다.
- 종속성이 없기때문에 이론적으로 노드를 무제한 늘릴수 있으며, 노드 수에 비례하여 전체 시스템의 용량이 늘고, 특정 노드 장애에도 전체 시스템이 영향받지 않는다.
- 노드간의 종속성을 발생시키는 것이 노드간의 공유정보인 상태 정보이다. 웹에서는 HTTP 세션정보가 예가 된다.
- 상태정보는 애플리케이션 서버의 클러스터링 기능을 이용하여 각 노드 간에 복제되는데 이것이 종속성을 유발한다. 이러한 공유 상태 정보를 애플리케이션 서버 단에서 제거하면 SN 아키텍처를 구현할 수 있다.
- 구현 방법으로는 클라이언트에 상태 정보를 저장하는 방법으로 쿠키가 있다. 하지만 쿠키 용량에 한계가 있기 때문에 DB나 Memcached 또는 데이터 그리드 계층, RDBMS등이 대안이 될수 있다.

### 데이터 그리드를 이용한 상태 정보 저장소
- 데이터 그리드(IMDG): 일종의 메모리 클러스터, 여러 개의 서버와 메모리를 연결하여 수십 기가의 메모리 저장소를 만들어 놓고, 이를 애플리케이션 서버에서 접근해서 사용하는 방식
- 주로 캐시나, HTTP세션, 로그인 정보와 같은 상태 정보를 여러 애플리케이션 서버에서 공유하는 등의 용도로 사용
- 서버 간에 클러스터링이 되어 있기 때문에 서버간에 데이터를 상호 복제하고 있어서, 특정 서버가 장애가 나더라도 자동으로 `Fail Over`(장애가 나지 않은 서버가 그 역할을 내려받음)하기 때문에 장애에 대한 고가용성 구조를 가지고 있고, 서버를 추가함으로써 전체 저장 용량을 늘릴수 있는 확장성을 제공한다. 그러나 메모리 클러스터인 만큼 전체 서버가 다운되면 모든 데이터가 날라간다.
- Redis의 경우에는 메모리에 저장된 내용을 주기적으로 디스크에 저장하고, 클러스터링을 통한 확장을 지원하지 않기 때문에 IMDB라고 봐야하지만, 사용이 편리하고 다양한 데이터 모델을 지원해서 자주 사용된다.

### 메시지 큐를 이용한 비동기 처리
- 비동기 처리는 요청을 보낸후 비즈니스 로직이 처리와 완료되지 않은 상태에서 다음 로직을 진행한다.
- 콜백 메시지는 클라이언트에게 비동기로 요청된 작업이 끝났음을 알려주는 호출이다.
- 비동기적 처리는 시간이 오래 걸리는 대규모 작업등에 유리하다.
- 일반적으로 비동기식 패턴 규현에는 메시지 큐를 사용한다. 메시지 큐는 들어온 요청을 쌓아놓는 임시 공간으로 쌓여있는 요청 메시지는 뒷단에서 처리된다.
- Rabbit MQ는 지원되는 기능과 모니터링 기능이 좋고, 사용이 매우 편리하다.
- 아파치 카프카는 데이터를 처리할 양이 많은 시스템의  분산 대용량 큐로 사용된다.
- 비동기식 구현에서 가장 중요한 점은 전달된 요청 메시지가 잘 처리되었느냐이다. 즉, 에러처리에 가장 신경을 써야한다.
- 비즈니스 컴포넌트에서 메시지 처리중 에러가 났을때 해당 메시지를 에러 큐라는 재처리용 큐로 전달 한다. 이후 4가지 방법으로 처리를 할 수있다. 첫 번째는 에러가 발생하면 다시 처리를 시도한다(재처리). 메시지를 처리하는 컴포넌트가 일시적인 장애일 경우에는 효율적으로 사용할수 있다. 최대 재처리 횟수를 지정하고, 일정 시간을 대기하였다가 처리하기를 해야한다. 두번째는 에러난 메시지를 무시하고 없애는 방식이다. 메시지 유실이 허용되는 경우에만 사용한다. 세번째는 관리자에게 알림을 보내서 직접처리 하도록 하는 것이다. 마지막은 자동적으로 처리하지 않고 관리자가 직접 처리할수 있도록 사용자 인터페이스를 제공하는 방법이있다.

#### 비동기 메시지 패턴
- Fire & Forget 패턴: 일반적 패턴으로, 클라이언트가 호출한 후 큐에 메시지가 제대로 들어갔으면, 메시지 처리 결과에 관계없이 응답을 기다리지 않고 바로 반환한다. 큐에 저장된 메시지는 뒷단에서 처리된다.
- Publish & Subscribe 패턴: 메시지 큐에 subscriber를 등록하면 클라이언트에서 보낸 하나의 메시지가 등록된 모든 구독자에게 전달되어 처리된다. 1:N 관계의 비동기 처리를 구현하고자 할때 사용
- Routing 패턴: 큐에 저장된 메시지를 조건에 따라 특정 비즈니스 컴포넌트로 라우팅하는 기능. 특정 메시지는 조건에 따라서 특정 컴포넌트 한개에만 전달
- Call back 패턴: 비즈니스 컴포넌트에서 처리가 끝나면 서버는 다시 클라이언트에 처리가 끝났다는 응답과 함께 결과 메시지를 콜백으로 보낸다. 클라이언트는 서버가 응답 메시지를 보내면 이벤트 핸들러 방식에 의해 응답 메시지를 호출한다.
- 이벤트 핸들러 방식: 이벤트 발생시 처리하는 방법으로 해당 이벤트를 처리하기 위해서 미리 등록된 이벤트 핸들러를 호출하여 이벤트에 대한 처리를 진행

#### 메시지 큐 구성시 고려할 점
- 메시지를 물리적으로 어디에 저장할 것인가를 고려한다. 메모리, 디스크, RDBMS등의 방법이 있다.
- 메모리 과다 사용으로 Out of memory에 주의해야한다. 메모리에 저장할 경우, 메시지가 쌓이게 되면 메모리 부족현상을 일으킬수 있다.
- 높은 신뢰성을 요구하는 시스템은 트랜잭션 지원 기능을 고려해야 한다. 에러메시지를 처리를 하기 위해서는 트랜잭션이 필수적이다.
- 여러개의 메시지 큐를 하나의 클러스터로 묶는 기능을 정의한다. 클러스터링을 통해서 특정 인스턴스 장애시 페일 오버를 할수 있고, 한 대의 서버로 처리할 수 없는 양의 메시지를 여러 대의 서버에서 분산 처리할 수 있다.

### 임시 파일 작업 공간
- 직접 애플리케이션 서버에 네트워크 파일 시스템(NFS)등으로 마운트될 수 있는 파일 시스템으로 작업을 위해서 임시로 파일을 저장하는 공간이다.
- 비동기 절차가 길면 길수록 많은 파일 복사가 발생하게 된다. 이럴 경우 로컬 스토리지로 파일 복사가 생길수 밖에 없는데 이것을 막으려고 임시 작업 공간이 필요하다.
- NFS과 같은 파일 시스템을 둬서 각 서버에 마운트한 후에 직접 이 NFS로 파일을 업로드하고 변환 작업등도 처리 한후에 아카이빙 스토리지로 올린다.
- 분산 환경에서 공유 파일 시스템을 사용할 수 있다. 많은 로그 처리가 있을 경우, 로그 서버가 스케일링되는 것과 상관없이 로그 파일이 공통 파일 시스템으로 모이게 할 수 있다.

### 메시징 프로토콜
- 프로세스 단위로 분리된 컴포넌트 간에는 통신을 하기 위해서 리모트로 호출을 해야 하는데, JSON 기반의 REST를 사용한다. 그러나 HTTP 프로토콜은 비연결형으로 매번 호출때마다 연결을 새로 만들기 때문에 네트워크 오버로드가 크고, JSON 역시 바이너리 파일에 비해 크기가 크고 파싱도 오래걸린다. 외부 제공 API들의 경우 HTTP/REST를 이용해서 가독성과 사용성을 높이지만, 내부 시스템간 호출에서는 바이너리 프로토콜을 사용하는 것이 성능과 용량면에서 효율적이다.
- PR(Google Protocol Buffer): 구글의 메시지 표준 정의 기술 오픈소스, 바이너리 스트림으로 직렬화해주는 프레임워크이다. 직렬화된 바이너리 스트림은 여러 계층을 통해서 전송될 수 있다. 여러가지 전송 채널을 사용할 수 있다.
- Thrift: 페이스북에서 만든 프로토콜, 직렬화는 물론이고 네트워크 전송 단을 함께 포함하여 RPC를 지원한다. 클라이언트에서 서버의 함수를 네트워크를 통해서 호출할 수 있다. 이를 통해 복잡한 프로토콜 핸들링을 생략할 수 있다. 또한, TLS등의 전송 단의 보안 메커니증을 제공한다.
- 두 방식은 모두 IDL로, 메시지의 포맷을 정의한후 전용 컴파일러를 통해서 IDL로 정의된 메시지 포맷을 사용하고자 하는 언어에 맞는 코드로 변경르 해줘야 한다. 이 코드를 클라이언트와 서버의 코드에서 참조하여 코딩해야 IDL로 정의된 메시지를 직렬/역직렬화할 수 있다.

## Persistent Layer
- 처리할 데이터를 저장하는 공간

### RDBMS
- 요청을 처리하는 트랜잭션 처리용의 OLTP와 성격과 데이터를 모아서 분석하고 리포팅하는 OLAP로 분리된다.
- Query off Loading: DB의 성능 향상을 위한 기법, Update 트랜잭션과 Read 트랜잭션을 분리하는 기법. 마스터 DB에는 쓰기만을 허용하고, 마스터 DB의 내용을 중간의 Staging DB에 복사한다. Staging DB는 복제된 내용을 N개의 Slave DB로 복제한다. 읽기는 Slave DB에서만 가능하다. 일반적으로 애플리케이션 서버에서는 DB연결을 관리하기 위해서 커넥션 풀을 사용한다. 애플리케이션은 N개의 Slave DB에 대하 요청을 로드 밸런싱해야 한다. 또한, 특정 Slave DB에서 다른 Slave DB로 접근할 수 있도록 고가용성 기능을 제공해야 한다. 각 계층의 DB간의 데이터 복제는 CDC기술을 이용한다. DB는 일반적으로 데이터를 실제로 저장하기 전에 해당 작업에 대한 요청을 백로그에 저장하는데, CDC는 이 백로그를 이용해서 데이터를 복제한다.
- Sharding: DB의 용량 한계를 극복하기 위한 기술이다. 데이터를 여러개의 DB에 나눠 담는 방법이다. 나눠 담는 DB를 shard라 한다. 샤딩은 데이터 분산 방식에 따라 수직적/수평적으로 나뉜다. 샤딩 구현 방법은 DB, 프레임워크, 애플리케이션이 있다. 다른 샤드간의 데이터 조인이 불가능 하기 때문에 구현시 고려를 해야한다.

### 파일 시스템
- SDK: 프로그래밍 언어에서 지원되는 파일 시스템 접근용 API
- OS계층: 여러 종류의 다양한 파일 시스템을 같은 형태의 스토리지로 추상화해준다. 각 다양한 파일 시스템의 메타 정보를 inode에 저장하고, 파일 자체를 블록 단위로 나눠서 저장하는 구조로 추상화한다.
- 파일 시스템: FAT32, NTFS, ext3과 같이 OS에서 제공하는 네이티브 파일 시스템과 GFS, HDFS등이 있다.
- 스토리지 하드웨어: DAS(외장형 디스크), SAN(하나의 스토리지를 여러 개의 서버에서 나눠서 사용하는 스토리지), NFS(공유 파일 시스템으로, 서버가 다른 서버의 저장 공간을 공유해서 사용하는 방식)
- object storage: HTTP/REST와 같은 다른 파일 I/O 인터페이스를 이용한다. 다른 인터페이스를 사용하기 때문에 파일 시스템으로의 접근 OS에 대한 제약을 받지 않는다. 많은 사용자가 동시에 접속하는 대용량 파일 서비스 구조에 적합하다.

### NoSQL
- 단순한 데이터를 대용량으로 저장할 수 있으며 빠른 성능을 제공하는 DB
- 데이터 모델은 단순하게 키/값 형태의 저장 구조를 가지며 데이터 간의 관계등은 지원하지 않는다. 데이터를 빠르게 읽고 쓰는데 최적화되어 있다.


