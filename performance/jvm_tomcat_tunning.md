# JVM과 톰캣 튜닝

## JVM 튜닝
- JVM의 메모리의 구조와 GC는 애플리케이션의 응답 시간과 성능에 밀접한 관계를 가진다.

### GC
- 가비지 컬렉션으로 사용하지 않는 메모리를 자동으로 거둬들이는 기능
- JVM의 메모리 영역: 일반적으로 애플리케이션에서 사용되는 객체는 오래 유지되는 객체보다 잠시 사용되는 비율이 더 많다. 자바에서는 Perm영역, Young영역과 Old영역으로 메모리를 구분한다. Young은 생성된지 얼마 안된 객체들을 저장하고 Old는 생성된지 오래된 객체를 저장하는 장소이다. Perm은 class, method등의 코드가 저장되는 영역이다.

#### 기본 GC 알고리즘
- Minor GC: young의 GC를 minor GC라 한다. Young영역은 eden과 survivor영역으로 나뉜다. Eden은 자바 객체가 생성되자마자 저장되는 곳이다. 이렇게 생선된 객체는 Minor GC가 발생할때 survivor로 이동한다. Survivor는 Survivor1, 2로 나뉜다. Minor GC가 발생하면 eden과 survivor1에 활성 객체를 survivor2로 복사한다. 활성이 아닌 객체는 제거된다. 다음번 Minor GC가 발생하면 eden과 survivor2에 활성 객체를 survivor1로 옮기고 비활성은 제거한다. 이러한 Minor GC를 실행하다가 오래된 객체는 old로 옮겨진다. 이런 알고리즘을 Copy & Scavenge라고 한다. 속도가 매우 빠르며 작은 크기의 메모리를 콜렉팅하는데 매우 효과적이다. Minor GC는 자주 일어난다.
- Full GC: old의 GC의 이름, Mark & Compact라는 알고리즘을 사용한다. 전체 객체들의 참조를 확인 하면서 참조가 연결되지 않은 객체를 표시한다. 이러한 작업이 끝나면 표시된 객체를 삭제한다. 속도가 매운 느린 GC이고 Full GC가 일어나는 도중에는 순간적으로 자바 애플리케이션이 멈춰 버려서 성능에 아주 큰 영향을 준다.
- Full GC작업이 자바 애플리케이션을 멈추기 때문에 과부하나 시스템 정지를 불러오기 때문에 GC의 관리를 해야한다.

#### 다양한 GC 알고리즘
- Parallel GC: JDK 1.4이후 만들어진 것으로, 그전 버전의 GC는 하나의 스레드에서 이루어진다. 하나의 CPU에서 동시에 여러 스레드를 실행할 수 있는 하이퍼스레딩 기술이나 여러 개의 CPU의 보급으로 여러 스레드의 사용이 가능해져 GC에 도입한 것이다. Minor GC를 동시에 여러 개의 스레드를 이용해서 진행한다. 최소한 4CPU의 256 메모리를 가진 하드웨어에서 유용하게 사용된다. 또한, 두가지의 방법이 있는데 low-pause방식과 throughput 방식이 존재한다. low-pause는 concurrentGC와 함께 사용할 수 있다. throughput방식은 old GC는 mark&compact 방법만을 사용하게 되어 있지만 대신 minor GC때 신속한 수행을 지원한다.
- Concurrent GC: Full GC에 의해서 애플리케이션이 멈추는 현상을 최소화 하기 위한 방법, 애플리케이션을 멈추고 진행하는 것이 아니라 일부는 애플리케이션이 돌아가는 단계에서 수행하고 최소한의 작업만을 애플리케이션을 멈췄을 때 수행하는 방법이다.
- Incremental GC: 애플리케이션이 멈추는 시간을 줄이고자 하는데 있다. Minor GC가 일어날 때마다 old영역을 조금씩 GC해서 Full GC가 발생하는 횟수나 시간을 줄이는 방법이다. 많은 자원을 소모하고 Minor GC를 자주 일으키기 때문에 성능 저하가 할 수도 있기 때문에 테스트 후에 사용해야 한다.

#### GC 로그 수집과 분석 방법
- GC 상황에 대한 로그를 남기고자 하면 옵션을 사용한다. 자바 옵션 `-verbosegc`, GC 정보는 stdout으로 출력되기 때문에 `>` 리다이렉션등을 이용해서 파일로 저장할 수 있다.
- Heap size는 자바에서 `-ms`와 `-mx`옵션으로 조정할 수있다. 힙은 ms~mx사이에서 늘었다 줄었다 한다.
- Perm 크기 조정 옵션: 자바 애플리케이션 자체가 로딩되는 영역, `-XX:MaxPermSize=128m`식으로 지정할수 있다. 일반적으로 64~256m 사이가 적절하다.
- young과 old 영역 조정: `-XX:NewRatio=2` 또는 `-XX:NewSize=128m`등이 있다. 전체 힙을 기준으로 young과 old를 나눈다.
- survivor 영역: `-XX:SurvivorRatio=64`(eden/survivor 비율)이 있다.
- -server: 애플리케이션 서버와 같은 서버 환경에 최적화된 옵션이다. 서버 애플리케이션은 부팅 시간보다는 사용자에 대한 응답 시간이 중요하고, 많은 사용자가 동시에 사용하기 때문에 서버 옵션이 지원하는 Hotspot  Compiler는 자바 애플리케이션을 최적화해서 빠른 응답 시간을 내는데 집중되어 있다. 상대적으로 old가 작고 young이 크게 배정된다.
- -client: 클라이언트 애플리케이션에 최적화된 옵션. 응답 시간보다는 빨리 기동 되는 데에 최적화가 되어있다. 애플리케이션이 종료될 때까지 남아있는 객체의 비중이 높아서 상대적으로 Old영역의 비율이 높다.

#### JVM GC 튜닝
- 애플리케이션의 종류와 튜닝 목표 값 결정: 메모리를 적게 쓰는가 아니면 GC횟수를 줄이는가등의 목표를 정하고 목표치에 근접하도록 JVM 파라미터를 조정하는 것이 필요
- 힙 크기과 Perm 크기 설정: -ms와 -mx를 이용해서 힙 크기를 정한다. 서버 애플리케이션은 ms=mx로 하는 것이 메모리의 증가와 감소에 의한 불필요한 로드를 막을수 있어서 권장된다. 애플리케이션의 시간대별 메모리 사용량이 급격하게 변화가 있는 애플리케이션은 ms와 mx를 달리한다. Perm크기는 자바 서버 애플리케이션의 경우에는 64~128사이로 한다.
- 테스트와 로그 분석: GC 로그를 위한 -verbosegc를 적용한다. nGrinder와 같은 스트레스 테스트 도구로 부하를 줘서 로그를 수집한다. 
- Perm 크기 조정: 로그를 토대로 적정 perm영역을 조정한다.
- GC 수행시간 분석: Full GC에 걸리는 시간이 중요하다. Full GC가 길게 일어나서 수행에 드는 시간을 줄이고자 하면 Old 영역을 줄인다. Full GC가 일어나는 횟수가 많으면 Old영역을 늘려주면 된다. 양쪽을 모두 적게 하게 하려면 old영역을 줄이고 여러 개의 인스턴스를 동시에 띄워 로드 밸런싱을 해주면 부하가 분산된다.
- 파라미터 변경: 로그 분석에서 얻은 각 영역의 허용 범위를 기준으로 old/young영역을 조절하고 perm사이즈드을 조정한다. 또한 사용할 GC 알고리즘도 결정한다.
- Visual VM: GUI기반의 JVM 모니터링 도구
- JConsole: JVM 설치시 기본으로 설치되는 GUI기반의 JVM 모니터링 도구

## 톰캣 튜닝
- 톰캣의 대부분 튜닝 파라미터는 `server.xml` 파일에 정의된다.

### Listener 설정
- 톰캣이 기동할 때 root 사용자이면 기동을 하지 못하게 하는 옵션
- root 권한으로 서버가 실행되었기 때문에 각종 설정 파일이나 로그 파일들의 권한이 바뀌어서 서버 기동이 불가능 할 수있는 것을 막아준다.

### Connector 설정
- 프로토콜 설정: 톰캣은 네트워크 통신 부분에서 BIO, NIO, APR 세 가지의 옵션을 제공한다. NIO는 자바의 NIO라이브러리를 사용하는 것이다, APR은 아파치 웹 서버의 I/O모듈이며, C라이브러리를 JNI 인터페이스를 통해서 로딩해서 사용하여 속도는 빠르나 JNI쪽에 문제가 생기면 코어 덤프문제를 내며 죽어버려서 안정성으로는 BIO나 NIO가 낫다. BIO는 java socket I/O를 사용한다.
- acceptCount: 큐의 길이를 정의한다. HTTP 요청이 들어왔을 경우 유휴 스레드가 생길 때까지 요청을 기다리는 큐의 길이이다. 큐에 메시지가 쌓은 것은 장애 상태일 가능성이 크기 때문에 짧게 해주어서 에러 코드를 클라이언트로 빠르게 보내는게 좋다.
- enableLookups: 톰캣에서 실행되는 Servlet/JSP 코드중 들어오는 HTTP 요청에 대한 IP를 조회하는 명령이 있을 때 톰캣은 DNS서버에 DNS이름을 요청하는데 이것이 HTTP 요청 처리 중에 일어난다. 이렇게 되면 서버간의 라운드 트립시간이 발생하는데 false를 해두면 DNS Lookup없이 그냥 DNS 명을 반환한다.
- comression: HTTP 메시지 바디를 gzip 형태로 압축해서 반환한다. 업무가 이미지나 파일을 응답하는 경우에는 압축을 적용하여 네트워크 대역폭을 절약하겠지만 REST통신에서는 사용할 필요가 없다.
- maxConnection: 하나의 톰캣 인스턴스가 유지할 수 있는 연결의 수를 정의한다. 현재 연결된 실제 연결의 수가 아니라 현재 사용중인 소켓 FD의 수라는 것이다. TCP 연결은 연결이 끝나도 바로 소켓이 닫히지 않고 FIN 신호를 보내고 TIME_WAIT 시간을 거쳐 연결을 정리하기 때문에 단시간 내에 많은 요청을 처리하면 TIME_WAIT가 사용하는 FD 수 떄문에 최대 연결이 부족할 수 있다. 이외에도 HTTP 1.1 Keep Alive를 사용하게 되면 요청을 처리하지 않는 연결도 계속 유지된다.
- maxKeepAliveRequest: HTTP 1.1 keep alive 연결시 최대로 유지할 연결 수를 결정하는 옵션이다.
- maxThread: 톰캣 내의 스레드 수를 결정하는 옵션이고 순간 처리 가능한 트랜잭션 수를 의미한다.
- tcpNoDelay: TCP 프로토콜은 기본적으로 패킷을 보낼때 패킷 버퍼가 다 차면 보내는 로직이다. 이 옵션은 버퍼가 차지 않아도 바로 전송되게 하는 옵션이다. 전송속도가 빨라지나 작은 패킷을 여러번 보내 네트워크 트래픽이 증가한다.
- 톰캣 Lib 셋팅: 자바 애플리케이션에서 사용하는 라이브러리에 대한 메모리 사용률을 줄이는 방법인데, 하나의 톰캣에 여러 war파일을 동시 배포하게 되면 같은 라이브러리가 각각 다른 클래스 로더로 배포되기 때문에 메모리 효율성이 떨어진다. 이럴 경우 톰켓 홈의 /lib 디렉터리에 라이브러리를 배포하고 war파일에서는 라이브러를 제거하면 메모리 사용이 효율적이다. lib 디렉터리의 jar 파일들은 톰캣 인스턴스를 재가동해야 반영이 된다.

### JVM 튜닝
- JVM모드를 -server나 -client로 목적에 맞게 변경하는 것이다. 
- 이러한 최적화 옵션으로 상당 부분을 자동으로 관리할 수 있다.

### 메모리 옵션
- Full GC 시간을 줄이는 것이 관건이다.
- 일반적으로 자바 프로세스가 사용하는 메모리의 양이 2G를 안넘는 것이 Full GC를 줄이는 것이 좋다.
- 시스템의 가용 메모리가 많다면 힙을 넉넉히 잡는 것보다는 톰켓 인스턴스를 여러 개 띄워서 클러스터링이나 로드 밸런서로 묶는 방법을 권장한다.
- Out of memory: 사용이 끝난 객체를 릴리즈하지 않기 때문이다. 이러한 에러를 찾아내려면 그 순간의 메모리 레이아웃인 힙 덤프가 필요하다. `-XX: -HeapDumpOnOutOfMemoryError`를 적용하면 에러 발생시 순간적으로 힙 덤프를 떠서 파일로 저장한다.
- GC 옵션: Parallel GC + Concurrent GC는 거의 공식이다. Parallel GC에 대한 스레드 수는 전체 CPU 코어 수보다 적어햐 한다.
- GC 로그 옵션: GC 로그를 상세하게 해도 성능 저하는 거의 없다. TraceClassLoading은 클래스가 로딩되는 순간에 로그를 남겨준다. Out of memory 에러시 클래스에서 발생하는 경우에는 이를 사용한다.