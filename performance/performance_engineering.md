# 성능 엔지니어링의 정의와 범위
- 시스템의 목표 성능을 정의하고 이를 달성하기 위해서 시스템의 구조를 반복적으로 개선하는 작업
- 코드 상의 병목을 잡고 시스템의 설정을 바꿔서 성능을 높이는 튜닝을 말하기도 하며, 성능 목표의 정의 부터 최적의 성능을 위한 디자인 및 구현 같은 개발 초기의 설계 부분과 개발 후의 운영 단계 그리고 모니터링까지의 전과정을 말하기도 한다.

## 성능 엔지니어링의 시기
- 분석단계: 초기 요구 사항 분석 및 시스템 기획 단계에서는 성능에 대한 목표를 정해야한다. 목표 응답시간, 시스템을 사용할 총 사용자 수, 동시 접속자의 수 또는 시스템에 부하가 어떤 패턴으로 들어오는지를 정의하는 성능 모델이 필요하다.
- 디자인 단계: 목표 성능과 용량을 달성할 수 있는 규모로 시스템 설계를 진행한다. 시스템 디자인은 항상 피크 타임에 맞춰서 디자인 되며, 최대 성능을 기반으로 전체 시스템이 감당할 수 있는 용량과 응답 시간을 고려해야 한다. 사용할 기술을 선택한 다음 간단한 프로토타입을 구현하고 시나리오가 단순한 대규모 성능 및 용량 테스트를 해보는 것이 좋다.
- 개발 단계: 리스크가 높은 부분과 아키텍처에 관련된 부분, 난도가 높은 부분, 핵심 기능 등을 개발한다. 시스템의 아키텍처와 모듈들이 성능 목표를 달성할 수 있는지 지속적으로 테스트하고 튜닝을 수행
- 최종 테스트 단계: 개발된 최종 시스템에 대한 성능, 용량 부분의 측적, 미세 튜닝을 한다. 잘못된 설정과 코딩의 검증이 이뤄진다.
- 운영 단계: 모니터링 도구를 사용하여 지속적으로 성능을 모니터링하고 성능상에 문제가 있는 부분을 지속적으로 수정해야 한다. 운영 시스템의 로그를 수집하고 분석하여 성능 모델을 분석 및 보유해두는 것이 좋다.

## 시스템 용량 산정

### 응답 시간
- 사용자가 서버에 요청을 한 시간부터 응답을 받을 때까지의 모든 시간을 포함한다. 
- 네트워크 시간(서버에 요청을 보내고 받을 때 소요되는 시간) + 트랜잭션 시간(서버에서 실제 트랜잭션이 처리되는 시간) 
- 응답시간 + Think time(사용자가 보낸 요청에 대한 응답을 받고 웹 페이지를 보거나 화면을 보는 시간) = 요청 인터벌

### 동시 사용자
- 현재 시스템을 사용하는 사용자

### Active 사용자
- 현재 시스템에 트랜잭션을 실행하여 부하를 주는 사용자를 정의
- 이 사용자들의 수는 서버에서 순간 실행되고 있는 스레드 수나 프로세스의 수와 같다

### 트랜잭션
- 사용자로부터의 요청을 다루는 단위
- 리소스에 대한 로딩은 비즈니스 로직 처리보다 부하가 상대적으로 적고, 일반적으로 브라우저에 캐시되기 때문에 보통 서버 선능 측정시 리소스 로딩에 대한 부하는 트랜잭션으로 처리하지 않는 경우가 많다.

### TPS
- 초당 처리할 수 있는 트랜잭션의 양, 주로 서버의 성능 평가 기준이 된다.
- Active user/ 트랜잭션

### HPS
- 시스템이 처리할 수 있는 모든 웹 요청의 초당 처리량
- TPS에 리소스에 대한 요청 처리량을 포함한다.

### Peak Time
- 서버가 순간적으로 가장 부하를 많이 받는 순간
- 보통 서버의 용량 산정이나 성능 설계는 이 시간의 부하량을 기준으로 한다.

## 성능 엔지니어링의 절차

### 목표와 모델 정의
- 먼저 주요 업무 패턴이나 튜닝의 대상이 되는 시나리오의 개별 성능 목표를 정의
- 각 시나리오별의 사용 비중을 정의하고 성능 모델을 정의

### 부하 생성
- 생성된 모델에 따라서 부하를 생성해야 한다.
- Apache AB, Grinder, Apache JMeter등이 있다.
- 부하 테스트는 VCS를 통해서 관리하는 것이 좋다

### 테스트와 모니터링
- 테스트를 진행하면서 주요 성능 요인을 지속적으로 모니터링하고 기록해야한다.
- 애플리케이션 관점: 시스템의 성능을 측정해야 한다. 응답시간, TPS이 중요 측정 값이 된다.
- 미들웨어 관점: 미들웨어는 애플리케이션이 작동하기 위한 기본적인 솔루션, 각 성능 시나리오별로 거쳐 가는 모든 미들웨어를 모니터링 해야한다. 웹 서버쪽은 네트워크 아웃바운드 I/O쪽에서 발생할 때가 많다. 대부분의 성능 문제는 애플리케이션이 로직이 수행되는 애플리케이션 서버와 DB단에서 많이 발생한다. 애플리케이션은 스레드의 수와 큐의 길이가 대상이 된다. DB의 경우에는 슬로우 쿼리를 모니터링하면 특히 느리게 수행되는 쿼리들을 잡아서 튜닝할 수 있다.
- 인프라 관점: 하드웨어 인프라에 대한 부분을 지속적으로 모니터링해줘야 한다. 하드웨어가 해당 성능을 내기 용량이 충분한지, 병목이 생기지 않는지를 모니터링 한다.
- CPU: 목표 성능을 달성할 시에는 보통 70~80% 정도의 CPU를 사용하는 것이 좋고 항상 20~30%의 여유를 두는 것이 좋다.
- 메모리: 피크 타임 시에 얼마나 사용되느냐가 중요, 리눅스기반 시스템의 특성상 물리 메모리 이상의 메모리를 제공하기 위해 가상 메모리를 사용하는데 이를 위하여 스와핑을 사용하게 되면 디스크 I/O를 발생시켜 성능이 매우 떨어진다. 스와핑이 발생하면 전체 메모리 사용량을 줄이도록 튜닝하거나 물리 메모리를 늘리는 것이 필요하다.
- 디스트 I/O: 파일 시스템에 파일을 저장하거나 로그를 저장하는 등의 파일 시스템을 요구하는 모듈에서 많이 발생한다. iostat와 같은 명령어를 이용하면 iowait를 통해서 병목을 확인할 수 있다. 프로세스당 디스크 I/O는 iotop과 같은 도구를 사용하면 자세한 정보를 얻을 수 있다. 디스크 I/O가 많이 발생하는 로직은 비동기 방식으로 설계를 변경하는 방법이있다. 애플리케이션 차원에서는 DB앞에 Memcache와 같은 캐싱을 사용하거나, 로깅의 경우에는 메시지 큐를 사용하여 로그를 다른 서버에서 I/O를 분산할 수 있다. 또는 Back Write같은 방식으로 로그 메시지가 발생할 때마다 디스크에 쓰는 것이 아니라 20/ 30개씩 한꺼번에 디스크로 flushing하는 방식을 이용할 수 있다.
- 네트워크 I/O: 고용량의 파일이나, 이미지 전송에서 병목이 자주 발생한다. Reverse Proxy, NAT, 라우터, 로드 밸런서 등에서 많이 발생한다. 일정 부하가 되어도 시스템들의 CPU, 메모리등의 자원은 넉넉한데 네트워크 I/O가 일정 수준이상으로 올라가지 않는 경우가 있는데 병목 발생 지점일 가능성이 크다. 이러한 것은 소프트웨어 기반의 로드 벨런서나 소프트웨어 기반 NAT장비 에서 많이 발생한다. 정적 콘텐츠는 CDN을 이용하게 하는 방법과 여러 개의 NAT를 사용해서 로드를 분산하도록 하는 방법등이 있다.

### 튜닝
- 튜닝은 병목 구간이 발생한 부분에 대한 전문적인 지식이 필요하다.
- 문제 정의:  기본적으로 문제 자체를 구체적으로 정의하는 것이다. 또한, 문제점은 재현 가능해야 한다.
- 문제 분리: 문제가 발생하는 부분이 어딘지를 판단해야 한다. 성능 시나리오가 어떤 컴포넌트를 거치는지를 명확하게 할 필요가 있다.
- 문제 고립: 문제가 되는 구간을 다른 요인으로부터 분리시킨다.
- 문제 상세 분석: 근본적인 문제를 찾고자 원인을 파 내려간다. 프로파일링을 하거나 코드에 디버그 정보를 걸어서 문제의 원인을 분석하는 관정이다.
- 병목 발견 및 해결: 간단한 문제부터 근본적인 솔루션 특성이나 설계상의 오류일수도 있다. 비즈니스 시나리오 자체를 바꾸는 것도 고려할만한 방법이다.

## 성능 엔지니어링을 위해 필요한 것들
- 부하 테스트기: 소규모, 대규모 부하 발생 도구등이 있다.
- 모니터링 도구: 어느 구간이 문제가 있는지 현상이 어떤지를 파악하기 위하여 필요하다.
- 프로파일링 도구: 문제에 대한 근본적인 원인을 찾기 위한 도구들을 말한다. 대규모 부하 환경에서는 해당 시스템의 상태에 대한 스냅 샷을 추출할 수 있는 덤프 도구들을 많이 사용한다. 유닉스는 ptrace를 통해 시스템 콜을 모니터링 하거나 pmap을 이용하여 메모리 스냅샷등을 추출할 수도 있고, 자바는 스레드 덤프를 추출해서 병목 당시 애플리케이션이 어떤 작동을 하고 있었는지 찾아낼 수 있다.
- 역랑: 엔지니어로서의 컴퓨터, 프로그래밍, OS등에 대한 넓은 이해는 필수적
- 하드웨어, 미들웨어, 애플리케이션에 대한지식: 특정 솔루션에 대한 전문적인 지식이 필요하다.