## 4. var, scope, memory

### 원시 값과 참조 값
- 원시값은 단순한 데이터이며 참조 값은 여러 값으로 구성되는 객체이다. 참조 값은 메모리에 저장된 객체이다.
- 변수에 값을 할당하면 자바스크립트 엔진은 해당 값이 원시 데이터인지 참조인지 판단한다.
- 자바스크립트는 메모리에 직접 접근을 하지 못하므로 참조를 조작한다.

#### 동적 프로퍼티
```javascript
var person = new object();
person.name = 12;
alert(person.name)
```

- 참조 값을 다룰 떄는 언제든 프로퍼티와 메서드를 추가하거나 바꾸고 삭제할 수 있다.
- 원시 값에는 프로퍼티가 없지만 추가하려 해도 에러가 생기진 않는다.

#### 값 복사
- 원시 값을 다른 변수로 복사할 때는 현재 저장된 값을 새로 생성한 다음 새로운 변수에 복사한다.
- 참조 값도 다른 변수에 복사되기는 하지만 복사되는 것은 객체 자체가 아니라 힙에 저장된 객체를 가리키는 포인터이다.

#### 매개변수 전달
- 자바스크립트의 함수 매개변수는 모두 값으로 전달된다. 즉, 변수에 값을 전달하는 것과 같은 방식으로 원시 값, 참조 값 모두를 전달한다.
- 매개변수를 값 형태로 넘기면 해당 값은 지역 변수에 복사된다.
- 참조 형태로 넘기면 메모리 상의 값의 위치가 지역 변수에 저장되므로 지역 변수를 변경하면 함수 바깥에도 해당 변경 내용이 반영된다.

#### 타입 판별
- typeof 연산자는 문자열이나 숫자, 불리언, undefined라면 정확한 타입을 알 수 있다. 값이 객체나 null이면 objcet를 반환한다.
- instanceof 연산자는 변수가 주어진 참조 타입의 인스턴스일 때 true를 반환한다.

### 실행 컨텍스트와 스코프
- 변수나 함수의 실행 컨텍스트는 다른 데이터에 접근할 수 있는지, 어떻게 행동하는지를 규정한다.
- 각 실행 컨텍스트에는 변수 객체가 연결되어 있으며 해당 컨텍스트에서 정의된 모든 변수와 함수는 이 객체에 존재한다. 이 객체를 코드에서 접근할 수는 없지만 이면에서 데이터를 다룰 떄 이 객체를 이용한다.
- 가장 바깥에 존재하는 실행 컨텍스트는 전역 컨텍스트이다. 구현한 환경에 따라 이 컨텍스트를 부르는 이름이 다르다. 웹 브라우저에서는 `window라 부르므로 전역 변수와 함수는 모두 window 객체의 프로퍼티 및 메서드로 생성된다.
- 실행 컨텍스트는 포함된 코드가 모두 실행될 떄 파괴되는데, 이때 해당 컨텍스트 내부에서 정의된 변수와 함수도 모두 파괴된다. 전역 컨텍스트는 애플리케이션이 종료될 떄까지 유지된다.
- 함수를 호출하면 독자적인 실행 컨텍스트가 생성된다. 코드 실행이 함수로 들어갈 떄마다 함수의 컨텍스트가 컨텍스트 스택에 쌓인다. 함수 실행이 끝나면 해당 컨텍스트를 스택에서 꺼내고 컨트롤을 이전 컨텍스트에 반환한다.
- 컨텍스트에서 코드를 실행하면 변수 객체에 `스코프 체인`이 만들어진다. 스코프 체인의 목적은 실행 컨텍스트가 접근할 수 있는 모든 변수와 함수에 순서를 정의하는 것이다. 스코프 체인의 앞쪽은 항상 코드가 실행되는 컨텍스트의 변수 객체이다.
- 컨텍스트가 함수라면 활성화 객체를 변수 객체로 사용한다. 활성화 객체는 항상 arguments 변수 단 하나로 시작한다(이 변수는 전역 컨텍스트에는 존재하지 않는다). 변수 객체의 다음 순서는 해당 컨텍스트를 포함하는 컨텍스트이며 그 다음에는 다시 부모의 부모 컨텍스트이다. 이를 통하여 전역 컨텍스트에 도달할 떄까지 계속한다. 전역 컨테스트의 변수 객체는 항상 스코프 체인의 마지막에 존재한다.
- 식별자를 찾을 떄는 스코프 체인 순서를 따라가면서 해당 식별자 이름을 검색한다.

```javascript
var color = 'blue';
function changeColor(){
    // changeColor의 스코프 체인에는 객체가 두 개 있다.
    // 변수 객체(arguments)와 전역 컨텍스트의 변수 객체이다.
    // 변수 color는 함수의 스코프 체인에서 찾을 수 있다.
    if(color === 'blue'){
        color = 'red';
    }else{
        color = 'blue';
    }
}
```

- 로컬 컨텍스트에서는 지역 변수와 전역 변수를 모두 쓸 수 있다.
- 각 컨텍스트는 스코프 체인을 따라 상위 컨텍스트에서 변수나 함수를 검색할 수 있지만, 스코프 체인을 내려가며 검색할 수는 없다.

#### 스코프 체인 확장
- 실행 컨텍스트에는 전역 컨텍스트와 함수 컨텍스트 두 가지 타입만 있지만(eval()을 호출할 때 생성되는 타입이도 있다.) 스코프 체인을 확장할 수 있는 방법이 있다. 특정 문장은 스코프 체인 앞 부분에 임시로 변수 객체를 만들며 해당 변수 객체는 코드 실행이 끝나면 사라진다.
- try-catch의 catch와 with문은 모두 스코프 체인 앞에 변수 객체를 추가한다. with 문에서는 해당 객체가 스코프 체인에 추가되며 catch 문에서는 에러 객체를 선언하는 변수 객체가 생성된다.

```javascript
function buildUrl(){
    var qs = "?debug=true";

    with(location){ // location 객체가 스코프 체인에 추가된다.
        var url = href + qs;
    }
    return url;
}
```

#### 자바스크립트에는 블록 레벨 스코프가 없다
- 다른 언어에서는 중괄호로 감싼 코드 블록마다 스코프가 생성되어 조건에 따라 변수를 정의한다. 그러나 자바스크립트에서는 변수를 선언할 때 해당 변수를 현재 실행 컨텍스트에 추가한다.
- var를 사용해 선언한 변수는 자동으로 가장 가까운 컨텍스트에 추가한다. 변수를 선언하지 않은 채 초기화 하면 해당 변수는 자동으로 전역 컨텍스트에 추가된다.

```javascript
function add(num1, num2){
    sum = num1 + num2;  // 전역 컨텍스트에 추가됨
    return sum;
}

var result = add(10, 20);
alert(sum);
```

- 컨텍스트 안에서 식별자를 참조하려 하면 먼저 검색부터 해야 한다. 검색은 스코프 체인 앞에서 시작하며 주어진 이름으로 식별자를 찾는다. 전역 컨테스트까지 가서도 찾지 못하면 정의되지 않은 것으로 판단한다.
- 지역 컨텍스트에서 전역 컨텍스트의 변수를 참조하려면 전역 컨텍스트라는 것을 명시해야 한다.

### 가비지 콜렉션
- 자바스크립트는 실행 환경에서 코드 실행 중에 메모리를 관리한다. 이런 의미에서 가비지 콜렉션 언어라고 부른다.
- 자바스크립트는 필요한 메모리를 자동으로 할당하고 더 이상 사용하지 않는 메모리는 자동으로 회수하므로 개발자가 직접 메모리를 관리하지 않아도 된다.
- 더 이상 사용하지 않을 변수를 찾아내서 해당 변수가 차지하고 있던 메모리를 회수한다. 이 프로세스는 주기적으로 실행되는데 코드 실행 중에 특정 시점에서 메모리를 회수하도록 지정할 수도 있다.

#### 표시하고 지우기
- 자바스크립트에서 가장 널리 쓰이는 가비지 컬렉션 방법은 표시하고 지우기이다. 
- 변수가 특정 컨텍스트 안에서 사용할 것으로 정의되면 그 변수는 그 컨텍스트 안에 있는 것으로 표시된다. 컨텍스트 안에 존재하는 변수의 메모리는 해제해서는 안되는데, 해당 컨텍스트가 실행 중인 한 사용될 가능성이 있기 때문이다.
- 변수에 표시하는 방법은 여러가지 있다. 변수가 컨텍스트 안에 있을 떄 특정 비트를 on 상태로 표시할 수 있고, 컨텍스트 내부와 외부를 나타내는 변수 목록을 따로 두어 변수의 움직임을 추적할 수도 있다.
- 가비지 컬렉터가 작동하면 메모리에 저장된 변수 전체에 표시를 남긴다. 그 다음 컨텍스트에 있는 변수와 컨텍스트에 있는 변수가 참조하는 변수에서 표시를 지운다. 이 과정을 거친 다음에도 표시가 남아 있는 변수는 컨텍스트에 있는 변수와 무관하므로 삭제한다.

#### 참조 카운팅
- 각 값이 얼마나 많이 참조되었는지 추적한다. 값을 참조할수록 참조 카운트가 늘어난다. 참조하는 변수에 다른 값을 할당하면 원래 값의 참조 카운트가 줄어든다. 값의 참조 카운트가 0이되면 회수한다.
- 순환 참조라는 문제가 있다. 서로가 서로를 참조하는 변수가 있을 경우, 참조 카운트가 줄어들지 않는다. 그대로 계속 남게된다.
- 예전 익스플로러에서 BOM과 DOM은 c++의 COM으로 구현되었는데 COM은 참조 카운트로 가비지 컬렉션을 구현했다. 그래서 자바스크립트에서 표시 지우기 방식을 쓴다고 해도, COM으로 인하여 문제가 생길 수 있다. 순환 참조 문제를 피하려면 네이티브 자바스크립트 객체나 DOM 요소를 다 사용한 후에는 둘 사이의 연결을 끊어야 한다. 최신의 익스플로러는 모두 자바스크립트 객체로 만들었다.

#### 성능
- 인터넷 익스플로러는 할당 숫자에 따라 가비지 컬렉터를 실행한다. 각 요소들의 임계점 중 어느 하나라도 초과되면 가비지 컬렉터를 실행한다. 익스플로러7에서는 이를 해결하기위하여 임계점을 동적으로 변경하게 하였다. 가비지 컬렉션을 한 번 수행했을 때 할당된 메모리의 15%이상을 복구하지 못하면 임시로 임계점을 두배로 늘린다. 할당된 메모리의 85% 이상을 복구했다면 임계점을 기본 값으로 되돌린다.

#### 메모리 관리
- 웹 브라우저에서 사용할 수 있는 메모리는 일반적인 애플리케이션의 가용 메모리에 비해 매우 적다. 이런 이유는 웹 페이지에서 실행하는 자바스크립트가 시스템 메모리를 전부 사용해서 OS를 다운시키는 일을 방지하기 위함이다.
- 메모리 사용을 최적화하는 가장 좋은 방법은 코드 실행에 필요한 데이터만 유지하는 것이다. `필요없어진 데이터는 null을 할당하여 참조를 제거`하는 것이 좋다. 수동으로 참조 제거해야 할 대상은 주로 전역 변수 및 전역 객체의 프로퍼티이다. 지역 변수는 컨텍스트를 빠져나가는 순간 자동으로 참조가 제거된다.
- 변수에서 참조를 제거한다 해서 할당된 메모리가 자동으로 반환되는 것은 아니다. 참조 제거의 요점은 값의 컨텍스트를 없애서 다음에 가비지 콜렉션을 실행 할 떄 해당 메모리를 회수하도록 하는 것이다.